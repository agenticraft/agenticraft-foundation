{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AgentiCraft Foundation","text":"<p>Formally verified mathematical foundations for multi-agent AI coordination. AgentiCraft Foundation provides 8 modules spanning CSP process algebra, multiparty session types, protocol-aware routing, spectral topology analysis, and formal specification -- all with zero runtime dependencies. The library delivers the mathematical guarantees that production multi-agent systems need: deadlock freedom, trace refinement, protocol well-formedness, and topology resilience bounds.</p>"},{"location":"#architecture","title":"Architecture","text":"<pre><code>graph TB\n    subgraph algebra[\"algebra\"]\n        csp[\"CSP Operators&lt;br/&gt;&lt;i&gt;13 process primitives&lt;/i&gt;\"]\n        sem[\"Semantics&lt;br/&gt;&lt;i&gt;LTS, traces, deadlock&lt;/i&gt;\"]\n        eq[\"Equivalence&lt;br/&gt;&lt;i&gt;bisimulation, failures&lt;/i&gt;\"]\n        ref[\"Refinement&lt;br/&gt;&lt;i&gt;trace, failures, FD&lt;/i&gt;\"]\n        pat[\"Patterns&lt;br/&gt;&lt;i&gt;coordination templates&lt;/i&gt;\"]\n        csp --&gt; sem\n        sem --&gt; eq\n        sem --&gt; ref\n        csp --&gt; pat\n    end\n\n    subgraph mpst[\"mpst\"]\n        gt[\"Global Types&lt;br/&gt;&lt;i&gt;protocol specification&lt;/i&gt;\"]\n        lt[\"Local Types&lt;br/&gt;&lt;i&gt;projected per-role&lt;/i&gt;\"]\n        proj[\"Projector&lt;br/&gt;&lt;i&gt;global to local&lt;/i&gt;\"]\n        mon[\"Session Monitor&lt;br/&gt;&lt;i&gt;runtime checking&lt;/i&gt;\"]\n        gt --&gt; proj --&gt; lt --&gt; mon\n    end\n\n    subgraph topology[\"topology\"]\n        lap[\"Laplacian Analysis&lt;br/&gt;&lt;i&gt;spectral decomposition&lt;/i&gt;\"]\n        conn[\"Connectivity&lt;br/&gt;&lt;i&gt;vertex/edge, bridges&lt;/i&gt;\"]\n        hyper[\"Hypergraph&lt;br/&gt;&lt;i&gt;group coordination&lt;/i&gt;\"]\n        lap --- conn\n        lap --- hyper\n    end\n\n    subgraph protocols[\"protocols\"]\n        pg[\"Protocol Graph&lt;br/&gt;&lt;i&gt;G = (V, E, P, \u03a6, \u0393)&lt;/i&gt;\"]\n        route[\"Routing&lt;br/&gt;&lt;i&gt;Dijkstra, BFS, resilient&lt;/i&gt;\"]\n        semr[\"Semantic Routing&lt;br/&gt;&lt;i&gt;capability embeddings&lt;/i&gt;\"]\n        compat_node[\"Compatibility&lt;br/&gt;&lt;i&gt;translation costs&lt;/i&gt;\"]\n        wf[\"Workflows&lt;br/&gt;&lt;i&gt;W = (T, \u227a, \u03c1)&lt;/i&gt;\"]\n        tx[\"Transformers&lt;br/&gt;&lt;i&gt;composable T: M \u2192 M'&lt;/i&gt;\"]\n        pg --&gt; route\n        pg --&gt; semr\n        compat_node --&gt; route\n        compat_node --&gt; tx\n        pg --&gt; wf\n    end\n\n    subgraph verification[\"verification\"]\n        inv[\"Invariant Checker&lt;br/&gt;&lt;i&gt;runtime assertions&lt;/i&gt;\"]\n        ctl[\"CTL Model Checker&lt;br/&gt;&lt;i&gt;AG, AF, EF, AU&lt;/i&gt;\"]\n        dtmc[\"Probabilistic (DTMC)&lt;br/&gt;&lt;i&gt;reachability, steady-state&lt;/i&gt;\"]\n        cex[\"Counterexamples&lt;br/&gt;&lt;i&gt;structured explanations&lt;/i&gt;\"]\n        inv --- ctl\n        ctl --- dtmc\n        ctl --- cex\n    end\n\n    subgraph specs[\"specifications\"]\n        formal[\"Consensus Properties&lt;br/&gt;&lt;i&gt;agreement, validity&lt;/i&gt;\"]\n        wcon[\"Weighted Consensus&lt;br/&gt;&lt;i&gt;quality-weighted quorum&lt;/i&gt;\"]\n        mas[\"MAS Mappings&lt;br/&gt;&lt;i&gt;BDI, Contract Net&lt;/i&gt;\"]\n        formal --- wcon\n        formal --- mas\n    end\n\n    subgraph complexity_mod[\"complexity\"]\n        bounds[\"Complexity Bounds&lt;br/&gt;&lt;i&gt;30+ theoretical limits&lt;/i&gt;\"]\n        faults[\"Fault Models&lt;br/&gt;&lt;i&gt;classical + LLM-specific&lt;/i&gt;\"]\n        bounds --- faults\n    end\n\n    pat -.-&gt;|\"coordination&lt;br/&gt;patterns\"| gt\n    ref -.-&gt;|\"property&lt;br/&gt;checking\"| formal\n    lap -.-&gt;|\"topology&lt;br/&gt;metrics\"| pg\n    hyper -.-&gt;|\"group&lt;br/&gt;structure\"| wf\n\n    style algebra fill:#0d94881a,stroke:#0D9488\n    style mpst fill:#0d94881a,stroke:#0D9488\n    style topology fill:#0d94881a,stroke:#0D9488\n    style protocols fill:#0d94881a,stroke:#0D9488\n    style verification fill:#0d94881a,stroke:#0D9488\n    style specs fill:#0d94881a,stroke:#0D9488\n    style complexity_mod fill:#0d94881a,stroke:#0D9488</code></pre>"},{"location":"#modules-at-a-glance","title":"Modules at a Glance","text":"Module Description Tests algebra CSP process algebra -- 13 operators, LTS semantics, trace/failures refinement, deadlock detection 219 mpst Multiparty session types -- global/local types, projection, session monitoring, well-formedness checking 270 protocols Protocol-aware routing -- protocol graphs, Dijkstra/BFS/resilient routing, compatibility matrices, workflows 259 topology Spectral topology analysis -- Laplacian decomposition, algebraic connectivity, hypergraph group coordination 57 specifications Formal specifications -- consensus properties, weighted quorum, BDI and Contract Net mappings 65 complexity Complexity theory -- 30+ theoretical bounds, classical and LLM-specific fault models 44 verification Verification -- CTL temporal logic model checking, DTMC probabilistic analysis, invariant checking, counterexample generation 199 integration Integration adapters -- MPST bridge for protocol session types, CSP orchestration for workflow verification 52 <p>Total: 8 modules, 1,165 tests, ~20K LOC, zero dependencies.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Getting Started: Installation -- install the package and set up a development environment</li> <li>Getting Started: Quick Start -- four self-contained examples covering the core modules</li> <li>Getting Started: Why Formal Methods? -- when and why to use formal verification for multi-agent systems</li> <li>API Reference -- complete module and class reference</li> <li>Concepts -- detailed explanations of the mathematical foundations</li> <li>Tutorials -- step-by-step walkthroughs for common tasks</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to agenticraft-foundation are documented here.</p>"},{"location":"changelog/#010-2026-02-26","title":"0.1.0 (2026-02-26)","text":"<p>Initial release of the formally verified mathematical foundations for multi-agent AI coordination.</p>"},{"location":"changelog/#added","title":"Added","text":""},{"location":"changelog/#process-algebra-algebra","title":"Process Algebra (<code>algebra</code>)","text":"<ul> <li>13 CSP operators: 8 core primitives (Stop, Skip, Prefix, ExternalChoice, InternalChoice, Parallel, Sequential, Hiding) + 5 agent-specific extensions (Interrupt, Timeout, Guard, Rename, Pipe)</li> <li>Recursion support: <code>Recursion</code>, <code>Variable</code>, <code>substitute()</code> with full operator compatibility</li> <li>Operational semantics: <code>build_lts()</code> for labeled transition systems, <code>traces()</code> for trace extraction, <code>detect_deadlock()</code> and <code>is_deadlock_free()</code> for deadlock analysis</li> <li>Process equivalence: trace equivalence, strong/weak bisimulation, failures equivalence</li> <li>Refinement checking: trace refinement, failures refinement, failures-divergence refinement</li> <li>6 coordination patterns: request-response, pipeline, scatter-gather, barrier, mutex, producer-consumer</li> </ul>"},{"location":"changelog/#multiparty-session-types-mpst","title":"Multiparty Session Types (<code>mpst</code>)","text":"<ul> <li>Global types: protocol specification with multi-party interactions</li> <li>Local types: per-role projected views via <code>Projector</code></li> <li>Well-formedness checking: <code>SessionTypeChecker</code> validates protocol structure</li> <li>Session monitoring: <code>SessionMonitor</code> for runtime conformance checking</li> <li>4 communication patterns: request-response, pipeline, scatter-gather, consensus</li> </ul>"},{"location":"changelog/#protocol-graph-model-protocols","title":"Protocol Graph Model (<code>protocols</code>)","text":"<ul> <li>Protocol graph: <code>ProtocolGraph</code> with \\(G = (V, E, P, \\Phi, \\Gamma)\\) model</li> <li>Routing algorithms: <code>ProtocolAwareDijkstra</code> (minimum-cost), <code>ProtocolConstrainedBFS</code> (minimum-hop), <code>ResilientRouter</code> (failover), <code>SemanticRouter</code> (capability-based)</li> <li>Protocol compatibility: <code>ProtocolCompatibilityMatrix</code> with translation cost modeling</li> <li>Path cost calculation: <code>PathCostCalculator</code> with configurable edge cost models</li> <li>Protocol transformers: composable \\(T: M_p \\to M_{p'}\\) with lossless/lossy/destructive classification</li> <li>Workflow validation: <code>WorkflowValidator</code> and <code>OptimalProtocolAssigner</code> for \\(W = (T, \\prec, \\rho)\\) workflows</li> <li>Formal specifications: protocol property definitions</li> </ul>"},{"location":"changelog/#spectral-topology-topology","title":"Spectral Topology (<code>topology</code>)","text":"<ul> <li>Laplacian analysis: <code>LaplacianAnalysis</code> with algebraic connectivity (\\(\\lambda_2\\)), consensus convergence bounds</li> <li>Connectivity: vertex/edge connectivity, bridge detection, component analysis</li> <li>Hypergraph topology: <code>HypergraphNetwork</code> with \\(L_H = D_v - H W D_e^{-1} H^T\\), group coordination metrics, factory constructors (<code>from_graph</code>, <code>clique_expansion</code>)</li> </ul>"},{"location":"changelog/#formal-specifications-specifications","title":"Formal Specifications (<code>specifications</code>)","text":"<ul> <li>Consensus properties: Agreement, Validity, Integrity, Termination</li> <li>Weighted consensus: <code>WeightedConsensusState</code>, <code>WeightedAgreement</code>, <code>WeightedQuorum</code> with \\(2W/3\\) threshold</li> <li>MAS theory mappings: <code>BDIMapping</code>, <code>JointIntentionMapping</code>, <code>SharedPlanMapping</code>, <code>ContractNetMapping</code> with bidirectional preservation</li> </ul>"},{"location":"changelog/#complexity-analysis-complexity","title":"Complexity Analysis (<code>complexity</code>)","text":"<ul> <li>30+ complexity bounds: consensus, gossip, leader election, broadcast, mesh communication</li> <li>Complexity annotations: decorator-based tracking with <code>ComplexityClass</code></li> <li>8 fault models: 4 classical (crash-stop, crash-recovery, Byzantine, omission) + 4 LLM-specific (hallucination, prompt injection, non-determinism, context overflow)</li> <li>Impossibility results: FLP theorem, Byzantine fault tolerance bounds</li> </ul>"},{"location":"changelog/#verification-verification","title":"Verification (<code>verification</code>)","text":"<ul> <li>Invariant checker: <code>InvariantChecker</code> for runtime state assertions, transition monitoring, violation tracking</li> <li>CTL temporal logic: <code>model_check()</code> with full CTL formula AST (<code>AG</code>, <code>AF</code>, <code>EF</code>, <code>EG</code>, <code>AU</code>, <code>EU</code>, <code>AX</code>, <code>EX</code>), backward fixpoint algorithms, counterexample traces</li> <li>Probabilistic verification: <code>DTMC</code> model with <code>check_reachability()</code>, <code>steady_state()</code>, <code>expected_steps()</code>, Gaussian elimination solver</li> <li>Counterexample generation: <code>explain_refinement_failure()</code>, <code>explain_equivalence_failure()</code> for structured failure diagnostics</li> <li>Convenience checkers: <code>check_safety()</code>, <code>check_liveness()</code>, <code>check_reachability()</code>, <code>check_temporal_invariant()</code></li> </ul>"},{"location":"changelog/#integration-integration","title":"Integration (<code>integration</code>)","text":"<ul> <li>MPST bridge: adapter applying session types to protocol verification (MCP/A2A)</li> <li>CSP orchestration: adapter applying CSP processes to workflow verification (DAG-to-CSP)</li> </ul>"},{"location":"changelog/#package","title":"Package","text":"<ul> <li>Zero runtime dependencies, pure Python</li> <li>Python 3.10, 3.11, 3.12, 3.13 support</li> <li>1,165 tests with 89%+ coverage</li> <li>Apache 2.0 license</li> <li>Type-checked with mypy strict mode</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#dev-setup","title":"Dev Setup","text":"<pre><code>git clone &lt;repo-url&gt;\ncd agenticraft-foundation\nuv sync --group dev\nuv run pytest tests/ -v\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Formatter/linter: Ruff (line-length 100, target <code>py310</code>)</li> <li>Type checker: mypy in strict mode</li> <li>Docstrings: Google style</li> <li>Imports: Always use <code>from __future__ import annotations</code> at the top of every module</li> </ul> <p>Standard import order:</p> <pre><code>from __future__ import annotations\n\nimport logging\nfrom typing import TYPE_CHECKING, Any\n\nif TYPE_CHECKING:\n    from some_module import SomeType\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<ul> <li>Framework: pytest</li> <li>Coverage minimum: 85%</li> <li>Test naming: <code>test_&lt;module&gt;_&lt;function&gt;_&lt;scenario&gt;</code></li> <li>Marks:<ul> <li><code>@pytest.mark.slow</code> -- long-running tests</li> <li><code>@pytest.mark.integration</code> -- integration tests</li> </ul> </li> </ul>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Full test suite\nuv run pytest tests/ -v\n\n# With coverage report\nuv run pytest tests/ --cov=agenticraft_foundation --cov-report=html\n\n# Only fast tests\nuv run pytest tests/ -v -m \"not slow\"\n\n# Single file\nuv run pytest tests/test_algebra.py -v\n</code></pre>"},{"location":"contributing/#linting","title":"Linting","text":"<pre><code># Check for lint errors\nuv run ruff check src/ tests/\n\n# Auto-format\nuv run ruff format src/ tests/\n\n# Type check\nuv run mypy src/\n</code></pre>"},{"location":"contributing/#pr-process","title":"PR Process","text":""},{"location":"contributing/#branch-naming","title":"Branch Naming","text":"<ul> <li><code>feat/&lt;name&gt;</code> -- new features</li> <li><code>fix/&lt;name&gt;</code> -- bug fixes</li> <li><code>docs/&lt;name&gt;</code> -- documentation changes</li> </ul>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<p>Use conventional commit format:</p> <pre><code>feat(algebra): add new CSP operator\nfix(topology): correct eigenvalue computation\ndocs(examples): add consensus walkthrough\nrefactor(mpst): simplify projection logic\ntest(protocols): add edge case coverage\nchore(ci): update GitHub Actions workflow\n</code></pre>"},{"location":"contributing/#guidelines","title":"Guidelines","text":"<ul> <li>Keep PRs focused on a single change.</li> <li>Include tests for new functionality.</li> <li>Ensure all existing tests pass before submitting.</li> <li>Run the linter and formatter before pushing.</li> </ul>"},{"location":"contributing/#adding-new-modules","title":"Adding New Modules","text":"<ol> <li>Follow the patterns established by existing modules (e.g., <code>algebra</code>, <code>topology</code>, <code>mpst</code>).</li> <li>Add comprehensive tests in the <code>tests/</code> directory.</li> <li>Export public API symbols from <code>__init__.py</code>.</li> <li>Add type annotations to all public functions and classes.</li> <li>Write Google-style docstrings for all public APIs.</li> </ol>"},{"location":"api/","title":"API Reference","text":"<p>Auto-generated reference documentation for all <code>agenticraft-foundation</code> modules.</p>"},{"location":"api/#package-structure","title":"Package Structure","text":"Module Description Source Files <code>types</code> Shared type definitions (<code>ProtocolName</code> enum) 1 <code>algebra</code> CSP process algebra \u2014 13 operators, LTS semantics, equivalence, refinement 8 <code>mpst</code> Multiparty Session Types \u2014 global/local types, projection, monitoring 7 <code>protocols</code> Protocol graph model \u2014 routing, workflows, transformers, compatibility 10 <code>topology</code> Spectral graph analysis \u2014 Laplacian, connectivity, hypergraph 4 <code>specifications</code> Consensus properties, weighted consensus, MAS theory mappings 3 <code>complexity</code> Complexity bounds, fault models, annotations 2 <code>verification</code> CTL temporal logic, DTMC probabilistic analysis, invariant checking, counterexamples 4 <code>integration</code> Protocol session type and workflow verification adapters 2"},{"location":"api/#top-level-exports","title":"Top-Level Exports","text":"<p>The package re-exports the most commonly used symbols from <code>agenticraft_foundation</code>:</p> <pre><code>from agenticraft_foundation import (\n    # CSP Core\n    Event, Process, ProcessKind,\n    Stop, Skip, Prefix, ExternalChoice, InternalChoice,\n    Parallel, Sequential, Hiding,\n    Recursion, Variable, substitute,\n    # Agent Extensions\n    Interrupt, Timeout, Guard, Rename, Pipe, TIMEOUT_EVENT,\n    # Semantics\n    traces, build_lts, detect_deadlock, is_deadlock_free,\n    # Topology\n    LaplacianAnalysis,\n    # Session Types\n    SessionMonitor,\n)\n</code></pre> <p>For full subpackage APIs, import from the specific module:</p> <pre><code>from agenticraft_foundation.algebra import trace_refines, failures_refines\nfrom agenticraft_foundation.mpst import Projector, SessionTypeChecker\nfrom agenticraft_foundation.protocols import ProtocolGraph, ProtocolAwareDijkstra\nfrom agenticraft_foundation.topology import NetworkGraph, HypergraphNetwork\n</code></pre>"},{"location":"api/types/","title":"agenticraft_foundation.types","text":"<p>Shared type definitions used across all modules.</p> <p>Foundation Types for the AgentiCraft Mesh.</p> <p>Core type definitions that sit at the foundation layer, enabling both formal verification and runtime services to share common abstractions without circular dependencies.</p> <p>This module contains protocol-agnostic enumerations and types that are used across the mesh foundation and services layers.</p> <p>Version: 0.1.0 Date: 2025-12-20</p>"},{"location":"api/types/#agenticraft_foundation.types.ProtocolName","title":"<code>ProtocolName</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported agent communication protocols.</p> <p>This foundational type enables protocol-aware routing, formal verification, and cross-protocol bridging throughout the mesh.</p> Protocols <p>MCP: Model Context Protocol (Anthropic) - Agent-to-Tool communication A2A: Agent-to-Agent Protocol (Google) - Agent-to-Agent communication ANP: Agent Network Protocol (W3C) - Decentralized P2P networks CUSTOM: Custom protocol adapters for extension</p>"},{"location":"api/types/#agenticraft_foundation.types.ProtocolName.MCP","title":"<code>MCP = 'mcp'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Model Context Protocol - Agent-to-Tool interactions.</p>"},{"location":"api/types/#agenticraft_foundation.types.ProtocolName.A2A","title":"<code>A2A = 'a2a'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Agent-to-Agent Protocol - Agent coordination and task delegation.</p>"},{"location":"api/types/#agenticraft_foundation.types.ProtocolName.ANP","title":"<code>ANP = 'anp'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Agent Network Protocol - Decentralized peer-to-peer mesh.</p>"},{"location":"api/types/#agenticraft_foundation.types.ProtocolName.CUSTOM","title":"<code>CUSTOM = 'custom'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Custom protocol adapter for extensibility.</p>"},{"location":"api/algebra/","title":"algebra","text":"<p>CSP process algebra for modeling multi-agent coordination.</p> <p>This module provides 13 CSP operators (8 core primitives + 5 agent-specific extensions), operational semantics (LTS construction, trace extraction, deadlock detection), process equivalence checking, refinement verification, and 6 coordination patterns.</p> <p>Process Algebra module for formal verification of agent coordination.</p> <p>This module provides: - CSP (Communicating Sequential Processes) primitives - Labeled Transition Systems (LTS) for operational semantics - Process equivalence (trace equivalence, bisimulation) - Refinement checking for specification verification - Coordination patterns for multi-agent systems</p> <p>Based on: - Hoare (1985) - Communicating Sequential Processes - Milner (1980) - Calculus of Communicating Systems - Roscoe (1998) - The Theory and Practice of Concurrency</p>"},{"location":"api/algebra/#submodules","title":"Submodules","text":"Module Description <code>csp</code> 13 process classes \u2014 Stop, Skip, Prefix, ExternalChoice, InternalChoice, Parallel, Sequential, Hiding, Interrupt, Timeout, Guard, Rename, Pipe, Recursion, Variable <code>semantics</code> LTS construction, trace extraction, deadlock detection <code>equivalence</code> Trace equivalence, bisimulation, failures equivalence <code>refinement</code> Trace, failures, and failures-divergence refinement <code>patterns</code> 6 coordination patterns"},{"location":"api/algebra/csp/","title":"agenticraft_foundation.algebra.csp","text":"<p>CSP process definitions \u2014 13 operators implementing the full <code>Process</code> contract.</p> <p>CSP (Communicating Sequential Processes) implementation.</p> <p>Based on Hoare (1985) - Communicating Sequential Processes.</p> <p>This module provides: - Core process primitives (STOP, SKIP, Prefix) - Choice operators (external \u25a1, internal \u2293) - Parallel composition (interleaving ||, synchronized |[A]|) - Sequential composition (;) - Hiding (P \\ H)</p> <p>Key Concepts: - Process: Entity that can engage in events - Event: Atomic unit of communication/action - Alphabet: Set of events a process can engage in - Trace: Sequence of events performed by a process</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Event","title":"<code>Event</code>","text":"<p>               Bases: <code>str</code></p> <p>An event in CSP.</p> <p>Events are atomic units of communication or action. The special event \"\u2713\" (TICK) indicates successful termination.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.ProcessKind","title":"<code>ProcessKind</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Classification of process types.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Process","title":"<code>Process</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for CSP processes.</p> <p>A process is characterized by: - alphabet: The set of events it can engage in - initials: The initial events it can perform - after(e): The process after performing event e</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Process.kind","title":"<code>kind</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Process classification.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Process.alphabet","title":"<code>alphabet()</code>  <code>abstractmethod</code>","text":"<p>Return the alphabet (set of events) this process can engage in.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Process.initials","title":"<code>initials()</code>  <code>abstractmethod</code>","text":"<p>Return the set of initial events the process can perform.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Process.after","title":"<code>after(event)</code>  <code>abstractmethod</code>","text":"<p>Return the process after performing the given event.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to perform</p> <p> TYPE: <code>Event</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>The resulting process after the event</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the event cannot be performed</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Process.can_perform","title":"<code>can_perform(event)</code>","text":"<p>Check if the process can perform the given event.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Process.is_deadlocked","title":"<code>is_deadlocked()</code>","text":"<p>Check if the process is deadlocked (no possible events).</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Process.is_terminated","title":"<code>is_terminated()</code>","text":"<p>Check if the process has successfully terminated.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Stop","title":"<code>Stop</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Process</code></p> <p>STOP - The deadlocked process.</p> <p>STOP cannot perform any events. It represents deadlock.</p> <p>Properties: - alphabet(STOP) = {} - initials(STOP) = {} - traces(STOP) = {\u27e8\u27e9}</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Skip","title":"<code>Skip</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Process</code></p> <p>SKIP - Successful termination.</p> <p>SKIP can only perform the tick event (\u2713) and then becomes STOP.</p> <p>Properties: - alphabet(SKIP) = {\u2713} - initials(SKIP) = {\u2713} - traces(SKIP) = {\u27e8\u27e9, \u27e8\u2713\u27e9}</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Prefix","title":"<code>Prefix</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Process</code></p> <p>a \u2192 P (Prefix/Guarding).</p> <p>Prefix performs event 'a' and then behaves as process P.</p> <p>Properties: - alphabet(a \u2192 P) = {a} \u222a alphabet(P) - initials(a \u2192 P) = {a} - (a \u2192 P) \u2500a\u2192 P</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.ExternalChoice","title":"<code>ExternalChoice</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Process</code></p> <p>P \u25a1 Q (External Choice).</p> <p>The environment chooses between P and Q based on the initial event.</p> <p>Properties: - alphabet(P \u25a1 Q) = alphabet(P) \u222a alphabet(Q) - initials(P \u25a1 Q) = initials(P) \u222a initials(Q) - P \u25a1 Q \u2500a\u2192 P' if P \u2500a\u2192 P' and a \u2209 initials(Q) - P \u25a1 Q \u2500a\u2192 Q' if Q \u2500a\u2192 Q' and a \u2209 initials(P) - P \u25a1 Q \u2500a\u2192 P' \u25a1 Q' if P \u2500a\u2192 P' and Q \u2500a\u2192 Q' (deterministic)</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.ExternalChoice.after","title":"<code>after(event)</code>","text":"<p>Resolve external choice by performing an event.</p> <p>When both branches offer the event, the left branch is chosen by convention (deterministic resolution).</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to perform.</p> <p> TYPE: <code>Event</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>Continuation process after performing the event.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If neither branch can perform the event.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.InternalChoice","title":"<code>InternalChoice</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Process</code></p> <p>P \u2293 Q (Internal/Nondeterministic Choice).</p> <p>The process internally chooses between P and Q. The environment has no control over which branch is taken.</p> <p>Properties: - alphabet(P \u2293 Q) = alphabet(P) \u222a alphabet(Q) - initials(P \u2293 Q) = initials(P) \u222a initials(Q) - P \u2293 Q \u2500\u03c4\u2192 P (internal transition to P) - P \u2293 Q \u2500\u03c4\u2192 Q (internal transition to Q)</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Parallel","title":"<code>Parallel</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Process</code></p> <p>P |[A]| Q (Generalized Parallel Composition).</p> <p>P and Q run in parallel, synchronizing on events in A. - Events in A require both processes to participate - Events not in A can be performed independently</p> <p>Special cases: - P ||| Q (A = {}) : Interleaving (no synchronization) - P || Q (A = alphabet(P) \u2229 alphabet(Q)) : Alphabetized parallel</p> <p>Properties: - alphabet(P |[A]| Q) = alphabet(P) \u222a alphabet(Q) - For a \u2208 A: P |[A]| Q \u2500a\u2192 P' |[A]| Q' iff P \u2500a\u2192 P' and Q \u2500a\u2192 Q' - For a \u2209 A: P |[A]| Q \u2500a\u2192 P' |[A]| Q iff P \u2500a\u2192 P'</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Sequential","title":"<code>Sequential</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Process</code></p> <p>P ; Q (Sequential Composition).</p> <p>P runs first, and when it terminates (performs \u2713), Q starts.</p> <p>Properties: - alphabet(P ; Q) = (alphabet(P) - {\u2713}) \u222a alphabet(Q) - initials(P ; Q) = initials(P) - {\u2713}  if \u2713 \u2209 initials(P)                   = (initials(P) - {\u2713}) \u222a initials(Q)  if \u2713 \u2208 initials(P) - P ; Q \u2500a\u2192 P' ; Q if P \u2500a\u2192 P' and a \u2260 \u2713 - P ; Q \u2500\u03c4\u2192 Q if P \u2500\u2713\u2192 (starts Q after P terminates)</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Hiding","title":"<code>Hiding</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Process</code></p> <p>P \\ H (Hiding).</p> <p>Events in H are hidden (become internal \u03c4 actions).</p> <p>Properties: - alphabet(P \\ H) = alphabet(P) - H - P \\ H \u2500a\u2192 P' \\ H if P \u2500a\u2192 P' and a \u2209 H - P \\ H \u2500\u03c4\u2192 P' \\ H if P \u2500a\u2192 P' and a \u2208 H</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Recursion","title":"<code>Recursion</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Process</code></p> <p>\u03bcX.P (Recursion).</p> <p>Recursive process definition where X is bound in P.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Recursion.unfold","title":"<code>unfold()</code>","text":"<p>Unfold one level of recursion.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.Variable","title":"<code>Variable</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Process</code></p> <p>X (Recursion Variable).</p> <p>A reference to a bound recursion variable.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.substitute","title":"<code>substitute(process, var_name, replacement)</code>","text":"<p>Substitute all occurrences of a named variable with a process.</p> <p>Recursively traverses the process tree, replacing each <code>Variable</code> node whose name matches var_name with replacement. Respects variable shadowing in <code>Recursion</code> nodes.</p> PARAMETER DESCRIPTION <code>process</code> <p>The process tree to transform.</p> <p> TYPE: <code>Process</code> </p> <code>var_name</code> <p>Name of the variable to replace.</p> <p> TYPE: <code>str</code> </p> <code>replacement</code> <p>Process to substitute in place of the variable.</p> <p> TYPE: <code>Process</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>A new process tree with all matching variables replaced.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.stop","title":"<code>stop()</code>","text":"<p>Create STOP process.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.skip","title":"<code>skip()</code>","text":"<p>Create SKIP process.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.prefix","title":"<code>prefix(event, continuation)</code>","text":"<p>Create prefix process: event \u2192 continuation.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.choice","title":"<code>choice(left, right)</code>","text":"<p>Create external choice: left \u25a1 right.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.internal_choice","title":"<code>internal_choice(left, right)</code>","text":"<p>Create internal choice: left \u2293 right.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.parallel","title":"<code>parallel(left, right, sync=None)</code>","text":"<p>Create parallel composition: left |[sync]| right.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.interleave","title":"<code>interleave(left, right)</code>","text":"<p>Create interleaving: left ||| right.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.sequential","title":"<code>sequential(first, second)</code>","text":"<p>Create sequential composition: first ; second.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.hide","title":"<code>hide(process, hidden)</code>","text":"<p>Create hiding: process \\ hidden.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.rec","title":"<code>rec(variable, body)</code>","text":"<p>Create recursion: \u03bcvariable.body.</p>"},{"location":"api/algebra/csp/#agenticraft_foundation.algebra.csp.var","title":"<code>var(name)</code>","text":"<p>Create recursion variable.</p>"},{"location":"api/algebra/equivalence/","title":"agenticraft_foundation.algebra.equivalence","text":"<p>Process equivalence checking \u2014 trace equivalence, strong/weak bisimulation, and failures equivalence.</p> <p>Process equivalence checking for CSP.</p> <p>This module provides: - Trace equivalence: P =_T Q iff traces(P) = traces(Q) - Strong bisimulation: P \u223c Q (finest equivalence) - Weak bisimulation: P \u2248 Q (observational equivalence) - Failures equivalence: P =_F Q (CSP standard)</p> <p>Equivalence hierarchy (finest to coarsest)::</p> <pre><code>Strong bisimulation (\u223c)\n    \u2282 Weak bisimulation (\u2248)\n        \u2282 Failures equivalence (=_F)\n            \u2282 Trace equivalence (=_T)\n</code></pre>"},{"location":"api/algebra/equivalence/#agenticraft_foundation.algebra.equivalence.EquivalenceResult","title":"<code>EquivalenceResult</code>  <code>dataclass</code>","text":"<p>Result of an equivalence check.</p>"},{"location":"api/algebra/equivalence/#agenticraft_foundation.algebra.equivalence.Failure","title":"<code>Failure</code>  <code>dataclass</code>","text":"<p>A failure: (trace, refusal set).</p>"},{"location":"api/algebra/equivalence/#agenticraft_foundation.algebra.equivalence.trace_equivalent","title":"<code>trace_equivalent(p, q, max_trace_length=100)</code>","text":"<p>Check trace equivalence: traces(P) = traces(Q).</p> <p>Two processes are trace equivalent if they can perform exactly the same sequences of visible events.</p> PARAMETER DESCRIPTION <code>p</code> <p>First process or LTS</p> <p> TYPE: <code>Process | LTS</code> </p> <code>q</code> <p>Second process or LTS</p> <p> TYPE: <code>Process | LTS</code> </p> <code>max_trace_length</code> <p>Maximum trace length to consider</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> RETURNS DESCRIPTION <code>EquivalenceResult</code> <p>EquivalenceResult with equivalence status</p>"},{"location":"api/algebra/equivalence/#agenticraft_foundation.algebra.equivalence.strong_bisimilar","title":"<code>strong_bisimilar(p, q)</code>","text":"<p>Check strong bisimulation: P \u223c Q.</p> <p>Strong bisimulation is the finest process equivalence. P \u223c Q iff there exists a relation R such that: - (P, Q) \u2208 R - If (P', Q') \u2208 R and P' \u2500a\u2192 P'', then Q' \u2500a\u2192 Q'' and (P'', Q'') \u2208 R - Symmetrically for Q'</p> PARAMETER DESCRIPTION <code>p</code> <p>First process or LTS</p> <p> TYPE: <code>Process | LTS</code> </p> <code>q</code> <p>Second process or LTS</p> <p> TYPE: <code>Process | LTS</code> </p> RETURNS DESCRIPTION <code>EquivalenceResult</code> <p>EquivalenceResult with bisimulation relation if equivalent</p>"},{"location":"api/algebra/equivalence/#agenticraft_foundation.algebra.equivalence.weak_bisimilar","title":"<code>weak_bisimilar(p, q)</code>","text":"<p>Check weak bisimulation: P \u2248 Q.</p> <p>Weak bisimulation ignores \u03c4 (internal) actions. P \u2248 Q iff there exists a relation R such that: - (P, Q) \u2208 R - If (P', Q') \u2208 R and P' \u2500a\u2192 P'', then Q' \u2550a\u21d2 Q'' and (P'', Q'') \u2208 R   where \u2550a\u21d2 means \u03c4\u00b7a\u00b7\u03c4 (zero or more \u03c4, then a, then zero or more \u03c4) - Symmetrically for Q'</p> PARAMETER DESCRIPTION <code>p</code> <p>First process or LTS</p> <p> TYPE: <code>Process | LTS</code> </p> <code>q</code> <p>Second process or LTS</p> <p> TYPE: <code>Process | LTS</code> </p> RETURNS DESCRIPTION <code>EquivalenceResult</code> <p>EquivalenceResult with bisimulation relation if equivalent</p>"},{"location":"api/algebra/equivalence/#agenticraft_foundation.algebra.equivalence.failures","title":"<code>failures(lts, max_trace_length=50)</code>","text":"<p>Generate failures of an LTS.</p> <p>A failure is a pair (s, X) where: - s is a trace the process can perform - X is a set of events the process can refuse after s</p> PARAMETER DESCRIPTION <code>lts</code> <p>The LTS to analyze</p> <p> TYPE: <code>LTS</code> </p> <code>max_trace_length</code> <p>Maximum trace length</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> YIELDS DESCRIPTION <code>Failure</code> <p>Failure objects</p>"},{"location":"api/algebra/equivalence/#agenticraft_foundation.algebra.equivalence.failures_equivalent","title":"<code>failures_equivalent(p, q, max_trace_length=50)</code>","text":"<p>Check failures equivalence: P =_F Q.</p> <p>Two processes are failures equivalent if they have exactly the same failures.</p> PARAMETER DESCRIPTION <code>p</code> <p>First process or LTS</p> <p> TYPE: <code>Process | LTS</code> </p> <code>q</code> <p>Second process or LTS</p> <p> TYPE: <code>Process | LTS</code> </p> <code>max_trace_length</code> <p>Maximum trace length</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>EquivalenceResult</code> <p>EquivalenceResult with equivalence status</p>"},{"location":"api/algebra/equivalence/#agenticraft_foundation.algebra.equivalence.are_equivalent","title":"<code>are_equivalent(p, q, equivalence='trace')</code>","text":"<p>Check if two processes are equivalent.</p> PARAMETER DESCRIPTION <code>p</code> <p>First process</p> <p> TYPE: <code>Process</code> </p> <code>q</code> <p>Second process</p> <p> TYPE: <code>Process</code> </p> <code>equivalence</code> <p>Type of equivalence: - \"trace\": Trace equivalence - \"strong\": Strong bisimulation - \"weak\": Weak bisimulation - \"failures\": Failures equivalence</p> <p> TYPE: <code>str</code> DEFAULT: <code>'trace'</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if processes are equivalent</p>"},{"location":"api/algebra/patterns/","title":"agenticraft_foundation.algebra.patterns","text":"<p>6 coordination patterns built from CSP primitives: request-response, pipeline, scatter-gather, barrier, mutex, producer-consumer.</p> <p>Coordination patterns for multi-agent systems in CSP.</p> <p>This module provides: - Request-Response: Client-server interaction - Pipeline: Sequential processing stages - Scatter-Gather: Parallel task distribution and collection - Barrier: Synchronization point for multiple agents - Mutex: Mutual exclusion pattern - Producer-Consumer: Buffered communication</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.BarrierPattern","title":"<code>BarrierPattern</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CoordinationPattern</code></p> <p>Barrier pattern for multi-party synchronization.</p> <p>All participants must reach the barrier before any can proceed.</p> CSP Model <p>PARTICIPANT_i = arrive \u2192 depart \u2192 SKIP BARRIER = arrive_1 \u2192 arrive_2 \u2192 ... \u2192 depart_1 \u2192 depart_2 \u2192 ... \u2192 SKIP</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.MutexPattern","title":"<code>MutexPattern</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CoordinationPattern</code></p> <p>Mutual exclusion pattern.</p> <p>Only one process can be in the critical section at a time.</p> CSP Model <p>MUTEX = acquire \u2192 release \u2192 MUTEX PROCESS_i = acquire \u2192 critical_i \u2192 release \u2192 SKIP</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.MutexPattern.global_process","title":"<code>global_process()</code>","text":"<p>The mutex resource process.</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.MutexPattern.system_process","title":"<code>system_process()</code>","text":"<p>The full system with mutex and all processes.</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.PipelinePattern","title":"<code>PipelinePattern</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CoordinationPattern</code></p> <p>Pipeline pattern for sequential multi-stage processing.</p> Interaction <p>Stage1 \u2500data\u2192 Stage2 \u2500data\u2192 Stage3 \u2192 ...</p> CSP Model <p>STAGE_1 = data_1_2 \u2192 SKIP STAGE_2 = data_1_2 \u2192 data_2_3 \u2192 SKIP STAGE_N = data_{n-1}_n \u2192 SKIP SYSTEM = STAGE_1 ||| STAGE_2 ||| ... ||| STAGE_N (synchronized on data events)</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.ProducerConsumerPattern","title":"<code>ProducerConsumerPattern</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CoordinationPattern</code></p> <p>Producer-Consumer pattern with bounded buffer.</p> CSP Model <p>PRODUCER = produce \u2192 put \u2192 PRODUCER CONSUMER = get \u2192 consume \u2192 CONSUMER BUFFER = put \u2192 get \u2192 BUFFER (simplified unbounded)</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.ProducerConsumerPattern.global_process","title":"<code>global_process()</code>","text":"<p>Simplified: produce \u2192 put \u2192 get \u2192 consume \u2192 recurse.</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.RequestResponsePattern","title":"<code>RequestResponsePattern</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CoordinationPattern</code></p> <p>Request-Response pattern for client-server interaction.</p> Interaction <p>Client \u2500request\u2192 Server Server \u2500response\u2192 Client</p> CSP Model <p>CLIENT = request \u2192 response \u2192 SKIP SERVER = request \u2192 response \u2192 SKIP SYSTEM = CLIENT |[{request, response}]| SERVER</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.ScatterGatherPattern","title":"<code>ScatterGatherPattern</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CoordinationPattern</code></p> <p>Scatter-Gather pattern for parallel task distribution.</p> Interaction <p>Coordinator \u2500task\u2192 Worker1, Worker2, ... Worker1, Worker2, ... \u2500result\u2192 Coordinator</p> CSP Model <p>COORD = task_w1 \u2192 task_w2 \u2192 result_w1 \u2192 result_w2 \u2192 SKIP WORKER_i = task_wi \u2192 result_wi \u2192 SKIP</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.barrier","title":"<code>barrier(participants, arrive_event='arrive', depart_event='depart', repeatable=False)</code>","text":"<p>Create a barrier synchronization pattern.</p> PARAMETER DESCRIPTION <code>participants</code> <p>List of participant names</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>arrive_event</code> <p>Prefix for arrival events</p> <p> TYPE: <code>str</code> DEFAULT: <code>'arrive'</code> </p> <code>depart_event</code> <p>Prefix for departure events</p> <p> TYPE: <code>str</code> DEFAULT: <code>'depart'</code> </p> <code>repeatable</code> <p>Whether the pattern repeats</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>The global process representing the pattern</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.compose_agents","title":"<code>compose_agents(agents, sync_events=None)</code>","text":"<p>Compose multiple agent processes in parallel.</p> PARAMETER DESCRIPTION <code>agents</code> <p>Dict mapping agent names to their processes</p> <p> TYPE: <code>dict[str, Process]</code> </p> <code>sync_events</code> <p>Events to synchronize on (all if None)</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>Parallel composition of all agents</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.mutex","title":"<code>mutex(processes, acquire_event='acquire', release_event='release', critical_event_prefix='critical')</code>","text":"<p>Create a mutual exclusion pattern.</p> PARAMETER DESCRIPTION <code>processes</code> <p>List of process names</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>acquire_event</code> <p>Event to acquire mutex</p> <p> TYPE: <code>str</code> DEFAULT: <code>'acquire'</code> </p> <code>release_event</code> <p>Event to release mutex</p> <p> TYPE: <code>str</code> DEFAULT: <code>'release'</code> </p> <code>critical_event_prefix</code> <p>Prefix for critical section events</p> <p> TYPE: <code>str</code> DEFAULT: <code>'critical'</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>The mutex resource process</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.pipeline","title":"<code>pipeline(stages, data_event_prefix='data', repeatable=False)</code>","text":"<p>Create a pipeline pattern process.</p> PARAMETER DESCRIPTION <code>stages</code> <p>Ordered list of stage names</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>data_event_prefix</code> <p>Prefix for data events</p> <p> TYPE: <code>str</code> DEFAULT: <code>'data'</code> </p> <code>repeatable</code> <p>Whether the pattern repeats</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>The global process representing the pattern</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.producer_consumer","title":"<code>producer_consumer(producer='producer', consumer='consumer', produce_event='produce', consume_event='consume', put_event='put', get_event='get')</code>","text":"<p>Create a producer-consumer pattern.</p> PARAMETER DESCRIPTION <code>producer</code> <p>Producer name</p> <p> TYPE: <code>str</code> DEFAULT: <code>'producer'</code> </p> <code>consumer</code> <p>Consumer name</p> <p> TYPE: <code>str</code> DEFAULT: <code>'consumer'</code> </p> <code>produce_event</code> <p>Event when producer creates item</p> <p> TYPE: <code>str</code> DEFAULT: <code>'produce'</code> </p> <code>consume_event</code> <p>Event when consumer uses item</p> <p> TYPE: <code>str</code> DEFAULT: <code>'consume'</code> </p> <code>put_event</code> <p>Event to put item in buffer</p> <p> TYPE: <code>str</code> DEFAULT: <code>'put'</code> </p> <code>get_event</code> <p>Event to get item from buffer</p> <p> TYPE: <code>str</code> DEFAULT: <code>'get'</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>The global process representing the pattern</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.request_response","title":"<code>request_response(client='client', server='server', request_event='request', response_event='response', repeatable=False)</code>","text":"<p>Create a request-response pattern process.</p> PARAMETER DESCRIPTION <code>client</code> <p>Client participant name</p> <p> TYPE: <code>str</code> DEFAULT: <code>'client'</code> </p> <code>server</code> <p>Server participant name</p> <p> TYPE: <code>str</code> DEFAULT: <code>'server'</code> </p> <code>request_event</code> <p>Request event name</p> <p> TYPE: <code>str</code> DEFAULT: <code>'request'</code> </p> <code>response_event</code> <p>Response event name</p> <p> TYPE: <code>str</code> DEFAULT: <code>'response'</code> </p> <code>repeatable</code> <p>Whether the pattern repeats</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>The global process representing the pattern</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.scatter_gather","title":"<code>scatter_gather(coordinator='coordinator', workers=(), task_event_prefix='task', result_event_prefix='result', repeatable=False)</code>","text":"<p>Create a scatter-gather pattern process.</p> PARAMETER DESCRIPTION <code>coordinator</code> <p>Coordinator name</p> <p> TYPE: <code>str</code> DEFAULT: <code>'coordinator'</code> </p> <code>workers</code> <p>List of worker names</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>task_event_prefix</code> <p>Prefix for task events</p> <p> TYPE: <code>str</code> DEFAULT: <code>'task'</code> </p> <code>result_event_prefix</code> <p>Prefix for result events</p> <p> TYPE: <code>str</code> DEFAULT: <code>'result'</code> </p> <code>repeatable</code> <p>Whether the pattern repeats</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>The global process representing the pattern</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.verify_pattern","title":"<code>verify_pattern(pattern, spec=None)</code>","text":"<p>Verify properties of a coordination pattern.</p> PARAMETER DESCRIPTION <code>pattern</code> <p>The pattern to verify</p> <p> TYPE: <code>CoordinationPattern</code> </p> <code>spec</code> <p>Optional specification to check refinement against</p> <p> TYPE: <code>Process | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>PatternVerification</code> <p>PatternVerification with results</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination","title":"<code>agenticraft_foundation.algebra.patterns.coordination</code>","text":"<p>Coordination patterns for multi-agent systems.</p> <p>These patterns express common coordination scenarios in CSP, enabling formal verification of multi-agent interactions.</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.CoordinationPattern","title":"<code>CoordinationPattern</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for coordination patterns.</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.CoordinationPattern.participants","title":"<code>participants()</code>  <code>abstractmethod</code>","text":"<p>Return set of participant names.</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.CoordinationPattern.events","title":"<code>events()</code>  <code>abstractmethod</code>","text":"<p>Return set of events in this pattern.</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.CoordinationPattern.global_process","title":"<code>global_process()</code>  <code>abstractmethod</code>","text":"<p>Return the global (system) process representing the pattern.</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.CoordinationPattern.local_process","title":"<code>local_process(participant)</code>  <code>abstractmethod</code>","text":"<p>Return the local process for a specific participant.</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.CoordinationPattern.compose","title":"<code>compose(sync_events=None)</code>","text":"<p>Compose all local processes into the global system.</p> PARAMETER DESCRIPTION <code>sync_events</code> <p>Events to synchronize on. Defaults to pattern events.</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>Composed parallel process</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.CoordinationPattern.is_deadlock_free","title":"<code>is_deadlock_free()</code>","text":"<p>Check if the pattern is deadlock-free.</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.RequestResponsePattern","title":"<code>RequestResponsePattern</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CoordinationPattern</code></p> <p>Request-Response pattern for client-server interaction.</p> Interaction <p>Client \u2500request\u2192 Server Server \u2500response\u2192 Client</p> CSP Model <p>CLIENT = request \u2192 response \u2192 SKIP SERVER = request \u2192 response \u2192 SKIP SYSTEM = CLIENT |[{request, response}]| SERVER</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.PipelinePattern","title":"<code>PipelinePattern</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CoordinationPattern</code></p> <p>Pipeline pattern for sequential multi-stage processing.</p> Interaction <p>Stage1 \u2500data\u2192 Stage2 \u2500data\u2192 Stage3 \u2192 ...</p> CSP Model <p>STAGE_1 = data_1_2 \u2192 SKIP STAGE_2 = data_1_2 \u2192 data_2_3 \u2192 SKIP STAGE_N = data_{n-1}_n \u2192 SKIP SYSTEM = STAGE_1 ||| STAGE_2 ||| ... ||| STAGE_N (synchronized on data events)</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.ScatterGatherPattern","title":"<code>ScatterGatherPattern</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CoordinationPattern</code></p> <p>Scatter-Gather pattern for parallel task distribution.</p> Interaction <p>Coordinator \u2500task\u2192 Worker1, Worker2, ... Worker1, Worker2, ... \u2500result\u2192 Coordinator</p> CSP Model <p>COORD = task_w1 \u2192 task_w2 \u2192 result_w1 \u2192 result_w2 \u2192 SKIP WORKER_i = task_wi \u2192 result_wi \u2192 SKIP</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.BarrierPattern","title":"<code>BarrierPattern</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CoordinationPattern</code></p> <p>Barrier pattern for multi-party synchronization.</p> <p>All participants must reach the barrier before any can proceed.</p> CSP Model <p>PARTICIPANT_i = arrive \u2192 depart \u2192 SKIP BARRIER = arrive_1 \u2192 arrive_2 \u2192 ... \u2192 depart_1 \u2192 depart_2 \u2192 ... \u2192 SKIP</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.MutexPattern","title":"<code>MutexPattern</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CoordinationPattern</code></p> <p>Mutual exclusion pattern.</p> <p>Only one process can be in the critical section at a time.</p> CSP Model <p>MUTEX = acquire \u2192 release \u2192 MUTEX PROCESS_i = acquire \u2192 critical_i \u2192 release \u2192 SKIP</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.MutexPattern.global_process","title":"<code>global_process()</code>","text":"<p>The mutex resource process.</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.MutexPattern.system_process","title":"<code>system_process()</code>","text":"<p>The full system with mutex and all processes.</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.ProducerConsumerPattern","title":"<code>ProducerConsumerPattern</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CoordinationPattern</code></p> <p>Producer-Consumer pattern with bounded buffer.</p> CSP Model <p>PRODUCER = produce \u2192 put \u2192 PRODUCER CONSUMER = get \u2192 consume \u2192 CONSUMER BUFFER = put \u2192 get \u2192 BUFFER (simplified unbounded)</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.ProducerConsumerPattern.global_process","title":"<code>global_process()</code>","text":"<p>Simplified: produce \u2192 put \u2192 get \u2192 consume \u2192 recurse.</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.PatternVerification","title":"<code>PatternVerification</code>  <code>dataclass</code>","text":"<p>Result of pattern verification.</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.request_response","title":"<code>request_response(client='client', server='server', request_event='request', response_event='response', repeatable=False)</code>","text":"<p>Create a request-response pattern process.</p> PARAMETER DESCRIPTION <code>client</code> <p>Client participant name</p> <p> TYPE: <code>str</code> DEFAULT: <code>'client'</code> </p> <code>server</code> <p>Server participant name</p> <p> TYPE: <code>str</code> DEFAULT: <code>'server'</code> </p> <code>request_event</code> <p>Request event name</p> <p> TYPE: <code>str</code> DEFAULT: <code>'request'</code> </p> <code>response_event</code> <p>Response event name</p> <p> TYPE: <code>str</code> DEFAULT: <code>'response'</code> </p> <code>repeatable</code> <p>Whether the pattern repeats</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>The global process representing the pattern</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.pipeline","title":"<code>pipeline(stages, data_event_prefix='data', repeatable=False)</code>","text":"<p>Create a pipeline pattern process.</p> PARAMETER DESCRIPTION <code>stages</code> <p>Ordered list of stage names</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>data_event_prefix</code> <p>Prefix for data events</p> <p> TYPE: <code>str</code> DEFAULT: <code>'data'</code> </p> <code>repeatable</code> <p>Whether the pattern repeats</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>The global process representing the pattern</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.scatter_gather","title":"<code>scatter_gather(coordinator='coordinator', workers=(), task_event_prefix='task', result_event_prefix='result', repeatable=False)</code>","text":"<p>Create a scatter-gather pattern process.</p> PARAMETER DESCRIPTION <code>coordinator</code> <p>Coordinator name</p> <p> TYPE: <code>str</code> DEFAULT: <code>'coordinator'</code> </p> <code>workers</code> <p>List of worker names</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> <code>task_event_prefix</code> <p>Prefix for task events</p> <p> TYPE: <code>str</code> DEFAULT: <code>'task'</code> </p> <code>result_event_prefix</code> <p>Prefix for result events</p> <p> TYPE: <code>str</code> DEFAULT: <code>'result'</code> </p> <code>repeatable</code> <p>Whether the pattern repeats</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>The global process representing the pattern</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.barrier","title":"<code>barrier(participants, arrive_event='arrive', depart_event='depart', repeatable=False)</code>","text":"<p>Create a barrier synchronization pattern.</p> PARAMETER DESCRIPTION <code>participants</code> <p>List of participant names</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>arrive_event</code> <p>Prefix for arrival events</p> <p> TYPE: <code>str</code> DEFAULT: <code>'arrive'</code> </p> <code>depart_event</code> <p>Prefix for departure events</p> <p> TYPE: <code>str</code> DEFAULT: <code>'depart'</code> </p> <code>repeatable</code> <p>Whether the pattern repeats</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>The global process representing the pattern</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.mutex","title":"<code>mutex(processes, acquire_event='acquire', release_event='release', critical_event_prefix='critical')</code>","text":"<p>Create a mutual exclusion pattern.</p> PARAMETER DESCRIPTION <code>processes</code> <p>List of process names</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>acquire_event</code> <p>Event to acquire mutex</p> <p> TYPE: <code>str</code> DEFAULT: <code>'acquire'</code> </p> <code>release_event</code> <p>Event to release mutex</p> <p> TYPE: <code>str</code> DEFAULT: <code>'release'</code> </p> <code>critical_event_prefix</code> <p>Prefix for critical section events</p> <p> TYPE: <code>str</code> DEFAULT: <code>'critical'</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>The mutex resource process</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.producer_consumer","title":"<code>producer_consumer(producer='producer', consumer='consumer', produce_event='produce', consume_event='consume', put_event='put', get_event='get')</code>","text":"<p>Create a producer-consumer pattern.</p> PARAMETER DESCRIPTION <code>producer</code> <p>Producer name</p> <p> TYPE: <code>str</code> DEFAULT: <code>'producer'</code> </p> <code>consumer</code> <p>Consumer name</p> <p> TYPE: <code>str</code> DEFAULT: <code>'consumer'</code> </p> <code>produce_event</code> <p>Event when producer creates item</p> <p> TYPE: <code>str</code> DEFAULT: <code>'produce'</code> </p> <code>consume_event</code> <p>Event when consumer uses item</p> <p> TYPE: <code>str</code> DEFAULT: <code>'consume'</code> </p> <code>put_event</code> <p>Event to put item in buffer</p> <p> TYPE: <code>str</code> DEFAULT: <code>'put'</code> </p> <code>get_event</code> <p>Event to get item from buffer</p> <p> TYPE: <code>str</code> DEFAULT: <code>'get'</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>The global process representing the pattern</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.compose_agents","title":"<code>compose_agents(agents, sync_events=None)</code>","text":"<p>Compose multiple agent processes in parallel.</p> PARAMETER DESCRIPTION <code>agents</code> <p>Dict mapping agent names to their processes</p> <p> TYPE: <code>dict[str, Process]</code> </p> <code>sync_events</code> <p>Events to synchronize on (all if None)</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>Parallel composition of all agents</p>"},{"location":"api/algebra/patterns/#agenticraft_foundation.algebra.patterns.coordination.verify_pattern","title":"<code>verify_pattern(pattern, spec=None)</code>","text":"<p>Verify properties of a coordination pattern.</p> PARAMETER DESCRIPTION <code>pattern</code> <p>The pattern to verify</p> <p> TYPE: <code>CoordinationPattern</code> </p> <code>spec</code> <p>Optional specification to check refinement against</p> <p> TYPE: <code>Process | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>PatternVerification</code> <p>PatternVerification with results</p>"},{"location":"api/algebra/refinement/","title":"agenticraft_foundation.algebra.refinement","text":"<p>Refinement checking \u2014 trace refinement, failures refinement, and failures-divergence refinement.</p> <p>Refinement checking for CSP processes.</p> <p>This module provides: - Trace refinement: SPEC \u2291_T IMPL iff traces(IMPL) \u2286 traces(SPEC) - Failures refinement: SPEC \u2291_F IMPL iff failures(IMPL) \u2286 failures(SPEC) - Failures-divergences refinement (FD): Standard CSP refinement</p> <p>Refinement is the key relation for verification: - SPEC describes allowed behaviors - IMPL must not have behaviors outside SPEC - If IMPL \u2291 SPEC, IMPL is a valid implementation</p> <p>Note on direction: - In CSP: SPEC \u2291 IMPL means \"SPEC is refined by IMPL\" - IMPL can do less than SPEC (subset of traces) - We check: traces(IMPL) \u2286 traces(SPEC)</p>"},{"location":"api/algebra/refinement/#agenticraft_foundation.algebra.refinement.RefinementResult","title":"<code>RefinementResult</code>  <code>dataclass</code>","text":"<p>Result of a refinement check.</p>"},{"location":"api/algebra/refinement/#agenticraft_foundation.algebra.refinement.RefinementResult.is_valid","title":"<code>is_valid</code>  <code>property</code>","text":"<p>True if implementation refines specification.</p>"},{"location":"api/algebra/refinement/#agenticraft_foundation.algebra.refinement.RefinementReport","title":"<code>RefinementReport</code>  <code>dataclass</code>","text":"<p>Detailed refinement analysis report.</p>"},{"location":"api/algebra/refinement/#agenticraft_foundation.algebra.refinement.RefinementReport.overall_result","title":"<code>overall_result</code>  <code>property</code>","text":"<p>True if all refinement checks pass.</p>"},{"location":"api/algebra/refinement/#agenticraft_foundation.algebra.refinement.DivergenceResult","title":"<code>DivergenceResult</code>  <code>dataclass</code>","text":"<p>Result of divergence check.</p>"},{"location":"api/algebra/refinement/#agenticraft_foundation.algebra.refinement.trace_refines","title":"<code>trace_refines(spec, impl, max_trace_length=100)</code>","text":"<p>Check trace refinement: traces(IMPL) \u2286 traces(SPEC).</p> <p>An implementation trace-refines a specification if every trace of the implementation is also a trace of the specification.</p> PARAMETER DESCRIPTION <code>spec</code> <p>The specification process</p> <p> TYPE: <code>Process | LTS</code> </p> <code>impl</code> <p>The implementation process</p> <p> TYPE: <code>Process | LTS</code> </p> <code>max_trace_length</code> <p>Maximum trace length to check</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> RETURNS DESCRIPTION <code>RefinementResult</code> <p>RefinementResult with counterexample if refinement fails</p>"},{"location":"api/algebra/refinement/#agenticraft_foundation.algebra.refinement.failures_refines","title":"<code>failures_refines(spec, impl, max_trace_length=50)</code>","text":"<p>Check failures refinement: failures(IMPL) \u2286 failures(SPEC).</p> <p>An implementation failures-refines a specification if every failure of the implementation is also a failure of the specification.</p> <p>This is stronger than trace refinement: not only must traces match, but refusal sets must also be subsets.</p> PARAMETER DESCRIPTION <code>spec</code> <p>The specification process</p> <p> TYPE: <code>Process | LTS</code> </p> <code>impl</code> <p>The implementation process</p> <p> TYPE: <code>Process | LTS</code> </p> <code>max_trace_length</code> <p>Maximum trace length</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>RefinementResult</code> <p>RefinementResult with counterexample if refinement fails</p>"},{"location":"api/algebra/refinement/#agenticraft_foundation.algebra.refinement.check_divergence_free","title":"<code>check_divergence_free(process, max_depth=1000)</code>","text":"<p>Check if process is divergence-free.</p> <p>A process diverges if it can perform an infinite sequence of \u03c4 actions. This is detected by finding \u03c4-cycles in the LTS.</p> PARAMETER DESCRIPTION <code>process</code> <p>The process to check</p> <p> TYPE: <code>Process | LTS</code> </p> <code>max_depth</code> <p>Maximum exploration depth</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> RETURNS DESCRIPTION <code>DivergenceResult</code> <p>DivergenceResult indicating divergence-freedom</p>"},{"location":"api/algebra/refinement/#agenticraft_foundation.algebra.refinement.fd_refines","title":"<code>fd_refines(spec, impl, max_trace_length=50)</code>","text":"<p>Check failures-divergences refinement.</p> <p>This is the standard CSP refinement: IMPL \u2291_FD SPEC iff: 1. failures(IMPL) \u2286 failures(SPEC) 2. divergences(IMPL) \u2286 divergences(SPEC)</p> <p>If SPEC is divergence-free, then IMPL must also be divergence-free.</p> PARAMETER DESCRIPTION <code>spec</code> <p>The specification process</p> <p> TYPE: <code>Process | LTS</code> </p> <code>impl</code> <p>The implementation process</p> <p> TYPE: <code>Process | LTS</code> </p> <code>max_trace_length</code> <p>Maximum trace length</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>RefinementResult</code> <p>RefinementResult</p>"},{"location":"api/algebra/refinement/#agenticraft_foundation.algebra.refinement.analyze_refinement","title":"<code>analyze_refinement(spec, impl, spec_name='SPEC', impl_name='IMPL', max_trace_length=50, check_failures=True)</code>","text":"<p>Perform comprehensive refinement analysis.</p> PARAMETER DESCRIPTION <code>spec</code> <p>The specification process</p> <p> TYPE: <code>Process</code> </p> <code>impl</code> <p>The implementation process</p> <p> TYPE: <code>Process</code> </p> <code>spec_name</code> <p>Name for the spec in reports</p> <p> TYPE: <code>str</code> DEFAULT: <code>'SPEC'</code> </p> <code>impl_name</code> <p>Name for the impl in reports</p> <p> TYPE: <code>str</code> DEFAULT: <code>'IMPL'</code> </p> <code>max_trace_length</code> <p>Maximum trace length</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> <code>check_failures</code> <p>Whether to check failures refinement</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>RefinementReport</code> <p>RefinementReport with detailed analysis</p>"},{"location":"api/algebra/refinement/#agenticraft_foundation.algebra.refinement.refines","title":"<code>refines(spec, impl, mode='trace')</code>","text":"<p>Check if implementation refines specification.</p> PARAMETER DESCRIPTION <code>spec</code> <p>The specification process</p> <p> TYPE: <code>Process</code> </p> <code>impl</code> <p>The implementation process</p> <p> TYPE: <code>Process</code> </p> <code>mode</code> <p>Refinement type: - \"trace\": Trace refinement - \"failures\": Failures refinement - \"fd\": Failures-divergences refinement</p> <p> TYPE: <code>str</code> DEFAULT: <code>'trace'</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if impl refines spec</p>"},{"location":"api/algebra/semantics/","title":"agenticraft_foundation.algebra.semantics","text":"<p>Operational semantics \u2014 LTS construction, trace extraction, deadlock detection, and liveness analysis.</p> <p>Labeled Transition System (LTS) for CSP operational semantics.</p> <p>This module provides: - LTS representation of process behavior - State space exploration - Trace generation - Deadlock detection</p> <p>An LTS is a tuple (S, Act, \u2192, s\u2080) where: - S: set of states - Act: set of actions/events - \u2192: transition relation S \u00d7 Act \u00d7 S - s\u2080: initial state</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.Transition","title":"<code>Transition</code>  <code>dataclass</code>","text":"<p>A transition in an LTS: source \u2500event\u2192 target.</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.LTSState","title":"<code>LTSState</code>  <code>dataclass</code>","text":"<p>A state in the LTS, wrapping a process.</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.LTS","title":"<code>LTS</code>  <code>dataclass</code>","text":"<p>Labeled Transition System.</p> <p>Represents the operational semantics of a CSP process as a graph.</p> ATTRIBUTE DESCRIPTION <code>states</code> <p>All states in the LTS</p> <p> TYPE: <code>dict[int, LTSState]</code> </p> <code>transitions</code> <p>All transitions</p> <p> TYPE: <code>list[Transition]</code> </p> <code>initial_state</code> <p>The starting state ID</p> <p> TYPE: <code>int</code> </p> <code>alphabet</code> <p>All events in the LTS</p> <p> TYPE: <code>frozenset[Event]</code> </p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.LTS.num_states","title":"<code>num_states</code>  <code>property</code>","text":"<p>Number of states in the LTS.</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.LTS.num_transitions","title":"<code>num_transitions</code>  <code>property</code>","text":"<p>Number of transitions in the LTS.</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.LTS.add_state","title":"<code>add_state(state)</code>","text":"<p>Add a state to the LTS.</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.LTS.add_transition","title":"<code>add_transition(transition)</code>","text":"<p>Add a transition to the LTS.</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.LTS.get_transitions_from","title":"<code>get_transitions_from(state_id)</code>","text":"<p>Get all transitions from a state.</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.LTS.get_transitions_to","title":"<code>get_transitions_to(state_id)</code>","text":"<p>Get all transitions to a state.</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.LTS.successors","title":"<code>successors(state_id)</code>","text":"<p>Yield (event, target_state) pairs for transitions from state.</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.LTS.predecessors","title":"<code>predecessors(state_id)</code>","text":"<p>Yield (event, source_state) pairs for transitions to state.</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.LTS.deadlock_states","title":"<code>deadlock_states()</code>","text":"<p>Return IDs of deadlock states.</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.LTS.terminal_states","title":"<code>terminal_states()</code>","text":"<p>Return IDs of terminal (successfully terminated) states.</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.LTSBuilder","title":"<code>LTSBuilder</code>","text":"<p>Builds an LTS from a CSP process through state space exploration.</p> <p>Uses breadth-first exploration to discover all reachable states and transitions.</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.LTSBuilder.__init__","title":"<code>__init__(max_states=10000, max_depth=1000)</code>","text":"<p>Initialize the builder.</p> PARAMETER DESCRIPTION <code>max_states</code> <p>Maximum number of states to explore</p> <p> TYPE: <code>int</code> DEFAULT: <code>10000</code> </p> <code>max_depth</code> <p>Maximum depth of exploration</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.LTSBuilder.build","title":"<code>build(process)</code>","text":"<p>Build an LTS from a process.</p> PARAMETER DESCRIPTION <code>process</code> <p>The CSP process to analyze</p> <p> TYPE: <code>Process</code> </p> RETURNS DESCRIPTION <code>LTS</code> <p>The resulting LTS</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.DeadlockAnalysis","title":"<code>DeadlockAnalysis</code>  <code>dataclass</code>","text":"<p>Result of deadlock analysis.</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.LivenessAnalysis","title":"<code>LivenessAnalysis</code>  <code>dataclass</code>","text":"<p>Result of liveness analysis.</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.traces","title":"<code>traces(lts, max_length=100, include_tau=False)</code>","text":"<p>Generate all traces of the LTS up to a maximum length.</p> <p>A trace is a sequence of visible events (\u03c4 is typically hidden).</p> PARAMETER DESCRIPTION <code>lts</code> <p>The LTS to analyze</p> <p> TYPE: <code>LTS</code> </p> <code>max_length</code> <p>Maximum trace length</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>include_tau</code> <p>Whether to include \u03c4 (internal) events</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> YIELDS DESCRIPTION <code>Trace</code> <p>Traces as tuples of events</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.maximal_traces","title":"<code>maximal_traces(lts, max_length=100)</code>","text":"<p>Generate maximal traces (traces that cannot be extended).</p> <p>A maximal trace ends in either: - A deadlock state - A terminal state (successful termination) - Maximum length reached</p> PARAMETER DESCRIPTION <code>lts</code> <p>The LTS to analyze</p> <p> TYPE: <code>LTS</code> </p> <code>max_length</code> <p>Maximum trace length</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> YIELDS DESCRIPTION <code>Trace</code> <p>Maximal traces</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.accepts","title":"<code>accepts(lts, trace)</code>","text":"<p>Check if the LTS can perform the given trace.</p> PARAMETER DESCRIPTION <code>lts</code> <p>The LTS to check</p> <p> TYPE: <code>LTS</code> </p> <code>trace</code> <p>The trace to verify</p> <p> TYPE: <code>Trace</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the trace can be performed</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.detect_deadlock","title":"<code>detect_deadlock(lts, max_trace_length=50)</code>","text":"<p>Detect deadlock states and find traces leading to them.</p> PARAMETER DESCRIPTION <code>lts</code> <p>The LTS to analyze</p> <p> TYPE: <code>LTS</code> </p> <code>max_trace_length</code> <p>Maximum trace length to consider</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>DeadlockAnalysis</code> <p>DeadlockAnalysis with results</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.analyze_liveness","title":"<code>analyze_liveness(lts, events_of_interest=None)</code>","text":"<p>Analyze liveness properties of the LTS.</p> PARAMETER DESCRIPTION <code>lts</code> <p>The LTS to analyze</p> <p> TYPE: <code>LTS</code> </p> <code>events_of_interest</code> <p>Events to check for liveness</p> <p> TYPE: <code>set[Event] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>LivenessAnalysis</code> <p>LivenessAnalysis with results</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.build_lts","title":"<code>build_lts(process, max_states=10000)</code>","text":"<p>Build an LTS from a process.</p> PARAMETER DESCRIPTION <code>process</code> <p>The CSP process</p> <p> TYPE: <code>Process</code> </p> <code>max_states</code> <p>Maximum states to explore</p> <p> TYPE: <code>int</code> DEFAULT: <code>10000</code> </p> RETURNS DESCRIPTION <code>LTS</code> <p>The LTS representation</p>"},{"location":"api/algebra/semantics/#agenticraft_foundation.algebra.semantics.is_deadlock_free","title":"<code>is_deadlock_free(process)</code>","text":"<p>Check if a process is deadlock-free.</p> PARAMETER DESCRIPTION <code>process</code> <p>The CSP process to check</p> <p> TYPE: <code>Process</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the process cannot deadlock</p>"},{"location":"api/complexity/","title":"complexity","text":"<p>Complexity bounds for distributed algorithms, fault models (classical + LLM-specific), and decorator-based complexity annotations.</p> <p>Complexity annotations and bounds for distributed algorithms.</p> <p>This module provides tools for documenting and analyzing algorithm complexity, including decorators for annotation and utilities for complexity comparison.</p>"},{"location":"api/complexity/#submodules","title":"Submodules","text":"Module Description <code>annotations</code> Decorator-based complexity tracking with <code>ComplexityClass</code> <code>bounds</code> 30+ catalogued bounds across consensus, gossip, leader election, broadcast, and mesh communication"},{"location":"api/complexity/annotations/","title":"agenticraft_foundation.complexity.annotations","text":"<p>Complexity annotations \u2014 decorator-based tracking for algorithmic complexity classification.</p> <p>Complexity annotations for algorithm documentation and analysis.</p> <p>This module provides decorators and utilities for documenting and analyzing algorithm complexity, following formal verification principles from distributed systems research.</p> Example <p>@complexity(     time=\"O(D * log n)\",     space=\"O(n)\",     messages=\"Theta(n^2)\",     rounds=\"O(D)\",     assumptions=[\"partial synchrony\", \"f &lt; n/3 Byzantine\"],     theorem_ref=\"Castro &amp; Liskov 1999\" ) async def propose(self, value, context):     ...</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.ComplexityClass","title":"<code>ComplexityClass</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Standard complexity classes.</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.SynchronyModel","title":"<code>SynchronyModel</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Synchrony assumptions for distributed algorithms.</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.FaultModel","title":"<code>FaultModel</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Fault tolerance models.</p> <p>Classical distributed systems fault models: - CRASH_STOP: Process halts, never recovers (f &lt; n/2) - CRASH_RECOVERY: Process halts, may recover with stable storage (f &lt; n/2) - BYZANTINE: Arbitrary behavior including malicious (f &lt; n/3) - OMISSION: Process fails to send or receive messages (f &lt; n/2) - AUTHENTICATED_BYZANTINE: Byzantine with digital signatures (f &lt; n/3)</p> <p>LLM-specific fault models (map to classical analogs): - HALLUCINATION: Generates plausible but incorrect output   (analog: Byzantine \u2014 arbitrary incorrect responses) - PROMPT_INJECTION: Adversarial input manipulates behavior   (analog: Byzantine \u2014 attacker-controlled behavior) - NON_DETERMINISM: Same input yields different outputs across calls   (analog: Omission \u2014 unreliable message content) - CONTEXT_OVERFLOW: Input exceeds context window, truncating information   (analog: Crash-Recovery \u2014 partial state loss, recoverable with chunking)</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.ComplexityBound","title":"<code>ComplexityBound</code>  <code>dataclass</code>","text":"<p>Represents a complexity bound with optional proof reference.</p> ATTRIBUTE DESCRIPTION <code>expression</code> <p>The complexity expression (e.g., \"O(n log n)\")</p> <p> TYPE: <code>str</code> </p> <code>tight</code> <p>Whether this is a tight bound (Theta vs O)</p> <p> TYPE: <code>bool</code> </p> <code>amortized</code> <p>Whether this is amortized complexity</p> <p> TYPE: <code>bool</code> </p> <code>expected</code> <p>Whether this is expected (average) complexity</p> <p> TYPE: <code>bool</code> </p> <code>worst_case</code> <p>Whether this is worst-case complexity</p> <p> TYPE: <code>bool</code> </p> <code>proof_ref</code> <p>Reference to proof (paper, theorem number)</p> <p> TYPE: <code>str | None</code> </p> <code>notes</code> <p>Additional notes about the bound</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.ComplexityBound.__str__","title":"<code>__str__()</code>","text":"<p>Format the complexity bound as a string.</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.ComplexityBound.parse","title":"<code>parse(expr)</code>  <code>classmethod</code>","text":"<p>Parse a complexity expression string.</p> PARAMETER DESCRIPTION <code>expr</code> <p>Complexity expression like \"O(n log n)\" or \"Theta(n^2)\"</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ComplexityBound</code> <p>ComplexityBound instance</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.DistributedComplexity","title":"<code>DistributedComplexity</code>  <code>dataclass</code>","text":"<p>Complexity metrics specific to distributed algorithms.</p> ATTRIBUTE DESCRIPTION <code>time</code> <p>Time complexity (sequential operations)</p> <p> TYPE: <code>ComplexityBound | str | None</code> </p> <code>space</code> <p>Space complexity per node</p> <p> TYPE: <code>ComplexityBound | str | None</code> </p> <code>messages</code> <p>Total message complexity</p> <p> TYPE: <code>ComplexityBound | str | None</code> </p> <code>message_size</code> <p>Size of individual messages</p> <p> TYPE: <code>ComplexityBound | str | None</code> </p> <code>rounds</code> <p>Round/communication complexity</p> <p> TYPE: <code>ComplexityBound | str | None</code> </p> <code>bits</code> <p>Total bit complexity</p> <p> TYPE: <code>ComplexityBound | str | None</code> </p> <code>synchrony</code> <p>Required synchrony model</p> <p> TYPE: <code>SynchronyModel | str | None</code> </p> <code>fault_model</code> <p>Assumed fault model</p> <p> TYPE: <code>FaultModel | str | None</code> </p> <code>fault_tolerance</code> <p>Maximum faults tolerated (e.g., \"f &lt; n/3\")</p> <p> TYPE: <code>str | None</code> </p> <code>assumptions</code> <p>List of additional assumptions</p> <p> TYPE: <code>list[str]</code> </p> <code>theorem_ref</code> <p>Reference to theorem/paper</p> <p> TYPE: <code>str | None</code> </p> <code>lower_bound</code> <p>Known lower bound for the problem</p> <p> TYPE: <code>str | None</code> </p> <code>optimal</code> <p>Whether this achieves the lower bound</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.DistributedComplexity.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Convert string bounds to ComplexityBound objects.</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.DistributedComplexity.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary for serialization.</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.DistributedComplexity.format_docstring","title":"<code>format_docstring()</code>","text":"<p>Format complexity information for docstring inclusion.</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.ComplexityAnalysis","title":"<code>ComplexityAnalysis</code>  <code>dataclass</code>","text":"<p>Results of complexity analysis on a codebase.</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.ComplexityAnalysis.summary","title":"<code>summary()</code>","text":"<p>Generate summary report.</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.get_complexity","title":"<code>get_complexity(func)</code>","text":"<p>Get complexity annotation for a function.</p> PARAMETER DESCRIPTION <code>func</code> <p>The annotated function</p> <p> TYPE: <code>Callable[..., Any]</code> </p> RETURNS DESCRIPTION <code>DistributedComplexity | None</code> <p>DistributedComplexity if annotated, None otherwise</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.get_all_complexities","title":"<code>get_all_complexities()</code>","text":"<p>Get all registered complexity annotations.</p> RETURNS DESCRIPTION <code>dict[str, DistributedComplexity]</code> <p>Dictionary mapping function keys to complexity info</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.complexity","title":"<code>complexity(time=None, space=None, messages=None, message_size=None, rounds=None, bits=None, synchrony=None, fault_model=None, fault_tolerance=None, assumptions=None, theorem_ref=None, lower_bound=None, optimal=False)</code>","text":"<p>Decorator to annotate function with complexity information.</p> <p>This decorator documents algorithm complexity for formal analysis and documentation purposes. It stores the complexity information in a registry for later retrieval.</p> PARAMETER DESCRIPTION <code>time</code> <p>Time complexity (e.g., \"O(n log n)\")</p> <p> TYPE: <code>str | ComplexityBound | None</code> DEFAULT: <code>None</code> </p> <code>space</code> <p>Space complexity per node</p> <p> TYPE: <code>str | ComplexityBound | None</code> DEFAULT: <code>None</code> </p> <code>messages</code> <p>Total message complexity</p> <p> TYPE: <code>str | ComplexityBound | None</code> DEFAULT: <code>None</code> </p> <code>message_size</code> <p>Size of individual messages</p> <p> TYPE: <code>str | ComplexityBound | None</code> DEFAULT: <code>None</code> </p> <code>rounds</code> <p>Round/communication complexity</p> <p> TYPE: <code>str | ComplexityBound | None</code> DEFAULT: <code>None</code> </p> <code>bits</code> <p>Total bit complexity</p> <p> TYPE: <code>str | ComplexityBound | None</code> DEFAULT: <code>None</code> </p> <code>synchrony</code> <p>Required synchrony model</p> <p> TYPE: <code>SynchronyModel | str | None</code> DEFAULT: <code>None</code> </p> <code>fault_model</code> <p>Assumed fault model</p> <p> TYPE: <code>FaultModel | str | None</code> DEFAULT: <code>None</code> </p> <code>fault_tolerance</code> <p>Maximum faults tolerated</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>assumptions</code> <p>Additional assumptions</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>theorem_ref</code> <p>Reference to theorem/paper</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>lower_bound</code> <p>Known lower bound</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>optimal</code> <p>Whether this achieves lower bound</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P, R]], Callable[P, R]]</code> <p>Decorated function with complexity metadata</p> Example <p>@complexity(     time=\"O(n^2)\",     messages=\"O(n^2)\",     rounds=\"O(1)\",     fault_model=FaultModel.BYZANTINE,     fault_tolerance=\"f &lt; n/3\",     theorem_ref=\"Castro &amp; Liskov 1999, PBFT\" ) async def pbft_prepare(self, request):     ...</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.consensus_complexity","title":"<code>consensus_complexity(algorithm, fault_tolerance='f &lt; n/3', synchrony=SynchronyModel.PARTIAL_SYNCHRONY)</code>","text":"<p>Specialized complexity decorator for consensus algorithms.</p> <p>Provides preset complexity bounds for common consensus algorithms.</p> PARAMETER DESCRIPTION <code>algorithm</code> <p>Name of consensus algorithm (raft, pbft, paxos, etc.)</p> <p> TYPE: <code>str</code> </p> <code>fault_tolerance</code> <p>Fault tolerance bound</p> <p> TYPE: <code>str</code> DEFAULT: <code>'f &lt; n/3'</code> </p> <code>synchrony</code> <p>Synchrony model</p> <p> TYPE: <code>SynchronyModel</code> DEFAULT: <code>PARTIAL_SYNCHRONY</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P, R]], Callable[P, R]]</code> <p>Complexity decorator with preset values</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.gossip_complexity","title":"<code>gossip_complexity(fanout=3, rounds='O(log n)')</code>","text":"<p>Specialized complexity decorator for gossip protocols.</p> PARAMETER DESCRIPTION <code>fanout</code> <p>Number of nodes to contact per round</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>rounds</code> <p>Expected rounds to convergence</p> <p> TYPE: <code>str</code> DEFAULT: <code>'O(log n)'</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P, R]], Callable[P, R]]</code> <p>Complexity decorator with gossip-specific values</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.analyze_complexity","title":"<code>analyze_complexity(module)</code>","text":"<p>Analyze complexity annotations in a module.</p> PARAMETER DESCRIPTION <code>module</code> <p>Python module to analyze</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>ComplexityAnalysis</code> <p>ComplexityAnalysis with results</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.parse_big_o","title":"<code>parse_big_o(expression)</code>","text":"<p>Parse a Big-O expression into components.</p> PARAMETER DESCRIPTION <code>expression</code> <p>Big-O expression like \"O(n^2 log n)\"</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>tuple[str, dict[str, Any]]</code> <p>Tuple of (base_class, parameters)</p> Example <p>parse_big_o(\"O(n^2 log n)\") ('polynomial_log', {'exponent': 2, 'log_factor': True})</p>"},{"location":"api/complexity/annotations/#agenticraft_foundation.complexity.annotations.compare_complexity","title":"<code>compare_complexity(a, b)</code>","text":"<p>Compare two complexity expressions.</p> PARAMETER DESCRIPTION <code>a</code> <p>First complexity expression</p> <p> TYPE: <code>str</code> </p> <code>b</code> <p>Second complexity expression</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>int</code> <p>-1 if a &lt; b, 0 if equal, 1 if a &gt; b</p>"},{"location":"api/complexity/bounds/","title":"agenticraft_foundation.complexity.bounds","text":"<p>30+ catalogued complexity bounds across distributed algorithm categories, fault models (4 classical + 4 LLM-specific), and impossibility results.</p> <p>Complexity bounds and theoretical limits.</p> <p>This module provides utilities for reasoning about complexity bounds, including lower bounds, optimality proofs, and theoretical limits for distributed algorithms.</p>"},{"location":"api/complexity/bounds/#agenticraft_foundation.complexity.bounds.BoundType","title":"<code>BoundType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Type of complexity bound.</p>"},{"location":"api/complexity/bounds/#agenticraft_foundation.complexity.bounds.TheoreticalBound","title":"<code>TheoreticalBound</code>  <code>dataclass</code>","text":"<p>A theoretical bound from distributed systems literature.</p> ATTRIBUTE DESCRIPTION <code>problem</code> <p>The problem this bound applies to</p> <p> TYPE: <code>str</code> </p> <code>metric</code> <p>What is being bounded (time, messages, rounds)</p> <p> TYPE: <code>str</code> </p> <code>bound_type</code> <p>Type of bound (upper, lower, tight)</p> <p> TYPE: <code>BoundType</code> </p> <code>expression</code> <p>The bound expression</p> <p> TYPE: <code>str</code> </p> <code>conditions</code> <p>Conditions under which bound holds</p> <p> TYPE: <code>list[str]</code> </p> <code>source</code> <p>Citation for the bound</p> <p> TYPE: <code>str</code> </p> <code>proof_sketch</code> <p>Brief description of proof technique</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/complexity/bounds/#agenticraft_foundation.complexity.bounds.OptimalityCheck","title":"<code>OptimalityCheck</code>  <code>dataclass</code>","text":"<p>Result of checking if an algorithm is optimal.</p> ATTRIBUTE DESCRIPTION <code>is_optimal</code> <p>Whether algorithm matches lower bound</p> <p> TYPE: <code>bool</code> </p> <code>algorithm_bound</code> <p>The algorithm's complexity</p> <p> TYPE: <code>str</code> </p> <code>lower_bound</code> <p>The theoretical lower bound</p> <p> TYPE: <code>str</code> </p> <code>gap</code> <p>Gap between algorithm and lower bound</p> <p> TYPE: <code>str | None</code> </p> <code>conditions_match</code> <p>Whether conditions match</p> <p> TYPE: <code>bool</code> </p> <code>notes</code> <p>Additional notes</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/complexity/bounds/#agenticraft_foundation.complexity.bounds.ImpossibilityResult","title":"<code>ImpossibilityResult</code>  <code>dataclass</code>","text":"<p>Represents an impossibility result.</p> ATTRIBUTE DESCRIPTION <code>problem</code> <p>The impossible problem</p> <p> TYPE: <code>str</code> </p> <code>conditions</code> <p>Conditions making it impossible</p> <p> TYPE: <code>list[str]</code> </p> <code>source</code> <p>Citation</p> <p> TYPE: <code>str</code> </p> <code>workarounds</code> <p>Known workarounds that weaken assumptions</p> <p> TYPE: <code>list[str]</code> </p>"},{"location":"api/complexity/bounds/#agenticraft_foundation.complexity.bounds.ComplexityComparison","title":"<code>ComplexityComparison</code>  <code>dataclass</code>","text":"<p>Comparison of multiple algorithm complexities.</p> ATTRIBUTE DESCRIPTION <code>problem</code> <p>The problem being solved</p> <p> TYPE: <code>str</code> </p> <code>algorithms</code> <p>Dict mapping algorithm name to complexity</p> <p> TYPE: <code>dict[str, dict[str, str]]</code> </p> <code>optimal_for_metric</code> <p>Dict mapping metric to best algorithm</p> <p> TYPE: <code>dict[str, list[str]]</code> </p> <code>pareto_optimal</code> <p>Algorithms that are Pareto optimal</p> <p> TYPE: <code>list[str]</code> </p>"},{"location":"api/complexity/bounds/#agenticraft_foundation.complexity.bounds.check_optimality","title":"<code>check_optimality(algorithm_complexity, problem, metric='messages')</code>","text":"<p>Check if an algorithm achieves optimal complexity.</p> PARAMETER DESCRIPTION <code>algorithm_complexity</code> <p>The algorithm's complexity (e.g., \"O(n^2)\")</p> <p> TYPE: <code>str</code> </p> <code>problem</code> <p>The problem being solved</p> <p> TYPE: <code>str</code> </p> <code>metric</code> <p>The metric to check</p> <p> TYPE: <code>str</code> DEFAULT: <code>'messages'</code> </p> RETURNS DESCRIPTION <code>OptimalityCheck</code> <p>OptimalityCheck with results</p>"},{"location":"api/complexity/bounds/#agenticraft_foundation.complexity.bounds.get_impossibility","title":"<code>get_impossibility(problem)</code>","text":"<p>Get impossibility result for a problem.</p> PARAMETER DESCRIPTION <code>problem</code> <p>Problem description</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ImpossibilityResult | None</code> <p>ImpossibilityResult if found, None otherwise</p>"},{"location":"api/complexity/bounds/#agenticraft_foundation.complexity.bounds.validate_fault_tolerance","title":"<code>validate_fault_tolerance(n, f, fault_model)</code>","text":"<p>Validate if fault tolerance is achievable.</p> PARAMETER DESCRIPTION <code>n</code> <p>Number of nodes</p> <p> TYPE: <code>int</code> </p> <code>f</code> <p>Number of failures to tolerate</p> <p> TYPE: <code>int</code> </p> <code>fault_model</code> <p>Type of failures (crash, byzantine)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>tuple[bool, str]</code> <p>Tuple of (is_valid, explanation)</p>"},{"location":"api/complexity/bounds/#agenticraft_foundation.complexity.bounds.compare_algorithms","title":"<code>compare_algorithms(problem, algorithms)</code>","text":"<p>Compare complexity of multiple algorithms.</p> PARAMETER DESCRIPTION <code>problem</code> <p>The problem being solved</p> <p> TYPE: <code>str</code> </p> <code>algorithms</code> <p>Dict mapping algorithm name to complexity dict Example: {\"PBFT\": {\"messages\": \"O(n^2)\", \"rounds\": \"O(1)\"}}</p> <p> TYPE: <code>dict[str, dict[str, str]]</code> </p> RETURNS DESCRIPTION <code>ComplexityComparison</code> <p>ComplexityComparison with analysis</p>"},{"location":"api/integration/","title":"integration","text":"<p>Adapters that apply formal verification primitives to real protocol and workflow systems.</p> <p>Formal verification integration adapters.</p> <p>This module provides integration adapters that connect formal verification components (MPST, Process Algebra) to protocol and workflow systems.</p> <p>Components: - MPSTBridgeAdapter: Session type verification for cross-protocol messaging - CSPOrchestrationAdapter: Process algebra verification for workflows</p>"},{"location":"api/integration/#submodules","title":"Submodules","text":"Module Description <code>mpst_bridge</code> Session type verification for MCP and A2A protocol interactions <code>csp_orchestration</code> CSP-based workflow specification, verification, and composition"},{"location":"api/integration/csp-orchestration/","title":"agenticraft_foundation.integration.csp_orchestration","text":"<p>CSP orchestration adapter \u2014 converts workflow DAGs to CSP processes for deadlock freedom, liveness analysis, and refinement checking.</p> <p>CSP Process Algebra integration for workflow orchestration.</p> <p>This module provides workflow verification using CSP refinement checking.</p> <p>Key Features: - Workflow specification using CSP process algebra - Refinement checking of workflow implementations - Deadlock freedom verification - Liveness analysis for workflow progress</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.WorkflowNodeType","title":"<code>WorkflowNodeType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Types of nodes in a workflow.</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.WorkflowSpec","title":"<code>WorkflowSpec</code>  <code>dataclass</code>","text":"<p>Specification of a workflow using CSP.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Workflow name</p> <p> TYPE: <code>str</code> </p> <code>process</code> <p>The CSP process representing the workflow</p> <p> TYPE: <code>Process</code> </p> <code>events_of_interest</code> <p>Events to check for liveness</p> <p> TYPE: <code>frozenset[Event]</code> </p> <code>invariants</code> <p>Custom invariant predicates</p> <p> TYPE: <code>list[Callable[[Process], bool]]</code> </p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.WorkflowSpec.from_dag","title":"<code>from_dag(name, nodes, edges, sync_events=None)</code>  <code>classmethod</code>","text":"<p>Create a workflow spec from a DAG definition.</p> PARAMETER DESCRIPTION <code>name</code> <p>Workflow name</p> <p> TYPE: <code>str</code> </p> <code>nodes</code> <p>Node ID to type mapping</p> <p> TYPE: <code>dict[str, WorkflowNodeType]</code> </p> <code>edges</code> <p>List of (source, target) edges</p> <p> TYPE: <code>list[tuple[str, str]]</code> </p> <code>sync_events</code> <p>Events that require synchronization</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>WorkflowSpec</code> <p>WorkflowSpec instance</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.WorkflowSpec.sequential_tasks","title":"<code>sequential_tasks(name, task_ids)</code>  <code>classmethod</code>","text":"<p>Create a sequential workflow spec.</p> PARAMETER DESCRIPTION <code>name</code> <p>Workflow name</p> <p> TYPE: <code>str</code> </p> <code>task_ids</code> <p>Ordered list of task IDs</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>WorkflowSpec</code> <p>WorkflowSpec instance</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.WorkflowSpec.parallel_tasks","title":"<code>parallel_tasks(name, task_ids, sync_on_complete=True)</code>  <code>classmethod</code>","text":"<p>Create a parallel workflow spec.</p> PARAMETER DESCRIPTION <code>name</code> <p>Workflow name</p> <p> TYPE: <code>str</code> </p> <code>task_ids</code> <p>List of task IDs to run in parallel</p> <p> TYPE: <code>list[str]</code> </p> <code>sync_on_complete</code> <p>Whether tasks must all complete (sync on TICK)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>WorkflowSpec</code> <p>WorkflowSpec instance</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.WorkflowSpec.choice_tasks","title":"<code>choice_tasks(name, task_ids)</code>  <code>classmethod</code>","text":"<p>Create a choice (branching) workflow spec.</p> PARAMETER DESCRIPTION <code>name</code> <p>Workflow name</p> <p> TYPE: <code>str</code> </p> <code>task_ids</code> <p>List of alternative task IDs</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>WorkflowSpec</code> <p>WorkflowSpec instance</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.WorkflowVerificationResult","title":"<code>WorkflowVerificationResult</code>  <code>dataclass</code>","text":"<p>Result of workflow verification.</p> ATTRIBUTE DESCRIPTION <code>is_valid</code> <p>Whether the workflow passes all checks</p> <p> TYPE: <code>bool</code> </p> <code>is_deadlock_free</code> <p>Whether the workflow cannot deadlock</p> <p> TYPE: <code>bool</code> </p> <code>is_live</code> <p>Whether all events of interest are live</p> <p> TYPE: <code>bool</code> </p> <code>refines_spec</code> <p>Whether implementation refines specification</p> <p> TYPE: <code>bool</code> </p> <code>violations</code> <p>List of verification violations</p> <p> TYPE: <code>list[str]</code> </p> <code>traces_sample</code> <p>Sample of workflow traces</p> <p> TYPE: <code>list[tuple[Event, ...]]</code> </p> <code>counterexample</code> <p>Counterexample trace if refinement fails</p> <p> TYPE: <code>tuple[Event, ...] | None</code> </p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.WorkflowVerificationResult.passed","title":"<code>passed(traces_sample=None)</code>  <code>classmethod</code>","text":"<p>Create a passing verification result.</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.WorkflowVerificationResult.failed","title":"<code>failed(violations, is_deadlock_free=True, is_live=True, refines_spec=True, counterexample=None)</code>  <code>classmethod</code>","text":"<p>Create a failing verification result.</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.CSPOrchestrationAdapter","title":"<code>CSPOrchestrationAdapter</code>","text":"<p>Adapter integrating CSP process algebra with OrchestrationService.</p> <p>This adapter provides workflow verification using CSP refinement checking. It can verify that workflow implementations conform to their specifications and detect potential issues like deadlocks.</p> Usage <p>adapter = CSPOrchestrationAdapter()</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.CSPOrchestrationAdapter--register-a-workflow-specification","title":"Register a workflow specification","text":"<p>spec = WorkflowSpec.sequential_tasks(\"my_workflow\", [\"task1\", \"task2\"]) adapter.register_spec(spec)</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.CSPOrchestrationAdapter--verify-a-workflow-implementation","title":"Verify a workflow implementation","text":"<p>result = adapter.verify_workflow(\"my_workflow\", implementation_process)</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.CSPOrchestrationAdapter--check-deadlock-freedom","title":"Check deadlock freedom","text":"<p>is_safe = adapter.check_deadlock_freedom(\"my_workflow\")</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.CSPOrchestrationAdapter--analyze-liveness","title":"Analyze liveness","text":"<p>liveness = adapter.analyze_liveness(\"my_workflow\")</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.CSPOrchestrationAdapter.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the adapter.</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.CSPOrchestrationAdapter.register_spec","title":"<code>register_spec(spec)</code>","text":"<p>Register a workflow specification.</p> PARAMETER DESCRIPTION <code>spec</code> <p>The workflow specification</p> <p> TYPE: <code>WorkflowSpec</code> </p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.CSPOrchestrationAdapter.get_spec","title":"<code>get_spec(name)</code>","text":"<p>Get a registered workflow specification.</p> PARAMETER DESCRIPTION <code>name</code> <p>Workflow name</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>WorkflowSpec | None</code> <p>The specification, or None if not registered</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.CSPOrchestrationAdapter.register_implementation","title":"<code>register_implementation(name, process)</code>","text":"<p>Register a workflow implementation.</p> PARAMETER DESCRIPTION <code>name</code> <p>Workflow name</p> <p> TYPE: <code>str</code> </p> <code>process</code> <p>The CSP process implementation</p> <p> TYPE: <code>Process</code> </p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.CSPOrchestrationAdapter.verify_spec","title":"<code>verify_spec(spec)</code>","text":"<p>Verify a workflow specification is valid.</p> <p>Checks: - Deadlock freedom - Liveness of events of interest - Custom invariants</p> PARAMETER DESCRIPTION <code>spec</code> <p>The workflow specification</p> <p> TYPE: <code>WorkflowSpec</code> </p> RETURNS DESCRIPTION <code>WorkflowVerificationResult</code> <p>Verification result</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.CSPOrchestrationAdapter.verify_workflow","title":"<code>verify_workflow(name, implementation=None, mode='trace')</code>","text":"<p>Verify a workflow implementation against its specification.</p> PARAMETER DESCRIPTION <code>name</code> <p>Workflow name</p> <p> TYPE: <code>str</code> </p> <code>implementation</code> <p>Optional implementation process (uses registered if None)</p> <p> TYPE: <code>Process | None</code> DEFAULT: <code>None</code> </p> <code>mode</code> <p>Refinement mode (\"trace\", \"failures\", \"fd\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'trace'</code> </p> RETURNS DESCRIPTION <code>WorkflowVerificationResult</code> <p>Verification result</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.CSPOrchestrationAdapter.check_deadlock_freedom","title":"<code>check_deadlock_freedom(name)</code>","text":"<p>Check if a workflow specification is deadlock-free.</p> PARAMETER DESCRIPTION <code>name</code> <p>Workflow name</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if deadlock-free</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.CSPOrchestrationAdapter.analyze_workflow_liveness","title":"<code>analyze_workflow_liveness(name, events=None)</code>","text":"<p>Analyze liveness of events in a workflow.</p> PARAMETER DESCRIPTION <code>name</code> <p>Workflow name</p> <p> TYPE: <code>str</code> </p> <code>events</code> <p>Events to check (uses spec's events_of_interest if None)</p> <p> TYPE: <code>set[Event] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict[Event, bool]</code> <p>Mapping of event to liveness status</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.CSPOrchestrationAdapter.get_workflow_traces","title":"<code>get_workflow_traces(name, max_length=20, max_count=100)</code>","text":"<p>Get sample traces from a workflow.</p> PARAMETER DESCRIPTION <code>name</code> <p>Workflow name</p> <p> TYPE: <code>str</code> </p> <code>max_length</code> <p>Maximum trace length</p> <p> TYPE: <code>int</code> DEFAULT: <code>20</code> </p> <code>max_count</code> <p>Maximum number of traces</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> RETURNS DESCRIPTION <code>list[tuple[Event, ...]]</code> <p>List of traces</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.CSPOrchestrationAdapter.compose_workflows","title":"<code>compose_workflows(name, workflow_names, composition_type='parallel', sync_events=None)</code>","text":"<p>Compose multiple workflows into a new workflow.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name for the composed workflow</p> <p> TYPE: <code>str</code> </p> <code>workflow_names</code> <p>Names of workflows to compose</p> <p> TYPE: <code>list[str]</code> </p> <code>composition_type</code> <p>\"parallel\", \"sequential\", or \"choice\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> <code>sync_events</code> <p>Events to synchronize on (for parallel)</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>WorkflowSpec | None</code> <p>Composed workflow spec, or None if any workflow not found</p>"},{"location":"api/integration/csp-orchestration/#agenticraft_foundation.integration.csp_orchestration.CSPOrchestrationAdapter.workflow_to_process","title":"<code>workflow_to_process(dag)</code>","text":"<p>Convert an orchestration DAG to a CSP process.</p> <p>This method can be used to convert the OrchestrationService's internal DAG representation to a CSP process for verification.</p> PARAMETER DESCRIPTION <code>dag</code> <p>DAG definition with nodes and edges</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>Process</code> <p>CSP process representation</p>"},{"location":"api/integration/mpst-bridge/","title":"agenticraft_foundation.integration.mpst_bridge","text":"<p>MPST bridge adapter \u2014 maps MCP and A2A protocol interactions to multiparty session types for protocol-verified communication.</p> <p>MPST integration adapter for protocol bridges.</p> <p>This module provides session type verification for cross-protocol messaging.</p> <p>Key Features: - Session type verification before message routing - Protocol session type mapping (MCP, A2A \u2192 MPST types) - Runtime session conformance monitoring - Well-formedness checking for protocol session types</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.ProtocolName","title":"<code>ProtocolName</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported protocol names.</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.SessionStatus","title":"<code>SessionStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Status of a session.</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.ProtocolSessionType","title":"<code>ProtocolSessionType</code>  <code>dataclass</code>","text":"<p>Maps a protocol interaction to an MPST session type.</p> ATTRIBUTE DESCRIPTION <code>protocol</code> <p>The protocol name</p> <p> TYPE: <code>ProtocolName</code> </p> <code>method</code> <p>The protocol method (e.g., \"tools/call\", \"tasks/send\")</p> <p> TYPE: <code>str</code> </p> <code>session_type</code> <p>The corresponding MPST global type</p> <p> TYPE: <code>SessionType</code> </p> <code>participants</code> <p>Participant roles in the session</p> <p> TYPE: <code>frozenset[ParticipantId]</code> </p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.SessionVerificationResult","title":"<code>SessionVerificationResult</code>  <code>dataclass</code>","text":"<p>Result of session type verification.</p> ATTRIBUTE DESCRIPTION <code>is_valid</code> <p>Whether the session conforms to its type</p> <p> TYPE: <code>bool</code> </p> <code>session_type</code> <p>The verified session type</p> <p> TYPE: <code>SessionType | None</code> </p> <code>violations</code> <p>List of conformance violations</p> <p> TYPE: <code>list[str]</code> </p> <code>current_status</code> <p>Current status of the session</p> <p> TYPE: <code>SessionStatus</code> </p> <code>remaining_type</code> <p>Remaining session type to complete</p> <p> TYPE: <code>SessionType | None</code> </p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.SessionVerificationResult.valid","title":"<code>valid(session_type, remaining=None)</code>  <code>classmethod</code>","text":"<p>Create a valid verification result.</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.SessionVerificationResult.invalid","title":"<code>invalid(violations, session_type=None)</code>  <code>classmethod</code>","text":"<p>Create an invalid verification result.</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.ActiveSession","title":"<code>ActiveSession</code>  <code>dataclass</code>","text":"<p>Internal representation of an active session.</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.MPSTBridgeAdapter","title":"<code>MPSTBridgeAdapter</code>","text":"<p>Adapter integrating MPST session types with ProtocolBridge.</p> <p>This adapter provides session type verification for cross-protocol message routing. It hooks into the ProtocolBridge's translation and routing pipeline to ensure session conformance.</p> Usage <p>adapter = MPSTBridgeAdapter()</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.MPSTBridgeAdapter--register-session-type-for-a-protocol-method","title":"Register session type for a protocol method","text":"<p>adapter.register_session_type(mcp_tool_call_session())</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.MPSTBridgeAdapter--verify-message-conforms-to-session-type","title":"Verify message conforms to session type","text":"<p>result = adapter.verify_message(message, \"tools/call\", ProtocolName.MCP)</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.MPSTBridgeAdapter--start-a-monitored-session","title":"Start a monitored session","text":"<p>session_id = await adapter.start_session(     session_type=mcp_tool_call_session().session_type,     participants={\"client\": \"agent-1\", \"server\": \"agent-2\"}, )</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.MPSTBridgeAdapter--monitor-message-in-session","title":"Monitor message in session","text":"<p>await adapter.on_message(session_id, message)</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.MPSTBridgeAdapter.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the adapter.</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.MPSTBridgeAdapter.register_session_type","title":"<code>register_session_type(session_type)</code>","text":"<p>Register a session type for a protocol method.</p> PARAMETER DESCRIPTION <code>session_type</code> <p>The session type to register</p> <p> TYPE: <code>ProtocolSessionType</code> </p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.MPSTBridgeAdapter.get_session_type","title":"<code>get_session_type(protocol, method)</code>","text":"<p>Get the session type for a protocol method.</p> PARAMETER DESCRIPTION <code>protocol</code> <p>The protocol name</p> <p> TYPE: <code>ProtocolName</code> </p> <code>method</code> <p>The method name</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ProtocolSessionType | None</code> <p>The session type, or None if not registered</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.MPSTBridgeAdapter.verify_wellformedness","title":"<code>verify_wellformedness(session_type)</code>","text":"<p>Verify a session type is well-formed.</p> PARAMETER DESCRIPTION <code>session_type</code> <p>The global type to verify</p> <p> TYPE: <code>SessionType</code> </p> RETURNS DESCRIPTION <code>SessionVerificationResult</code> <p>Verification result</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.MPSTBridgeAdapter.verify_message","title":"<code>verify_message(message, method, protocol, participant=None)</code>","text":"<p>Verify a message conforms to the expected session type.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to verify</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>method</code> <p>The protocol method</p> <p> TYPE: <code>str</code> </p> <code>protocol</code> <p>The protocol name</p> <p> TYPE: <code>ProtocolName</code> </p> <code>participant</code> <p>Optional participant to verify as</p> <p> TYPE: <code>ParticipantId | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>SessionVerificationResult</code> <p>Verification result</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.MPSTBridgeAdapter.start_session","title":"<code>start_session(session_type, participants)</code>  <code>async</code>","text":"<p>Start a new monitored session.</p> PARAMETER DESCRIPTION <code>session_type</code> <p>The global session type</p> <p> TYPE: <code>SessionType</code> </p> <code>participants</code> <p>Mapping of participant roles to agent IDs</p> <p> TYPE: <code>dict[ParticipantId, str]</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Session ID for tracking</p> RAISES DESCRIPTION <code>ValueError</code> <p>If session type is not well-formed</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.MPSTBridgeAdapter.on_message","title":"<code>on_message(session_id, message, sender, receiver)</code>  <code>async</code>","text":"<p>Process a message in an active session.</p> PARAMETER DESCRIPTION <code>session_id</code> <p>The session ID</p> <p> TYPE: <code>str</code> </p> <code>message</code> <p>The message being sent</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>sender</code> <p>The sending participant role</p> <p> TYPE: <code>ParticipantId</code> </p> <code>receiver</code> <p>The receiving participant role</p> <p> TYPE: <code>ParticipantId</code> </p> RETURNS DESCRIPTION <code>SessionVerificationResult</code> <p>Verification result</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.MPSTBridgeAdapter.end_session","title":"<code>end_session(session_id)</code>  <code>async</code>","text":"<p>End a session and verify it completed properly.</p> PARAMETER DESCRIPTION <code>session_id</code> <p>The session ID</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>SessionVerificationResult</code> <p>Final verification result</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.MPSTBridgeAdapter.get_active_sessions","title":"<code>get_active_sessions()</code>","text":"<p>Get list of active session IDs.</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.MPSTBridgeAdapter.get_session_status","title":"<code>get_session_status(session_id)</code>","text":"<p>Get current status of all participants in a session.</p> PARAMETER DESCRIPTION <code>session_id</code> <p>The session ID</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict[ParticipantId, SessionStatus] | None</code> <p>Mapping of participant to status, or None if session not found</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.mcp_tool_call_session","title":"<code>mcp_tool_call_session()</code>","text":"<p>MCP tools/call session type: client \u2192 server : call. server \u2192 client : result.</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.mcp_resource_read_session","title":"<code>mcp_resource_read_session()</code>","text":"<p>MCP resources/read session type.</p>"},{"location":"api/integration/mpst-bridge/#agenticraft_foundation.integration.mpst_bridge.a2a_task_send_session","title":"<code>a2a_task_send_session()</code>","text":"<p>A2A tasks/send session type with status updates.</p>"},{"location":"api/mpst/","title":"mpst","text":"<p>Multiparty Session Types for specifying and verifying multi-party communication protocols.</p> <p>This module provides global type definitions, local type projection, well-formedness checking, runtime session monitoring, and 4 communication patterns.</p> <p>Multiparty Session Types (MPST) for formal protocol verification.</p> <p>This module provides a comprehensive framework for specifying and verifying multi-agent communication protocols using session types.</p> <p>Based on: Honda, Yoshida, Carbone (2008) - Multiparty Session Types</p> <p>Key Components: - Global Types: Bird's-eye view of session choreography - Local Types: Participant-specific session behavior - Projection: Global \u2192 Local type derivation - Type Checking: Static verification of well-formedness - Session Monitoring: Runtime conformance checking</p> Example"},{"location":"api/mpst/#agenticraft_foundation.mpst--define-a-request-response-protocol","title":"Define a request-response protocol","text":"<p>from agenticraft_foundation.mpst import (     msg, end, request_response, Projector, SessionTypeChecker, )</p>"},{"location":"api/mpst/#agenticraft_foundation.mpst--using-the-convenience-pattern","title":"Using the convenience pattern","text":"<p>protocol = request_response(\"client\", \"server\")</p>"},{"location":"api/mpst/#agenticraft_foundation.mpst--or-build-manually","title":"Or build manually","text":"<p>protocol = msg(\"client\", \"server\", \"request\",                msg(\"server\", \"client\", \"response\"))</p>"},{"location":"api/mpst/#agenticraft_foundation.mpst--project-to-local-types","title":"Project to local types","text":"<p>projector = Projector() client_type = projector.project(protocol, \"client\") server_type = projector.project(protocol, \"server\")</p>"},{"location":"api/mpst/#agenticraft_foundation.mpst--verify-well-formedness","title":"Verify well-formedness","text":"<p>checker = SessionTypeChecker() result = checker.verify_global(protocol) print(f\"Well-formed: {result.is_valid}\")</p>"},{"location":"api/mpst/#submodules","title":"Submodules","text":"Module Description <code>types</code> Session type definitions <code>global_types</code> Global type specification for multi-party protocols <code>local_types</code> Local type projection per role <code>checker</code> Well-formedness checking <code>patterns</code> 4 communication patterns"},{"location":"api/mpst/checker/","title":"agenticraft_foundation.mpst.checker","text":"<p>Well-formedness checking for session types \u2014 validates protocol structure and properties.</p> <p>Session type checker with runtime verification.</p> <p>This module provides type checking for MPST sessions, integrating with the InvariantRegistry for runtime verification of session properties.</p> <p>Key Features: - Well-formedness checking for global types - Session conformance checking against local types - Runtime monitoring with StateTransitionMonitor - Integration with InvariantRegistry for property verification</p> <p>References: - Honda, Yoshida, Carbone (2008) - Multiparty Session Types</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.WellFormednessResult","title":"<code>WellFormednessResult</code>  <code>dataclass</code>","text":"<p>Result of well-formedness checking.</p> ATTRIBUTE DESCRIPTION <code>is_well_formed</code> <p>Whether the type is well-formed</p> <p> TYPE: <code>bool</code> </p> <code>errors</code> <p>List of errors found</p> <p> TYPE: <code>list[str]</code> </p> <code>warnings</code> <p>List of warnings</p> <p> TYPE: <code>list[str]</code> </p> <code>participants</code> <p>Set of participants in the type</p> <p> TYPE: <code>set[ParticipantId]</code> </p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.WellFormednessChecker","title":"<code>WellFormednessChecker</code>","text":"<p>Checks well-formedness of global session types.</p> <p>A global type G is well-formed if: 1. All participants are reachable from the initial state 2. No orphan messages (every send has a matching receive) 3. Choice consistency (sender/receiver are distinct) 4. Recursion is guarded (no unguarded recursive calls) 5. Projection is defined for all participants</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.WellFormednessChecker.check","title":"<code>check(global_type)</code>","text":"<p>Check if a global type is well-formed.</p> PARAMETER DESCRIPTION <code>global_type</code> <p>Global session type to check</p> <p> TYPE: <code>SessionType</code> </p> RETURNS DESCRIPTION <code>WellFormednessResult</code> <p>WellFormednessResult with details</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionMonitor","title":"<code>SessionMonitor</code>  <code>dataclass</code>","text":"<p>Monitors a session's conformance to its local type.</p> <p>Tracks message exchanges and verifies they conform to the expected local type for each participant.</p> <p>Integrates with StateTransitionMonitor for transition tracking.</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionMonitor.on_send","title":"<code>on_send(receiver, payload)</code>","text":"<p>Handle a send action.</p> PARAMETER DESCRIPTION <code>receiver</code> <p>Target participant</p> <p> TYPE: <code>ParticipantId</code> </p> <code>payload</code> <p>Message payload</p> <p> TYPE: <code>MessagePayload</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if send conforms to local type</p> RAISES DESCRIPTION <code>TypeCheckError</code> <p>If strict and send doesn't conform</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionMonitor.on_receive","title":"<code>on_receive(sender, payload)</code>","text":"<p>Handle a receive action.</p> PARAMETER DESCRIPTION <code>sender</code> <p>Source participant</p> <p> TYPE: <code>ParticipantId</code> </p> <code>payload</code> <p>Message payload</p> <p> TYPE: <code>MessagePayload</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if receive conforms to local type</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionMonitor.is_complete","title":"<code>is_complete()</code>","text":"<p>Check if session has completed successfully.</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionMonitor.can_send","title":"<code>can_send()</code>","text":"<p>Check if next action is a send.</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionMonitor.can_receive","title":"<code>can_receive()</code>","text":"<p>Check if next action is a receive.</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionMonitor.get_violations","title":"<code>get_violations()</code>","text":"<p>Get all recorded violations.</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionMonitor.get_state","title":"<code>get_state()</code>","text":"<p>Get current monitor state.</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.MPSTInvariantRegistry","title":"<code>MPSTInvariantRegistry</code>","text":"<p>Registry of MPST-specific invariants.</p> <p>Provides standard session type invariants for runtime verification.</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.MPSTInvariantRegistry.__init__","title":"<code>__init__(registry=None)</code>","text":"<p>Initialize with optional parent registry.</p> PARAMETER DESCRIPTION <code>registry</code> <p>Parent InvariantRegistry to use</p> <p> TYPE: <code>InvariantRegistry | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.MPSTInvariantRegistry.check_all","title":"<code>check_all(monitors)</code>","text":"<p>Check all MPST invariants.</p> PARAMETER DESCRIPTION <code>monitors</code> <p>Dictionary of session monitors</p> <p> TYPE: <code>dict[ParticipantId, SessionMonitor]</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>List of violated invariant names</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionTypeChecker","title":"<code>SessionTypeChecker</code>","text":"<p>Complete session type checker with runtime monitoring.</p> <p>Provides: - Well-formedness checking of global types - Local type projection - Runtime session monitoring - Invariant verification</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionTypeChecker.__init__","title":"<code>__init__(registry=None)</code>","text":"<p>Initialize type checker.</p> PARAMETER DESCRIPTION <code>registry</code> <p>Optional InvariantRegistry for invariants</p> <p> TYPE: <code>InvariantRegistry | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionTypeChecker.check_well_formed","title":"<code>check_well_formed(global_type)</code>","text":"<p>Check if a global type is well-formed.</p> PARAMETER DESCRIPTION <code>global_type</code> <p>Global session type</p> <p> TYPE: <code>SessionType</code> </p> RETURNS DESCRIPTION <code>WellFormednessResult</code> <p>WellFormednessResult with details</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionTypeChecker.project","title":"<code>project(global_type, participant)</code>","text":"<p>Project global type to local type.</p> PARAMETER DESCRIPTION <code>global_type</code> <p>Global session type</p> <p> TYPE: <code>SessionType</code> </p> <code>participant</code> <p>Participant to project for</p> <p> TYPE: <code>ParticipantId</code> </p> RETURNS DESCRIPTION <code>SessionType</code> <p>Local session type</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionTypeChecker.create_session","title":"<code>create_session(session_id, global_type, strict=True)</code>","text":"<p>Create monitors for a new session.</p> PARAMETER DESCRIPTION <code>session_id</code> <p>Unique session identifier</p> <p> TYPE: <code>str</code> </p> <code>global_type</code> <p>Global session type</p> <p> TYPE: <code>SessionType</code> </p> <code>strict</code> <p>If True, raise on type violations</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>dict[ParticipantId, SessionMonitor]</code> <p>Dictionary of monitors per participant</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionTypeChecker.get_session","title":"<code>get_session(session_id)</code>","text":"<p>Get monitors for an active session.</p> PARAMETER DESCRIPTION <code>session_id</code> <p>Session identifier</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict[ParticipantId, SessionMonitor] | None</code> <p>Dictionary of monitors or None if not found</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionTypeChecker.close_session","title":"<code>close_session(session_id)</code>","text":"<p>Close and remove a session.</p> PARAMETER DESCRIPTION <code>session_id</code> <p>Session to close</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if session was active and closed</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionTypeChecker.check_invariants","title":"<code>check_invariants(session_id)</code>","text":"<p>Check MPST invariants for a session.</p> PARAMETER DESCRIPTION <code>session_id</code> <p>Session to check</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>List of violated invariant names</p>"},{"location":"api/mpst/checker/#agenticraft_foundation.mpst.checker.SessionTypeChecker.get_statistics","title":"<code>get_statistics()</code>","text":"<p>Get checker statistics.</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Dictionary with statistics</p>"},{"location":"api/mpst/global-types/","title":"agenticraft_foundation.mpst.global_types","text":"<p>Global type specification \u2014 bird's-eye view of multi-party protocols.</p> <p>Global session types for multi-party choreographies.</p> <p>Global types describe the overall communication structure from a bird's-eye view, specifying message exchanges between all participants.</p> <p>Syntax: - p \u2192 q : M.G        (Message: p sends M to q, then continue with G) - p \u2192 q : {l\u1d62: G\u1d62}  (Choice: p sends choice l\u1d62 to q, continue with G\u1d62) - \u03bcX.G               (Recursion: recursive type bound to X) - X                  (Variable: recursion variable reference) - end                (End: successful termination)</p> <p>References: - Honda, Yoshida, Carbone (2008) - Multiparty Session Types</p>"},{"location":"api/mpst/global-types/#agenticraft_foundation.mpst.global_types.EndType","title":"<code>EndType</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SessionType</code></p> <p>End type: Successful session termination.</p> <p>Represents the end of a session with no further communication. Written as 'end' in session type notation.</p>"},{"location":"api/mpst/global-types/#agenticraft_foundation.mpst.global_types.MessageType","title":"<code>MessageType</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SessionType</code></p> <p>Message type: p \u2192 q : M.G</p> <p>Represents a single message from sender to receiver, followed by a continuation.</p> ATTRIBUTE DESCRIPTION <code>sender</code> <p>Sending participant p</p> <p> TYPE: <code>ParticipantId</code> </p> <code>receiver</code> <p>Receiving participant q</p> <p> TYPE: <code>ParticipantId</code> </p> <code>payload</code> <p>Message payload M</p> <p> TYPE: <code>MessagePayload</code> </p> <code>continuation</code> <p>Continuation type G</p> <p> TYPE: <code>SessionType</code> </p>"},{"location":"api/mpst/global-types/#agenticraft_foundation.mpst.global_types.ChoiceType","title":"<code>ChoiceType</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SessionType</code></p> <p>Choice type: p \u2192 q : {l\u1d62: G\u1d62}</p> <p>Represents a branching choice where sender selects a label and both parties continue with the corresponding branch.</p> ATTRIBUTE DESCRIPTION <code>sender</code> <p>Participant making the choice p</p> <p> TYPE: <code>ParticipantId</code> </p> <code>receiver</code> <p>Participant receiving the choice q</p> <p> TYPE: <code>ParticipantId</code> </p> <code>branches</code> <p>Mapping from labels to continuation types</p> <p> TYPE: <code>dict[MessageLabel, SessionType]</code> </p>"},{"location":"api/mpst/global-types/#agenticraft_foundation.mpst.global_types.RecursionType","title":"<code>RecursionType</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SessionType</code></p> <p>Recursion type: \u03bcX.G</p> <p>Represents a recursive session type where variable X is bound in the body G.</p> ATTRIBUTE DESCRIPTION <code>variable</code> <p>Recursion variable name X</p> <p> TYPE: <code>str</code> </p> <code>body</code> <p>Body of the recursion G</p> <p> TYPE: <code>SessionType</code> </p>"},{"location":"api/mpst/global-types/#agenticraft_foundation.mpst.global_types.RecursionType.unfold_once","title":"<code>unfold_once()</code>","text":"<p>Unfold one level of recursion.</p> <p>Returns the body with the variable replaced by self.</p>"},{"location":"api/mpst/global-types/#agenticraft_foundation.mpst.global_types.VariableType","title":"<code>VariableType</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SessionType</code></p> <p>Variable type: X</p> <p>Represents a recursion variable reference.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Variable name</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/mpst/global-types/#agenticraft_foundation.mpst.global_types.ParallelType","title":"<code>ParallelType</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SessionType</code></p> <p>Parallel composition: G\u2081 | G\u2082</p> <p>Represents parallel execution of two independent sessions. Participants of G\u2081 and G\u2082 should be disjoint.</p> ATTRIBUTE DESCRIPTION <code>left</code> <p>Left session type G\u2081</p> <p> TYPE: <code>SessionType</code> </p> <code>right</code> <p>Right session type G\u2082</p> <p> TYPE: <code>SessionType</code> </p>"},{"location":"api/mpst/global-types/#agenticraft_foundation.mpst.global_types.msg","title":"<code>msg(sender, receiver, label, continuation=None, payload_type='any')</code>","text":"<p>Convenience constructor for MessageType.</p> PARAMETER DESCRIPTION <code>sender</code> <p>Sending participant</p> <p> TYPE: <code>str | ParticipantId</code> </p> <code>receiver</code> <p>Receiving participant</p> <p> TYPE: <code>str | ParticipantId</code> </p> <code>label</code> <p>Message label</p> <p> TYPE: <code>str | MessageLabel</code> </p> <code>continuation</code> <p>Continuation type (default: EndType)</p> <p> TYPE: <code>SessionType | None</code> DEFAULT: <code>None</code> </p> <code>payload_type</code> <p>Type of payload</p> <p> TYPE: <code>str</code> DEFAULT: <code>'any'</code> </p> RETURNS DESCRIPTION <code>MessageType</code> <p>MessageType instance</p> Example"},{"location":"api/mpst/global-types/#agenticraft_foundation.mpst.global_types.msg--client-server-request-server-client-response-end","title":"Client \u2192 Server : Request. Server \u2192 Client : Response. end","text":"<p>msg(\"client\", \"server\", \"request\",     msg(\"server\", \"client\", \"response\"))</p>"},{"location":"api/mpst/global-types/#agenticraft_foundation.mpst.global_types.choice","title":"<code>choice(sender, receiver, branches)</code>","text":"<p>Convenience constructor for ChoiceType.</p> PARAMETER DESCRIPTION <code>sender</code> <p>Participant making the choice</p> <p> TYPE: <code>str | ParticipantId</code> </p> <code>receiver</code> <p>Participant receiving the choice</p> <p> TYPE: <code>str | ParticipantId</code> </p> <code>branches</code> <p>Mapping from label strings to continuation types</p> <p> TYPE: <code>dict[str, SessionType]</code> </p> RETURNS DESCRIPTION <code>ChoiceType</code> <p>ChoiceType instance</p> Example <p>choice(\"client\", \"server\", {     \"buy\": msg(\"server\", \"client\", \"confirm\"),     \"cancel\": msg(\"server\", \"client\", \"cancelled\"), })</p>"},{"location":"api/mpst/global-types/#agenticraft_foundation.mpst.global_types.rec","title":"<code>rec(variable, body)</code>","text":"<p>Convenience constructor for RecursionType.</p> PARAMETER DESCRIPTION <code>variable</code> <p>Recursion variable name</p> <p> TYPE: <code>str</code> </p> <code>body</code> <p>Body of the recursion</p> <p> TYPE: <code>SessionType</code> </p> RETURNS DESCRIPTION <code>RecursionType</code> <p>RecursionType instance</p> Example"},{"location":"api/mpst/global-types/#agenticraft_foundation.mpst.global_types.rec--x-client-server-request-server-client-response-x","title":"\u03bcX. Client \u2192 Server : Request. Server \u2192 Client : Response. X","text":"<p>rec(\"X\", msg(\"client\", \"server\", \"request\",             msg(\"server\", \"client\", \"response\", var(\"X\"))))</p>"},{"location":"api/mpst/global-types/#agenticraft_foundation.mpst.global_types.var","title":"<code>var(name)</code>","text":"<p>Convenience constructor for VariableType.</p> PARAMETER DESCRIPTION <code>name</code> <p>Variable name</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>VariableType</code> <p>VariableType instance</p>"},{"location":"api/mpst/global-types/#agenticraft_foundation.mpst.global_types.end","title":"<code>end()</code>","text":"<p>Convenience constructor for EndType.</p> RETURNS DESCRIPTION <code>EndType</code> <p>EndType instance</p>"},{"location":"api/mpst/global-types/#agenticraft_foundation.mpst.global_types.parallel","title":"<code>parallel(left, right)</code>","text":"<p>Convenience constructor for ParallelType.</p> PARAMETER DESCRIPTION <code>left</code> <p>Left session type</p> <p> TYPE: <code>SessionType</code> </p> <code>right</code> <p>Right session type</p> <p> TYPE: <code>SessionType</code> </p> RETURNS DESCRIPTION <code>ParallelType</code> <p>ParallelType instance</p>"},{"location":"api/mpst/local-types/","title":"agenticraft_foundation.mpst.local_types","text":"<p>Local type projection \u2014 per-role views derived from global types.</p> <p>Local session types and projection algorithm.</p> <p>Local types describe the communication behavior from a single participant's perspective. They are derived from global types via projection.</p> <p>Local Type Syntax: - !q(M).L           (Send: send M to q, then continue with L) - ?p(M).L           (Receive: receive M from p, then continue with L) - \u2295q{l\u1d62: L\u1d62}      (Select: send choice l\u1d62 to q) - &amp;p{l\u1d62: L\u1d62}      (Branch: receive choice from p) - \u03bcX.L              (Recursion) - X                 (Variable) - end               (End)</p> <p>Projection Rules: - (p \u2192 q : M.G) \u2193 p = !q(M).(G \u2193 p)      (sender projects to send) - (p \u2192 q : M.G) \u2193 q = ?p(M).(G \u2193 q)      (receiver projects to receive) - (p \u2192 q : M.G) \u2193 r = G \u2193 r              (other participants skip)</p> <p>Key Theorem: If G \u2193 p is defined for all p \u2208 participants(G), then the local types are consistent and the session is deadlock-free.</p> <p>References: - Honda, Yoshida, Carbone (2008) - Multiparty Session Types</p>"},{"location":"api/mpst/local-types/#agenticraft_foundation.mpst.local_types.LocalEndType","title":"<code>LocalEndType</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SessionType</code></p> <p>Local end type: Session termination from local perspective.</p>"},{"location":"api/mpst/local-types/#agenticraft_foundation.mpst.local_types.SendType","title":"<code>SendType</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SessionType</code></p> <p>Send type: !q(M).L</p> <p>Send message M to participant q, then continue with L.</p> ATTRIBUTE DESCRIPTION <code>receiver</code> <p>Target participant q</p> <p> TYPE: <code>ParticipantId</code> </p> <code>payload</code> <p>Message payload M</p> <p> TYPE: <code>MessagePayload</code> </p> <code>continuation</code> <p>Continuation type L</p> <p> TYPE: <code>SessionType</code> </p>"},{"location":"api/mpst/local-types/#agenticraft_foundation.mpst.local_types.ReceiveType","title":"<code>ReceiveType</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SessionType</code></p> <p>Receive type: ?p(M).L</p> <p>Receive message M from participant p, then continue with L.</p> ATTRIBUTE DESCRIPTION <code>sender</code> <p>Source participant p</p> <p> TYPE: <code>ParticipantId</code> </p> <code>payload</code> <p>Message payload M</p> <p> TYPE: <code>MessagePayload</code> </p> <code>continuation</code> <p>Continuation type L</p> <p> TYPE: <code>SessionType</code> </p>"},{"location":"api/mpst/local-types/#agenticraft_foundation.mpst.local_types.SelectType","title":"<code>SelectType</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SessionType</code></p> <p>Select type: \u2295q{l\u1d62: L\u1d62}</p> <p>Send choice to participant q, selecting one of the labels.</p> ATTRIBUTE DESCRIPTION <code>receiver</code> <p>Target participant q</p> <p> TYPE: <code>ParticipantId</code> </p> <code>branches</code> <p>Available choices with continuations</p> <p> TYPE: <code>dict[MessageLabel, SessionType]</code> </p>"},{"location":"api/mpst/local-types/#agenticraft_foundation.mpst.local_types.BranchType","title":"<code>BranchType</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SessionType</code></p> <p>Branch type: &amp;p{l\u1d62: L\u1d62}</p> <p>Receive choice from participant p, branching on the label.</p> ATTRIBUTE DESCRIPTION <code>sender</code> <p>Source participant p</p> <p> TYPE: <code>ParticipantId</code> </p> <code>branches</code> <p>Possible branches with continuations</p> <p> TYPE: <code>dict[MessageLabel, SessionType]</code> </p>"},{"location":"api/mpst/local-types/#agenticraft_foundation.mpst.local_types.LocalRecursionType","title":"<code>LocalRecursionType</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SessionType</code></p> <p>Local recursion type: \u03bcX.L</p> ATTRIBUTE DESCRIPTION <code>variable</code> <p>Recursion variable name</p> <p> TYPE: <code>str</code> </p> <code>body</code> <p>Body of the recursion</p> <p> TYPE: <code>SessionType</code> </p>"},{"location":"api/mpst/local-types/#agenticraft_foundation.mpst.local_types.LocalVariableType","title":"<code>LocalVariableType</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SessionType</code></p> <p>Local variable type: X</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Variable name</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/mpst/local-types/#agenticraft_foundation.mpst.local_types.Projector","title":"<code>Projector</code>","text":"<p>Projects global session types to local types for each participant.</p> <p>The projection algorithm derives the local view of a session from the global choreography.</p> <p>Key Property: If projection is defined for all participants, the session is well-formed and deadlock-free.</p>"},{"location":"api/mpst/local-types/#agenticraft_foundation.mpst.local_types.Projector.__init__","title":"<code>__init__(strict=True)</code>","text":"<p>Initialize projector.</p> PARAMETER DESCRIPTION <code>strict</code> <p>If True, raise errors on projection failure.    If False, return None on failure.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"api/mpst/local-types/#agenticraft_foundation.mpst.local_types.Projector.project","title":"<code>project(global_type, participant)</code>","text":"<p>Project global type to local type for participant.</p> <p>G \u2193 p = local type for participant p</p> PARAMETER DESCRIPTION <code>global_type</code> <p>Global session type G</p> <p> TYPE: <code>SessionType</code> </p> <code>participant</code> <p>Participant to project to p</p> <p> TYPE: <code>ParticipantId</code> </p> RETURNS DESCRIPTION <code>SessionType | None</code> <p>Local session type (G \u2193 p), or None if undefined</p> RAISES DESCRIPTION <code>ProjectionError</code> <p>If projection fails and strict=True</p>"},{"location":"api/mpst/local-types/#agenticraft_foundation.mpst.local_types.Projector.project_all","title":"<code>project_all(global_type, participants=None)</code>","text":"<p>Project global type to local types for all (or specified) participants.</p> PARAMETER DESCRIPTION <code>global_type</code> <p>Global session type</p> <p> TYPE: <code>SessionType</code> </p> <code>participants</code> <p>Optional subset of participants to project. If None, auto-discovers all participants from the global type.</p> <p> TYPE: <code>set[ParticipantId] | list[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict[ParticipantId, SessionType]</code> <p>Dictionary mapping each participant to their local type</p> RAISES DESCRIPTION <code>ProjectionError</code> <p>If projection fails for any participant</p>"},{"location":"api/mpst/local-types/#agenticraft_foundation.mpst.local_types.project","title":"<code>project(global_type, participant, strict=True)</code>","text":"<p>Project global type to local type for a participant.</p> PARAMETER DESCRIPTION <code>global_type</code> <p>Global session type</p> <p> TYPE: <code>SessionType</code> </p> <code>participant</code> <p>Participant ID</p> <p> TYPE: <code>ParticipantId | str</code> </p> <code>strict</code> <p>If True, raise on failure</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>SessionType | None</code> <p>Local type or None if undefined</p>"},{"location":"api/mpst/local-types/#agenticraft_foundation.mpst.local_types.project_all","title":"<code>project_all(global_type, participants=None)</code>","text":"<p>Project global type to local types for all (or specified) participants.</p> PARAMETER DESCRIPTION <code>global_type</code> <p>Global session type</p> <p> TYPE: <code>SessionType</code> </p> <code>participants</code> <p>Optional subset of participants to project. If None, auto-discovers all participants from the global type.</p> <p> TYPE: <code>set[ParticipantId] | list[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict[ParticipantId, SessionType]</code> <p>Dictionary of local types per participant</p>"},{"location":"api/mpst/patterns/","title":"agenticraft_foundation.mpst.patterns","text":"<p>4 communication patterns built from session types: request-response, pipeline, scatter-gather, consensus.</p> <p>Common multi-agent session patterns.</p> <p>This module provides reusable session type patterns for common multi-agent communication scenarios.</p> <p>Patterns: - RequestResponse: Simple client-server request-response - ScatterGather: Coordinator sends to all, gathers responses - Pipeline: Sequential processing through stages - Consensus: Multi-party agreement protocol</p> <p>Each pattern provides: - Global type constructor - Local type projections - Example usage</p>"},{"location":"api/mpst/patterns/#agenticraft_foundation.mpst.patterns.ConsensusPattern","title":"<code>ConsensusPattern</code>  <code>dataclass</code>","text":"<p>Two-Phase Commit consensus pattern.</p> ATTRIBUTE DESCRIPTION <code>coordinator</code> <p>Coordinator participant ID</p> <p> TYPE: <code>ParticipantId | str</code> </p> <code>participants</code> <p>List of participant IDs</p> <p> TYPE: <code>Sequence[ParticipantId | str]</code> </p> <code>prepare_label</code> <p>Label for prepare messages</p> <p> TYPE: <code>str</code> </p> <code>vote_yes_label</code> <p>Label for affirmative vote</p> <p> TYPE: <code>str</code> </p> <code>vote_no_label</code> <p>Label for negative vote</p> <p> TYPE: <code>str</code> </p> <code>commit_label</code> <p>Label for commit decision</p> <p> TYPE: <code>str</code> </p> <code>abort_label</code> <p>Label for abort decision</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/mpst/patterns/#agenticraft_foundation.mpst.patterns.ConsensusPattern.global_type","title":"<code>global_type(with_choice=False)</code>","text":"<p>Build the global session type.</p> PARAMETER DESCRIPTION <code>with_choice</code> <p>If True, include explicit choice branches         (only practical for 1-2 participants)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>SessionType</code> <p>Global type for two-phase commit</p>"},{"location":"api/mpst/patterns/#agenticraft_foundation.mpst.patterns.ConsensusPattern.participants_set","title":"<code>participants_set()</code>","text":"<p>Get all participants including coordinator.</p>"},{"location":"api/mpst/patterns/#agenticraft_foundation.mpst.patterns.PipelinePattern","title":"<code>PipelinePattern</code>  <code>dataclass</code>","text":"<p>Pipeline session pattern.</p> ATTRIBUTE DESCRIPTION <code>stages</code> <p>List of stage participant IDs in order</p> <p> TYPE: <code>Sequence[ParticipantId | str]</code> </p> <code>data_label</code> <p>Label for data messages between stages</p> <p> TYPE: <code>str</code> </p> <code>repeatable</code> <p>If True, pipeline can repeat</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/mpst/patterns/#agenticraft_foundation.mpst.patterns.PipelinePattern.global_type","title":"<code>global_type()</code>","text":"<p>Build the global session type.</p> RETURNS DESCRIPTION <code>SessionType</code> <p>Global type for pipeline</p> The type is <p>Stage_1 \u2192 Stage_2 : Data. Stage_2 \u2192 Stage_3 : Data. ... Stage_{n-1} \u2192 Stage_n : Data. end (or X for repeatable)</p>"},{"location":"api/mpst/patterns/#agenticraft_foundation.mpst.patterns.PipelinePattern.participants","title":"<code>participants()</code>","text":"<p>Get all participants in the pipeline.</p> RETURNS DESCRIPTION <code>set[ParticipantId]</code> <p>Set of stage participant identifiers.</p>"},{"location":"api/mpst/patterns/#agenticraft_foundation.mpst.patterns.RequestResponsePattern","title":"<code>RequestResponsePattern</code>  <code>dataclass</code>","text":"<p>Request-Response session pattern.</p> ATTRIBUTE DESCRIPTION <code>client</code> <p>Client participant ID</p> <p> TYPE: <code>ParticipantId | str</code> </p> <code>server</code> <p>Server participant ID</p> <p> TYPE: <code>ParticipantId | str</code> </p> <code>request_label</code> <p>Label for request message</p> <p> TYPE: <code>str</code> </p> <code>response_label</code> <p>Label for response message</p> <p> TYPE: <code>str</code> </p> <code>repeatable</code> <p>If True, pattern can repeat</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/mpst/patterns/#agenticraft_foundation.mpst.patterns.RequestResponsePattern.global_type","title":"<code>global_type()</code>","text":"<p>Build the global session type.</p> RETURNS DESCRIPTION <code>SessionType</code> <p>Global type for request-response</p>"},{"location":"api/mpst/patterns/#agenticraft_foundation.mpst.patterns.RequestResponsePattern.participants","title":"<code>participants()</code>","text":"<p>Get all participants in the request-response interaction.</p> RETURNS DESCRIPTION <code>set[ParticipantId]</code> <p>Set containing the client and server identifiers.</p>"},{"location":"api/mpst/patterns/#agenticraft_foundation.mpst.patterns.ScatterGatherPattern","title":"<code>ScatterGatherPattern</code>  <code>dataclass</code>","text":"<p>Scatter-Gather session pattern.</p> ATTRIBUTE DESCRIPTION <code>coordinator</code> <p>Coordinator participant ID</p> <p> TYPE: <code>ParticipantId | str</code> </p> <code>workers</code> <p>List of worker participant IDs</p> <p> TYPE: <code>Sequence[ParticipantId | str]</code> </p> <code>task_label</code> <p>Label for task messages</p> <p> TYPE: <code>str</code> </p> <code>result_label</code> <p>Label for result messages</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/mpst/patterns/#agenticraft_foundation.mpst.patterns.ScatterGatherPattern.global_type","title":"<code>global_type()</code>","text":"<p>Build the global session type.</p> RETURNS DESCRIPTION <code>SessionType</code> <p>Global type for scatter-gather</p> The type is <p>Coordinator \u2192 Worker_1 : Task. ... Coordinator \u2192 Worker_n : Task. Worker_1 \u2192 Coordinator : Result. ... Worker_n \u2192 Coordinator : Result. end</p>"},{"location":"api/mpst/patterns/#agenticraft_foundation.mpst.patterns.ScatterGatherPattern.participants","title":"<code>participants()</code>","text":"<p>Get all participants in the scatter-gather pattern.</p> RETURNS DESCRIPTION <code>set[ParticipantId]</code> <p>Set containing the coordinator and all worker identifiers.</p>"},{"location":"api/mpst/patterns/#agenticraft_foundation.mpst.patterns.two_phase_commit","title":"<code>two_phase_commit(coordinator='coordinator', participants=None, with_choice=False)</code>","text":"<p>Create a two-phase commit global type.</p> PARAMETER DESCRIPTION <code>coordinator</code> <p>Coordinator participant name</p> <p> TYPE: <code>str</code> DEFAULT: <code>'coordinator'</code> </p> <code>participants</code> <p>List of participant names</p> <p> TYPE: <code>Sequence[str] | None</code> DEFAULT: <code>None</code> </p> <code>with_choice</code> <p>Include explicit choice branches (only for 1-2 participants)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>SessionType</code> <p>Global session type</p> Example"},{"location":"api/mpst/patterns/#agenticraft_foundation.mpst.patterns.two_phase_commit--simple-2pc-with-2-participants","title":"Simple 2PC with 2 participants","text":"<p>g = two_phase_commit()</p>"},{"location":"api/mpst/patterns/#agenticraft_foundation.mpst.patterns.two_phase_commit--custom-participants","title":"Custom participants","text":"<p>g = two_phase_commit(\"leader\", [\"replica1\", \"replica2\", \"replica3\"])</p>"},{"location":"api/mpst/patterns/#agenticraft_foundation.mpst.patterns.two_phase_commit--with-explicit-branching-for-2-participants","title":"With explicit branching (for 2 participants)","text":"<p>g = two_phase_commit(with_choice=True)</p>"},{"location":"api/mpst/types/","title":"agenticraft_foundation.mpst.types","text":"<p>Session type definitions \u2014 base types for global and local session specifications.</p> <p>Core type definitions for Multiparty Session Types (MPST).</p> <p>This module provides the foundational types for MPST-based verification of multi-agent choreographies.</p> <p>References: - Honda, Yoshida, Carbone (2008) - Multiparty Session Types - Scalas, Yoshida (2019) - Less is More: Multiparty Session Types Revisited</p> <p>Key Theorem: Well-typed sessions are deadlock-free. If all participants conform to their local projections, the global protocol is deadlock-free.</p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.ParticipantId","title":"<code>ParticipantId</code>","text":"<p>               Bases: <code>str</code></p> <p>Unique identifier for a session participant (agent).</p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.MessageLabel","title":"<code>MessageLabel</code>","text":"<p>               Bases: <code>str</code></p> <p>Label for a message type in session communication.</p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.SessionState","title":"<code>SessionState</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>States of a session execution.</p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.TypeKind","title":"<code>TypeKind</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Kinds of session types.</p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.MessagePayload","title":"<code>MessagePayload</code>  <code>dataclass</code>","text":"<p>Payload type for session messages.</p> ATTRIBUTE DESCRIPTION <code>label</code> <p>Message label/type identifier</p> <p> TYPE: <code>MessageLabel</code> </p> <code>payload_type</code> <p>Type of the payload data</p> <p> TYPE: <code>str</code> </p> <code>schema</code> <p>Optional JSON schema for validation</p> <p> TYPE: <code>dict[str, Any] | None</code> </p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.SessionMessage","title":"<code>SessionMessage</code>  <code>dataclass</code>","text":"<p>A message in a session.</p> ATTRIBUTE DESCRIPTION <code>sender</code> <p>Sending participant</p> <p> TYPE: <code>ParticipantId</code> </p> <code>receiver</code> <p>Receiving participant</p> <p> TYPE: <code>ParticipantId</code> </p> <code>payload</code> <p>Message payload</p> <p> TYPE: <code>MessagePayload</code> </p> <code>session_id</code> <p>Session this message belongs to</p> <p> TYPE: <code>str</code> </p> <code>sequence</code> <p>Sequence number in session</p> <p> TYPE: <code>int</code> </p> <code>metadata</code> <p>Additional message metadata</p> <p> TYPE: <code>dict[str, Any]</code> </p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.SessionContext","title":"<code>SessionContext</code>  <code>dataclass</code>","text":"<p>Runtime context for session execution.</p> ATTRIBUTE DESCRIPTION <code>session_id</code> <p>Unique session identifier</p> <p> TYPE: <code>str</code> </p> <code>participants</code> <p>Set of participant IDs</p> <p> TYPE: <code>set[ParticipantId]</code> </p> <code>current_state</code> <p>Current execution state</p> <p> TYPE: <code>SessionState</code> </p> <code>message_history</code> <p>History of messages exchanged</p> <p> TYPE: <code>list[SessionMessage]</code> </p> <code>local_states</code> <p>Per-participant local state</p> <p> TYPE: <code>dict[ParticipantId, str]</code> </p> <code>metadata</code> <p>Additional context metadata</p> <p> TYPE: <code>dict[str, Any]</code> </p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.SessionContext.add_message","title":"<code>add_message(message)</code>","text":"<p>Record a message in the session history.</p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.SessionContext.get_participant_messages","title":"<code>get_participant_messages(participant)</code>","text":"<p>Get all messages involving a participant.</p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.SessionType","title":"<code>SessionType</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base for session types (both global and local).</p> <p>Session types describe the structure of multi-party communication.</p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.SessionType.kind","title":"<code>kind</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The kind of session type.</p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.SessionType.participants","title":"<code>participants()</code>  <code>abstractmethod</code>","text":"<p>Get all participants referenced in this type.</p> RETURNS DESCRIPTION <code>set[ParticipantId]</code> <p>Set of participant identifiers.</p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.SessionType.is_terminated","title":"<code>is_terminated()</code>  <code>abstractmethod</code>","text":"<p>Check if this type represents termination.</p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.SessionType.unfold","title":"<code>unfold(bindings)</code>  <code>abstractmethod</code>","text":"<p>Unfold recursion variables with given bindings.</p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.ProjectionError","title":"<code>ProjectionError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error during type projection.</p> ATTRIBUTE DESCRIPTION <code>message</code> <p>Error message</p> <p> TYPE: <code>str</code> </p> <code>participant</code> <p>Participant being projected</p> <p> TYPE: <code>ParticipantId | None</code> </p> <code>global_type</code> <p>Global type being projected</p> <p> TYPE: <code>SessionType | None</code> </p> <code>cause</code> <p>Original exception if any</p> <p> TYPE: <code>Exception | None</code> </p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.TypeCheckError","title":"<code>TypeCheckError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error during type checking.</p> ATTRIBUTE DESCRIPTION <code>message</code> <p>Error message</p> <p> TYPE: <code>str</code> </p> <code>expected</code> <p>Expected type</p> <p> TYPE: <code>SessionType | None</code> </p> <code>actual</code> <p>Actual type encountered</p> <p> TYPE: <code>SessionType | None</code> </p> <code>location</code> <p>Location in the session</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/mpst/types/#agenticraft_foundation.mpst.types.SessionViolation","title":"<code>SessionViolation</code>  <code>dataclass</code>","text":"<p>A violation of session type rules.</p> ATTRIBUTE DESCRIPTION <code>violation_type</code> <p>Type of violation</p> <p> TYPE: <code>str</code> </p> <code>message</code> <p>Detailed message</p> <p> TYPE: <code>str</code> </p> <code>participant</code> <p>Participant involved</p> <p> TYPE: <code>ParticipantId | None</code> </p> <code>expected_action</code> <p>What was expected</p> <p> TYPE: <code>str</code> </p> <code>actual_action</code> <p>What actually happened</p> <p> TYPE: <code>str</code> </p> <code>context</code> <p>Additional context</p> <p> TYPE: <code>dict[str, Any]</code> </p>"},{"location":"api/protocols/","title":"protocols","text":"<p>Multi-protocol mesh model with formal graph representation, routing algorithms, workflow validation, and composable protocol transformers.</p> <p>Formal protocol model for multi-protocol mesh.</p> <p>Implements the formal model with the following components:</p> <ul> <li>G = (V, E, P, \u03a6, \u0393): Protocol graph model.</li> <li>Protocol-Aware Dijkstra: Optimal routing with translation costs.</li> <li>Semantic Preservation: Round-trip verification.</li> <li>Formal Specifications: Protocol routing property verification.</li> </ul> <p>Example::</p> <pre><code>from agenticraft_foundation.protocols import (\n    ProtocolGraph, ProtocolAwareDijkstra, SemanticPreservationVerifier,\n)\n\ngraph = ProtocolGraph()\ngraph.add_agent(\"agent1\", [\"code_execution\"], {ProtocolName.MCP})\ngraph.add_agent(\"agent2\", [\"task_delegation\"], {ProtocolName.A2A})\ngraph.add_edge(\"agent1\", \"agent2\", {ProtocolName.MCP, ProtocolName.A2A})\n</code></pre>"},{"location":"api/protocols/#submodules","title":"Submodules","text":"Module Description <code>graph</code> Protocol graph \\(G = (V, E, P, \\Phi, \\Gamma)\\) <code>routing</code> Dijkstra, BFS, and resilient routing algorithms <code>semantic_routing</code> Capability-based semantic routing <code>compatibility</code> Protocol compatibility matrix and translation costs <code>cost</code> Path cost calculation with configurable edge cost models <code>affinity</code> Protocol affinity scoring per agent-protocol pair <code>workflow</code> Workflow model \\(W = (T, \\prec, \\rho)\\) with validation <code>transformers</code> Composable protocol message transformers <code>semantic</code> Semantic routing implementations <code>specifications</code> Formal protocol specifications"},{"location":"api/protocols/affinity/","title":"agenticraft_foundation.protocols.affinity","text":"<p>Protocol affinity scoring \u2014 measures how well an agent supports a given protocol.</p> <p>Capability-protocol affinity matrix: \u03b1(c, p) \u2192 [0, 1].</p> <p>Maps capabilities to optimal protocols based on protocol characteristics. Higher affinity indicates better suitability.</p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.AffinityConfig","title":"<code>AffinityConfig</code>  <code>dataclass</code>","text":"<p>Configuration for affinity calculations.</p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.AffinityConfig.default_affinity","title":"<code>default_affinity = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default affinity for unknown capability-protocol pairs</p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.AffinityConfig.min_affinity","title":"<code>min_affinity = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Minimum affinity value</p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.AffinityConfig.max_affinity","title":"<code>max_affinity = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum affinity value</p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.AffinityConfig.aggregation_method","title":"<code>aggregation_method = 'weighted_average'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Aggregation method: 'average', 'weighted_average', 'max', 'min'.</p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.CapabilityAffinityMatrix","title":"<code>CapabilityAffinityMatrix</code>","text":"<p>Lookup capability-protocol affinities.</p> <p>The affinity matrix maps capabilities to protocols, indicating how well each protocol supports specific capabilities. Higher values (closer to 1.0) indicate better fit.</p> Usage <p>matrix = CapabilityAffinityMatrix()</p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.CapabilityAffinityMatrix--get-affinity-for-a-single-capability","title":"Get affinity for a single capability","text":"<p>affinity = matrix.get_affinity(\"code_execution\", ProtocolName.MCP)</p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.CapabilityAffinityMatrix--get-optimal-protocol-for-a-capability","title":"Get optimal protocol for a capability","text":"<p>best_protocol = matrix.get_optimal_protocol(\"task_delegation\")</p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.CapabilityAffinityMatrix--score-protocol-for-multiple-capabilities","title":"Score protocol for multiple capabilities","text":"<p>score = matrix.score_protocol_for_capabilities(     [\"code_execution\", \"resource_access\"],     ProtocolName.MCP )</p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.CapabilityAffinityMatrix.__init__","title":"<code>__init__(affinity_data=None, config=None)</code>","text":"<p>Initialize affinity matrix.</p> PARAMETER DESCRIPTION <code>affinity_data</code> <p>Optional custom affinity data.           Uses CAPABILITY_PROTOCOL_AFFINITY by default.</p> <p> TYPE: <code>dict[tuple[str, ProtocolName], float] | None</code> DEFAULT: <code>None</code> </p> <code>config</code> <p>Configuration for affinity calculations.</p> <p> TYPE: <code>AffinityConfig | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.CapabilityAffinityMatrix.get_affinity","title":"<code>get_affinity(capability, protocol)</code>","text":"<p>Get affinity score for a capability-protocol pair.</p> PARAMETER DESCRIPTION <code>capability</code> <p>Capability name</p> <p> TYPE: <code>str</code> </p> <code>protocol</code> <p>Protocol name</p> <p> TYPE: <code>ProtocolName</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Affinity score (0.0 to 1.0)</p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.CapabilityAffinityMatrix.get_optimal_protocol","title":"<code>get_optimal_protocol(capability)</code>","text":"<p>Get the optimal protocol for a capability.</p> PARAMETER DESCRIPTION <code>capability</code> <p>Capability to optimize for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ProtocolName</code> <p>Protocol with highest affinity for this capability</p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.CapabilityAffinityMatrix.score_protocol_for_capabilities","title":"<code>score_protocol_for_capabilities(capabilities, protocol, weights=None)</code>","text":"<p>Calculate aggregate affinity score for multiple capabilities.</p> PARAMETER DESCRIPTION <code>capabilities</code> <p>List of capabilities</p> <p> TYPE: <code>list[str]</code> </p> <code>protocol</code> <p>Protocol to score</p> <p> TYPE: <code>ProtocolName</code> </p> <code>weights</code> <p>Optional weights for each capability</p> <p> TYPE: <code>dict[str, float] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Aggregate affinity score (0.0 to 1.0)</p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.CapabilityAffinityMatrix.get_best_protocol_for_capabilities","title":"<code>get_best_protocol_for_capabilities(capabilities, weights=None, exclude_protocols=None)</code>","text":"<p>Find the best protocol for a set of capabilities.</p> PARAMETER DESCRIPTION <code>capabilities</code> <p>List of capabilities</p> <p> TYPE: <code>list[str]</code> </p> <code>weights</code> <p>Optional weights for each capability</p> <p> TYPE: <code>dict[str, float] | None</code> DEFAULT: <code>None</code> </p> <code>exclude_protocols</code> <p>Protocols to exclude from consideration</p> <p> TYPE: <code>set[ProtocolName] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>tuple[ProtocolName, float]</code> <p>Tuple of (best protocol, aggregate score)</p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.CapabilityAffinityMatrix.rank_protocols_for_capabilities","title":"<code>rank_protocols_for_capabilities(capabilities, weights=None)</code>","text":"<p>Rank all protocols for a set of capabilities.</p> PARAMETER DESCRIPTION <code>capabilities</code> <p>List of capabilities</p> <p> TYPE: <code>list[str]</code> </p> <code>weights</code> <p>Optional weights for each capability</p> <p> TYPE: <code>dict[str, float] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[tuple[ProtocolName, float]]</code> <p>List of (protocol, score) tuples, sorted by score descending</p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.CapabilityAffinityMatrix.get_capability_coverage","title":"<code>get_capability_coverage(protocol, threshold=0.7)</code>","text":"<p>Get capabilities well-supported by a protocol.</p> PARAMETER DESCRIPTION <code>protocol</code> <p>Protocol to analyze</p> <p> TYPE: <code>ProtocolName</code> </p> <code>threshold</code> <p>Minimum affinity threshold</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.7</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>List of capabilities with affinity &gt;= threshold</p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.CapabilityAffinityMatrix.register_affinity","title":"<code>register_affinity(capability, protocol, affinity)</code>","text":"<p>Register or update an affinity value.</p> PARAMETER DESCRIPTION <code>capability</code> <p>Capability name</p> <p> TYPE: <code>str</code> </p> <code>protocol</code> <p>Protocol name</p> <p> TYPE: <code>ProtocolName</code> </p> <code>affinity</code> <p>Affinity value (0.0 to 1.0)</p> <p> TYPE: <code>float</code> </p>"},{"location":"api/protocols/affinity/#agenticraft_foundation.protocols.affinity.CapabilityAffinityMatrix.get_statistics","title":"<code>get_statistics()</code>","text":"<p>Get matrix statistics.</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Dictionary of statistics</p>"},{"location":"api/protocols/compatibility/","title":"agenticraft_foundation.protocols.compatibility","text":"<p>Protocol compatibility matrix \u2014 translation costs between protocol pairs.</p> <p>Protocol compatibility relation.</p> <p>Defines full, partial, or incompatible translation between protocols based on Definition 6 (Protocol Compatibility Relation) from the formal model.</p> <p>Compatibility levels: - FULL: No semantic loss during translation. - PARTIAL: Some semantic loss possible. - NONE: No translation possible.</p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.CompatibilityLevel","title":"<code>CompatibilityLevel</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Protocol compatibility levels.</p> <p>Represents the degree of semantic preservation when translating between protocols.</p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.CompatibilityLevel.FULL","title":"<code>FULL = 'full'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>\u2713 No semantic loss - complete bidirectional translation</p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.CompatibilityLevel.PARTIAL","title":"<code>PARTIAL = 'partial'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>\u26a1 Some semantic loss possible - requires validation</p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.CompatibilityLevel.NONE","title":"<code>NONE = 'none'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>\u2717 No translation possible - incompatible protocols</p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.CompatibilityRelation","title":"<code>CompatibilityRelation</code>  <code>dataclass</code>","text":"<p>Protocol compatibility relation p\u2081 \u223c_p p\u2082.</p> <p>Based on Definition 6 (Protocol Compatibility Relation) from the formal model. For protocols p\u2081, p\u2082 \u2208 P, p\u2081 \u223cp p\u2082 \u27fa \u2203 bidirectional translator T</p> ATTRIBUTE DESCRIPTION <code>source</code> <p>Source protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>target</code> <p>Target protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>level</code> <p>Compatibility level (FULL, PARTIAL, NONE)</p> <p> TYPE: <code>CompatibilityLevel</code> </p> <code>semantic_loss</code> <p>Estimated semantic loss (0.0 = no loss, 1.0 = total loss)</p> <p> TYPE: <code>float</code> </p> <code>reversible</code> <p>Whether T\u207b\u00b9(T(m)) \u2248 m holds</p> <p> TYPE: <code>bool</code> </p> <code>latency_factor</code> <p>Relative latency multiplier for translation</p> <p> TYPE: <code>float</code> </p> <code>conditions</code> <p>Conditions under which translation works</p> <p> TYPE: <code>list[str]</code> </p> <code>feature_mapping</code> <p>Mapping of features between protocols</p> <p> TYPE: <code>dict[str, str]</code> </p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.CompatibilityRelation.is_full","title":"<code>is_full</code>  <code>property</code>","text":"<p>Check if this is full compatibility.</p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.CompatibilityRelation.is_partial","title":"<code>is_partial</code>  <code>property</code>","text":"<p>Check if this is partial compatibility.</p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.CompatibilityRelation.is_compatible","title":"<code>is_compatible</code>  <code>property</code>","text":"<p>Check if translation is possible (FULL or PARTIAL).</p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.CompatibilityRelation.get_translation_cost","title":"<code>get_translation_cost()</code>","text":"<p>Calculate translation cost based on semantic loss and latency.</p> RETURNS DESCRIPTION <code>float</code> <p>Combined cost factor for routing decisions</p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.ProtocolCompatibilityMatrix","title":"<code>ProtocolCompatibilityMatrix</code>","text":"<p>Lookup and query protocol compatibility.</p> <p>Provides efficient access to the protocol compatibility matrix for routing and translation decisions.</p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.ProtocolCompatibilityMatrix.__init__","title":"<code>__init__(compatibility_data=None)</code>","text":"<p>Initialize compatibility matrix.</p> PARAMETER DESCRIPTION <code>compatibility_data</code> <p>Optional custom compatibility data.                Uses PROTOCOL_COMPATIBILITY by default.</p> <p> TYPE: <code>dict[tuple[ProtocolName, ProtocolName], CompatibilityRelation] | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.ProtocolCompatibilityMatrix.get_compatibility","title":"<code>get_compatibility(source, target)</code>","text":"<p>Get compatibility relation between two protocols.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>target</code> <p>Target protocol</p> <p> TYPE: <code>ProtocolName</code> </p> RETURNS DESCRIPTION <code>CompatibilityRelation</code> <p>CompatibilityRelation describing the translation</p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.ProtocolCompatibilityMatrix.can_translate","title":"<code>can_translate(source, target)</code>","text":"<p>Check if translation is possible between protocols.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>target</code> <p>Target protocol</p> <p> TYPE: <code>ProtocolName</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if translation is possible (FULL or PARTIAL)</p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.ProtocolCompatibilityMatrix.get_translation_cost","title":"<code>get_translation_cost(source, target)</code>","text":"<p>Get the cost of translating between protocols.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>target</code> <p>Target protocol</p> <p> TYPE: <code>ProtocolName</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Translation cost (infinity if not possible)</p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.ProtocolCompatibilityMatrix.get_semantic_loss","title":"<code>get_semantic_loss(source, target)</code>","text":"<p>Get the expected semantic loss for a translation.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>target</code> <p>Target protocol</p> <p> TYPE: <code>ProtocolName</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Semantic loss (0.0 to 1.0, 1.0 if not possible)</p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.ProtocolCompatibilityMatrix.get_all_compatible","title":"<code>get_all_compatible(source, level=None)</code>","text":"<p>Get all protocols compatible with a source protocol.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>level</code> <p>Optional level filter (FULL or PARTIAL)</p> <p> TYPE: <code>CompatibilityLevel | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[ProtocolName]</code> <p>List of compatible protocols</p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.ProtocolCompatibilityMatrix.get_best_translation_path","title":"<code>get_best_translation_path(source, target, max_hops=2)</code>","text":"<p>Find the best translation path (lowest semantic loss).</p> <p>Uses breadth-first search with cost optimization.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>target</code> <p>Target protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>max_hops</code> <p>Maximum number of intermediate translations</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> RETURNS DESCRIPTION <code>list[ProtocolName] | None</code> <p>List of protocols in the path, or None if no path exists</p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.ProtocolCompatibilityMatrix.register_compatibility","title":"<code>register_compatibility(relation)</code>","text":"<p>Register a new compatibility relation.</p> PARAMETER DESCRIPTION <code>relation</code> <p>Compatibility relation to register</p> <p> TYPE: <code>CompatibilityRelation</code> </p>"},{"location":"api/protocols/compatibility/#agenticraft_foundation.protocols.compatibility.ProtocolCompatibilityMatrix.get_statistics","title":"<code>get_statistics()</code>","text":"<p>Get matrix statistics.</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Dictionary of statistics</p>"},{"location":"api/protocols/cost/","title":"agenticraft_foundation.protocols.cost","text":"<p>Path cost function \\(\\text{cost}(\\pi, \\sigma) = \\sum w_{e_i}(p_i) + \\sum \\tau(p_i, p_{i+1}, v_i)\\) with configurable edge cost models for routing optimization.</p> <p>Path cost function: cost(\u03c0, \u03c3).</p> <p>Computes cost(\u03c0, \u03c3) = \u03a3 w\u2091(p) + \u03a3 \u03c4(p\u1d62, p\u1d62\u208a\u2081, v\u1d62) where \u03c0 is the path, \u03c3 is the protocol sequence, w\u2091(p) is the edge weight for protocol p, and \u03c4 is the translation cost at each node.</p> <p>Based on Definition 12 (Path Cost Function) from the formal multi-protocol mesh model.</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.TranslationCost","title":"<code>TranslationCost</code>  <code>dataclass</code>","text":"<p>Cost of translating between protocols at a node.</p> <p>Represents \u03c4(p\u1d62\u2099, p\u2092\u1d64\u209c, v) \u2014 the cost incurred when translating from p\u1d62\u2099 to p\u2092\u1d64\u209c at node v.</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.TranslationCost.source_protocol","title":"<code>source_protocol</code>  <code>instance-attribute</code>","text":"<p>Incoming protocol (p\u1d62\u2099)</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.TranslationCost.target_protocol","title":"<code>target_protocol</code>  <code>instance-attribute</code>","text":"<p>Outgoing protocol (p\u2092\u1d64\u209c)</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.TranslationCost.base_cost","title":"<code>base_cost = 0.1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>\u03c4_base \u2014 base translation overhead</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.TranslationCost.semantic_loss_penalty","title":"<code>semantic_loss_penalty = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>\u03c4_semantic \u2014 penalty for semantic loss during translation</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.TranslationCost.latency_ms","title":"<code>latency_ms = 10.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Expected latency in milliseconds for this translation</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.TranslationCost.node_id","title":"<code>node_id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Node where translation occurs (v)</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.TranslationCost.total_cost","title":"<code>total_cost</code>  <code>property</code>","text":"<p>Total translation cost.</p> <p>\u03c4(p\u1d62\u2099, p\u2092\u1d64\u209c, v) = \u03c4_base + \u03c4_semantic</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.TranslationCost.is_identity","title":"<code>is_identity</code>  <code>property</code>","text":"<p>Check if this is an identity translation (same protocol).</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCost","title":"<code>PathCost</code>  <code>dataclass</code>","text":"<p>Complete cost breakdown for a protocol-aware path.</p> <p>Represents cost(\u03c0, \u03c3) = \u03a3 w\u2091(p) + \u03a3 \u03c4(p\u1d62, p\u1d62\u208a\u2081, v\u1d62) with detailed breakdown.</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCost.edge_costs","title":"<code>edge_costs = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>w\u2091(p) for each edge in the path</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCost.translation_costs","title":"<code>translation_costs = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>\u03c4(p\u1d62, p\u1d62\u208a\u2081, v\u1d62) for each translation point</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCost.path","title":"<code>path = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Agent IDs in the path</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCost.protocol_sequence","title":"<code>protocol_sequence = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Protocols used on each edge</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCost.total_edge_cost","title":"<code>total_edge_cost</code>  <code>property</code>","text":"<p>Sum of all edge costs: \u03a3 w\u2091(p)</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCost.total_translation_cost","title":"<code>total_translation_cost</code>  <code>property</code>","text":"<p>Sum of all translation costs: \u03a3 \u03c4(p\u1d62, p\u1d62\u208a\u2081, v\u1d62)</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCost.total_cost","title":"<code>total_cost</code>  <code>property</code>","text":"<p>Total path cost.</p> <p>cost(\u03c0, \u03c3) = \u03a3 w\u2091(p) + \u03a3 \u03c4(p\u1d62, p\u1d62\u208a\u2081, v\u1d62)</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCost.total_latency_ms","title":"<code>total_latency_ms</code>  <code>property</code>","text":"<p>Estimated total latency in milliseconds.</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCost.num_translations","title":"<code>num_translations</code>  <code>property</code>","text":"<p>Number of protocol translations (excluding identity).</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCost.semantic_loss_estimate","title":"<code>semantic_loss_estimate</code>  <code>property</code>","text":"<p>Estimated semantic loss across all translations.</p> <p>Compounds multiplicatively: (1 - loss1) * (1 - loss2) * ...</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCost.get_summary","title":"<code>get_summary()</code>","text":"<p>Get cost summary dictionary.</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.CostConfig","title":"<code>CostConfig</code>  <code>dataclass</code>","text":"<p>Configuration for path cost calculation.</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.CostConfig.default_edge_weight","title":"<code>default_edge_weight = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default weight for edges without explicit weights</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.CostConfig.default_translation_base_cost","title":"<code>default_translation_base_cost = 0.1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default base cost for protocol translations</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.CostConfig.semantic_loss_multiplier","title":"<code>semantic_loss_multiplier = 2.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Multiplier for semantic loss in cost calculation</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.CostConfig.latency_weight","title":"<code>latency_weight = 0.01</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Weight for latency in cost calculation (cost per ms)</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.CostConfig.identity_translation_cost","title":"<code>identity_translation_cost = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Cost for identity translations (same protocol)</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCostCalculator","title":"<code>PathCostCalculator</code>","text":"<p>Calculate path cost for protocol-aware routing.</p> <p>Implements Definition 12 (Path Cost Function) from the formal model::</p> <pre><code>cost(\u03c0, \u03c3) = \u03a3 w\u2091\u1d62(p\u1d62) + \u03a3 \u03c4(p\u1d62, p\u1d62\u208a\u2081, v\u1d62)\n</code></pre> <p>Where:</p> <ul> <li>\u03c0 is the path (sequence of agents)</li> <li>\u03c3 is the protocol sequence</li> <li>w\u2091\u1d62(p\u1d62) is the weight of edge i using protocol p\u1d62</li> <li>\u03c4(p\u1d62, p\u1d62\u208a\u2081, v\u1d62) is the translation cost at intermediate nodes</li> </ul> Usage <p>calculator = PathCostCalculator(graph, compatibility_matrix)</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCostCalculator--calculate-cost-for-a-path","title":"Calculate cost for a path","text":"<p>cost = calculator.calculate_path_cost(     path=[\"agent1\", \"agent2\", \"agent3\"],     protocol_sequence=[ProtocolName.MCP, ProtocolName.A2A] )</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCostCalculator--get-detailed-cost-breakdown","title":"Get detailed cost breakdown","text":"<p>path_cost = calculator.get_path_cost_breakdown(path, protocol_sequence) print(f\"Total: {path_cost.total_cost}\") print(f\"Translations: {path_cost.num_translations}\")</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCostCalculator.__init__","title":"<code>__init__(graph, compatibility_matrix, config=None)</code>","text":"<p>Initialize path cost calculator.</p> PARAMETER DESCRIPTION <code>graph</code> <p>Protocol graph with agents and edges</p> <p> TYPE: <code>ProtocolGraph</code> </p> <code>compatibility_matrix</code> <p>Protocol compatibility information</p> <p> TYPE: <code>ProtocolCompatibilityMatrix</code> </p> <code>config</code> <p>Cost calculation configuration</p> <p> TYPE: <code>CostConfig | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCostCalculator.calculate_path_cost","title":"<code>calculate_path_cost(path, protocol_sequence)</code>","text":"<p>Calculate total cost for a protocol-aware path.</p> PARAMETER DESCRIPTION <code>path</code> <p>Sequence of agent IDs</p> <p> TYPE: <code>list[str]</code> </p> <code>protocol_sequence</code> <p>Protocol to use on each edge</p> <p> TYPE: <code>list[ProtocolName]</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Total path cost (infinity if path is invalid)</p> RAISES DESCRIPTION <code>ValueError</code> <p>If path and protocol_sequence lengths don't match</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCostCalculator.get_path_cost_breakdown","title":"<code>get_path_cost_breakdown(path, protocol_sequence)</code>","text":"<p>Get detailed cost breakdown for a path.</p> PARAMETER DESCRIPTION <code>path</code> <p>Sequence of agent IDs</p> <p> TYPE: <code>list[str]</code> </p> <code>protocol_sequence</code> <p>Protocol to use on each edge</p> <p> TYPE: <code>list[ProtocolName]</code> </p> RETURNS DESCRIPTION <code>PathCost</code> <p>PathCost with detailed breakdown</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCostCalculator.get_translation_cost","title":"<code>get_translation_cost(source_protocol, target_protocol, at_node=None)</code>","text":"<p>Get cost of translating between protocols at a node.</p> PARAMETER DESCRIPTION <code>source_protocol</code> <p>Incoming protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>target_protocol</code> <p>Outgoing protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>at_node</code> <p>Node where translation occurs</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>TranslationCost</code> <p>TranslationCost for this translation</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCostCalculator.estimate_minimum_cost","title":"<code>estimate_minimum_cost(source, target, source_protocol, target_protocol=None)</code>","text":"<p>Estimate minimum possible cost between two agents.</p> <p>Useful for A* heuristic or early termination.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source agent ID</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>Target agent ID</p> <p> TYPE: <code>str</code> </p> <code>source_protocol</code> <p>Starting protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>target_protocol</code> <p>Required ending protocol (optional)</p> <p> TYPE: <code>ProtocolName | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Lower bound on path cost</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCostCalculator.compare_paths","title":"<code>compare_paths(path1, path2)</code>","text":"<p>Compare two paths by cost.</p> PARAMETER DESCRIPTION <code>path1</code> <p>First (path, protocol_sequence) tuple</p> <p> TYPE: <code>tuple[list[str], list[ProtocolName]]</code> </p> <code>path2</code> <p>Second (path, protocol_sequence) tuple</p> <p> TYPE: <code>tuple[list[str], list[ProtocolName]]</code> </p> RETURNS DESCRIPTION <code>int</code> <p>-1 if path1 cheaper, 1 if path2 cheaper, 0 if equal</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCostCalculator.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear the translation cost cache.</p>"},{"location":"api/protocols/cost/#agenticraft_foundation.protocols.cost.PathCostCalculator.get_statistics","title":"<code>get_statistics()</code>","text":"<p>Get calculator statistics.</p>"},{"location":"api/protocols/graph/","title":"agenticraft_foundation.protocols.graph","text":"<p>Protocol graph representation \u2014 agent nodes, protocol edges, and the formal model \\(G = (V, E, P, \\Phi, \\Gamma)\\).</p> <p>Protocol graph model: G = (V, E, P, \u03a6, \u0393).</p> <p>Formal graph-theoretic representation of multi-protocol mesh topology.</p> <p>The graph represents: - V: Set of agents (vertices). - E: Set of edges between agents. - P: Protocol set {MCP, A2A, CUSTOM, ...}. - \u03a6: E \u2192 2\u1d3e (protocols supported on each edge). - \u0393: Capability-protocol affinity function.</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.NodeType","title":"<code>NodeType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Type of node in the protocol graph.</p> <p>Extended taxonomy from graph-theoretic foundations: - AGENT: Generic agent (backward-compatible default) - LLM_AGENT: LLM-powered agent with inference capabilities - TOOL_SERVER: Tool/resource server (MCP servers, API endpoints) - COORDINATOR: Orchestrator/coordinator agent managing workflows - GATEWAY: Protocol gateway/bridge between protocol domains - ROUTER: Routing node for message forwarding - TRANSLATOR: Protocol translator for message conversion</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.AgentNode","title":"<code>AgentNode</code>  <code>dataclass</code>","text":"<p>Agent node in the protocol graph.</p> <p>Represents an agent with its capabilities and supported protocols.</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.AgentNode.agent_id","title":"<code>agent_id</code>  <code>instance-attribute</code>","text":"<p>Unique agent identifier</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.AgentNode.capabilities","title":"<code>capabilities = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Agent capabilities (e.g., ['code_execution', 'web_search'])</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.AgentNode.protocols","title":"<code>protocols = field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Protocols this agent supports</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.AgentNode.node_type","title":"<code>node_type = NodeType.AGENT</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Type of node</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.AgentNode.metadata","title":"<code>metadata = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Additional node metadata</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.AgentNode.avg_latency_ms","title":"<code>avg_latency_ms = 50.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Average response latency in milliseconds</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.AgentNode.reliability","title":"<code>reliability = 0.99</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Node reliability score (0.0 to 1.0)</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.AgentNode.supports_protocol","title":"<code>supports_protocol(protocol)</code>","text":"<p>Check if agent supports a specific protocol.</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolEdge","title":"<code>ProtocolEdge</code>  <code>dataclass</code>","text":"<p>Edge with protocol capabilities: \u03a6(u, v).</p> <p>Represents a connection between two agents with per-protocol weights.</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolEdge.source","title":"<code>source</code>  <code>instance-attribute</code>","text":"<p>Source agent ID</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolEdge.target","title":"<code>target</code>  <code>instance-attribute</code>","text":"<p>Target agent ID</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolEdge.protocols","title":"<code>protocols</code>  <code>instance-attribute</code>","text":"<p>\u03a6(u,v) \u2014 protocols supported on this edge</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolEdge.weights","title":"<code>weights = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>w\u2091(p) \u2014 per-protocol edge weights (cost/latency)</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolEdge.metadata","title":"<code>metadata = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Additional edge metadata</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolEdge.bandwidth_mbps","title":"<code>bandwidth_mbps = 100.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Estimated bandwidth in Mbps</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolEdge.reliability","title":"<code>reliability = 0.99</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Edge reliability score (0.0 to 1.0)</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolEdge.get_weight","title":"<code>get_weight(protocol)</code>","text":"<p>Get edge weight for a specific protocol.</p> <p>Returns infinity if protocol not supported on this edge.</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolEdge.supports_protocol","title":"<code>supports_protocol(protocol)</code>","text":"<p>Check if edge supports a specific protocol.</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolEdge.diversity_index","title":"<code>diversity_index(total_protocols)</code>","text":"<p>Protocol Diversity Index: PDI(e) = |P\u2091| / |P|.</p> <p>Measures what fraction of the total protocol set is supported on this edge. Higher values indicate more versatile connections.</p> PARAMETER DESCRIPTION <code>total_protocols</code> <p>Total number of protocols in the mesh |P|</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>float</code> <p>PDI in [0.0, 1.0]</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph","title":"<code>ProtocolGraph</code>  <code>dataclass</code>","text":"<p>Multi-protocol mesh graph G = (V, E, P, \u03a6, \u0393).</p> <p>V: Set of agents (vertices) E: Set of edges between agents P: Protocol set {MCP, A2A, CUSTOM, ...} \u03a6: E \u2192 2\u1d3e (protocols supported on each edge) \u0393: Capability-protocol affinity function</p> <p>This graph enables: - Protocol-aware path finding (Dijkstra with protocol constraints) - Optimal protocol selection based on capability affinity - Semantic-preserving route discovery</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.agents","title":"<code>agents = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>V: Set of agent nodes</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.edges","title":"<code>edges = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>E: Set of protocol edges</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.protocols","title":"<code>protocols = field(default_factory=(lambda: {ProtocolName.MCP, ProtocolName.A2A, ProtocolName.CUSTOM}))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>P: Supported protocol set</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.add_agent","title":"<code>add_agent(agent_id, capabilities=None, protocols=None, node_type=NodeType.AGENT, metadata=None, avg_latency_ms=50.0, reliability=0.99)</code>","text":"<p>Add an agent node to the graph.</p> PARAMETER DESCRIPTION <code>agent_id</code> <p>Unique agent identifier</p> <p> TYPE: <code>str</code> </p> <code>capabilities</code> <p>Agent capabilities</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>protocols</code> <p>Supported protocols</p> <p> TYPE: <code>set[ProtocolName] | None</code> DEFAULT: <code>None</code> </p> <code>node_type</code> <p>Type of node</p> <p> TYPE: <code>NodeType</code> DEFAULT: <code>AGENT</code> </p> <code>metadata</code> <p>Additional metadata</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>avg_latency_ms</code> <p>Average latency</p> <p> TYPE: <code>float</code> DEFAULT: <code>50.0</code> </p> <code>reliability</code> <p>Node reliability</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.99</code> </p> RETURNS DESCRIPTION <code>AgentNode</code> <p>The created or updated AgentNode</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.remove_agent","title":"<code>remove_agent(agent_id)</code>","text":"<p>Remove an agent node and all connected edges.</p> PARAMETER DESCRIPTION <code>agent_id</code> <p>Agent to remove</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if removed, False if not found</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.add_edge","title":"<code>add_edge(source, target, protocols, weights=None, metadata=None, bidirectional=True)</code>","text":"<p>Add a protocol edge between two agents.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source agent ID</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>Target agent ID</p> <p> TYPE: <code>str</code> </p> <code>protocols</code> <p>Protocols supported on this edge</p> <p> TYPE: <code>set[ProtocolName]</code> </p> <code>weights</code> <p>Per-protocol edge weights</p> <p> TYPE: <code>dict[ProtocolName, float] | None</code> DEFAULT: <code>None</code> </p> <code>metadata</code> <p>Additional metadata</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>bidirectional</code> <p>If True, add reverse edge as well</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ProtocolEdge</code> <p>The created ProtocolEdge</p> RAISES DESCRIPTION <code>ValueError</code> <p>If source or target agent not in graph</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.remove_edge","title":"<code>remove_edge(source, target, bidirectional=True)</code>","text":"<p>Remove an edge between two agents.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source agent ID</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>Target agent ID</p> <p> TYPE: <code>str</code> </p> <code>bidirectional</code> <p>If True, remove reverse edge as well</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if removed, False if not found</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.get_edge","title":"<code>get_edge(source, target)</code>","text":"<p>Get edge between two agents.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source agent ID</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>Target agent ID</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ProtocolEdge | None</code> <p>ProtocolEdge or None if not found</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.get_neighbors","title":"<code>get_neighbors(agent_id, protocol=None)</code>","text":"<p>Get neighbors of an agent, optionally filtered by protocol.</p> PARAMETER DESCRIPTION <code>agent_id</code> <p>Agent to get neighbors for</p> <p> TYPE: <code>str</code> </p> <code>protocol</code> <p>Optional protocol filter</p> <p> TYPE: <code>ProtocolName | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>List of neighbor agent IDs</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.get_edges_from","title":"<code>get_edges_from(agent_id, protocol=None)</code>","text":"<p>Get all outgoing edges from an agent.</p> PARAMETER DESCRIPTION <code>agent_id</code> <p>Source agent ID</p> <p> TYPE: <code>str</code> </p> <code>protocol</code> <p>Optional protocol filter</p> <p> TYPE: <code>ProtocolName | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[ProtocolEdge]</code> <p>List of outgoing ProtocolEdges</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.is_protocol_valid_path","title":"<code>is_protocol_valid_path(path, protocol_sequence)</code>","text":"<p>Check if a path is valid for a given protocol sequence.</p> <p>Validates: \u2200 (u,v) \u2208 \u03c0: p_i \u2208 \u03a6(u,v)</p> PARAMETER DESCRIPTION <code>path</code> <p>Sequence of agent IDs</p> <p> TYPE: <code>list[str]</code> </p> <code>protocol_sequence</code> <p>Protocol to use on each edge</p> <p> TYPE: <code>list[ProtocolName]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if path is valid</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.get_agents_by_capability","title":"<code>get_agents_by_capability(capability, protocol=None)</code>","text":"<p>Find agents with a specific capability.</p> PARAMETER DESCRIPTION <code>capability</code> <p>Capability to search for</p> <p> TYPE: <code>str</code> </p> <code>protocol</code> <p>Optional protocol filter</p> <p> TYPE: <code>ProtocolName | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[AgentNode]</code> <p>List of matching AgentNodes</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.get_agents_by_protocol","title":"<code>get_agents_by_protocol(protocol)</code>","text":"<p>Find agents that support a specific protocol.</p> PARAMETER DESCRIPTION <code>protocol</code> <p>Protocol to filter by</p> <p> TYPE: <code>ProtocolName</code> </p> RETURNS DESCRIPTION <code>list[AgentNode]</code> <p>List of matching AgentNodes</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.get_statistics","title":"<code>get_statistics()</code>","text":"<p>Get graph statistics.</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Dictionary of statistics</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.protocol_diversity","title":"<code>protocol_diversity()</code>","text":"<p>Compute Protocol Diversity Index for all edges.</p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary mapping edge key \"source-&gt;target\" to PDI value.</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.is_reachable","title":"<code>is_reachable(source, target, allowed_protocols=None)</code>","text":"<p>Check reachability from source to target using allowed protocols.</p> <p>Implements Theorem 3 from the formal model: protocol-constrained reachability in O(|V| + |E|) via BFS on the protocol subgraph.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source agent ID</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>Target agent ID</p> <p> TYPE: <code>str</code> </p> <code>allowed_protocols</code> <p>If provided, only traverse edges that support at least one of these protocols. If None, all edges are used.</p> <p> TYPE: <code>set[ProtocolName] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if target is reachable from source</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.reachable_agents","title":"<code>reachable_agents(source, allowed_protocols=None)</code>","text":"<p>Find all agents reachable from source using allowed protocols.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source agent ID</p> <p> TYPE: <code>str</code> </p> <code>allowed_protocols</code> <p>If provided, only traverse edges that support at least one of these protocols. If None, all edges are used.</p> <p> TYPE: <code>set[ProtocolName] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>set[str]</code> <p>Set of reachable agent IDs (excluding source)</p>"},{"location":"api/protocols/graph/#agenticraft_foundation.protocols.graph.ProtocolGraph.clear","title":"<code>clear()</code>","text":"<p>Clear all agents and edges.</p>"},{"location":"api/protocols/routing/","title":"agenticraft_foundation.protocols.routing","text":"<p>Protocol-aware routing algorithms \u2014 Dijkstra (minimum-cost), BFS (minimum-hop), and resilient routing with failover.</p> <p>Protocol-aware Dijkstra routing (Algorithm 1).</p> <p>Finds optimal path considering protocol translation costs. State space: (agent, incoming_protocol).</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.RoutingState","title":"<code>RoutingState</code>  <code>dataclass</code>","text":"<p>State for protocol-aware routing.</p> <p>State space: (agent_id, incoming_protocol) Each state represents being at an agent with a specific incoming protocol.</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.RoutingState.agent_id","title":"<code>agent_id</code>  <code>instance-attribute</code>","text":"<p>Current agent ID</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.RoutingState.protocol","title":"<code>protocol</code>  <code>instance-attribute</code>","text":"<p>Incoming protocol at this agent</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.RoutingState.__lt__","title":"<code>__lt__(other)</code>","text":"<p>For heap comparison - compare by agent_id then protocol.</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.OptimalRoute","title":"<code>OptimalRoute</code>  <code>dataclass</code>","text":"<p>Result of protocol-aware routing.</p> <p>Contains the optimal path with protocol sequence and cost breakdown.</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.OptimalRoute.path","title":"<code>path</code>  <code>instance-attribute</code>","text":"<p>Sequence of agent IDs from source to target</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.OptimalRoute.protocol_sequence","title":"<code>protocol_sequence</code>  <code>instance-attribute</code>","text":"<p>Protocol to use on each edge (len = len(path) - 1)</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.OptimalRoute.total_cost","title":"<code>total_cost</code>  <code>instance-attribute</code>","text":"<p>Total path cost: \u03a3 w_e(p) + \u03a3 \u03c4(p_i, p_{i+1}, v_i)</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.OptimalRoute.translation_points","title":"<code>translation_points</code>  <code>instance-attribute</code>","text":"<p>List of (node_id, from_protocol, to_protocol) where translations occur</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.OptimalRoute.semantic_loss_estimate","title":"<code>semantic_loss_estimate</code>  <code>instance-attribute</code>","text":"<p>Estimated semantic loss across all translations (0.0 to 1.0)</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.OptimalRoute.edge_costs","title":"<code>edge_costs = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Individual edge costs</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.OptimalRoute.translation_costs","title":"<code>translation_costs = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Individual translation costs</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.OptimalRoute.num_hops","title":"<code>num_hops = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of hops (edges) in the path</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.OptimalRoute.num_translations","title":"<code>num_translations</code>  <code>property</code>","text":"<p>Number of protocol translations (changes).</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.OptimalRoute.is_single_protocol","title":"<code>is_single_protocol</code>  <code>property</code>","text":"<p>Check if route uses only one protocol (no translations).</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.OptimalRoute.get_summary","title":"<code>get_summary()</code>","text":"<p>Get route summary.</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.RoutingConfig","title":"<code>RoutingConfig</code>  <code>dataclass</code>","text":"<p>Configuration for Protocol-Aware Dijkstra.</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.RoutingConfig.max_hops","title":"<code>max_hops = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum number of hops allowed</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.RoutingConfig.max_translations","title":"<code>max_translations = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum number of protocol translations allowed</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.RoutingConfig.max_semantic_loss","title":"<code>max_semantic_loss = 0.3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum allowed semantic loss (0.0 to 1.0)</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.RoutingConfig.prefer_single_protocol","title":"<code>prefer_single_protocol = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Prefer routes that don't require protocol translation</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.RoutingConfig.single_protocol_bonus","title":"<code>single_protocol_bonus = 0.1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Cost reduction for single-protocol routes</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.ProtocolAwareDijkstra","title":"<code>ProtocolAwareDijkstra</code>","text":"<p>Protocol-Aware Dijkstra Algorithm (Algorithm 1 from formal model).</p> <p>State space: (agent, incoming_protocol) Transition: Consider all outgoing edges and protocol translations Cost: edge_weight + translation_cost</p> <p>This algorithm finds the optimal route through a multi-protocol mesh, considering both edge weights and protocol translation costs.</p> Usage <p>dijkstra = ProtocolAwareDijkstra(graph, compatibility, cost_calculator)</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.ProtocolAwareDijkstra--find-optimal-route","title":"Find optimal route","text":"<p>route = dijkstra.find_optimal_route(     source=\"agent1\",     target=\"agent3\",     source_protocol=ProtocolName.MCP, )</p> <p>if route:     print(f\"Path: {route.path}\")     print(f\"Cost: {route.total_cost}\")     print(f\"Protocols: {route.protocol_sequence}\")</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.ProtocolAwareDijkstra.__init__","title":"<code>__init__(graph, compatibility_matrix, cost_calculator, config=None)</code>","text":"<p>Initialize Protocol-Aware Dijkstra.</p> PARAMETER DESCRIPTION <code>graph</code> <p>Protocol graph with agents and edges</p> <p> TYPE: <code>ProtocolGraph</code> </p> <code>compatibility_matrix</code> <p>Protocol compatibility information</p> <p> TYPE: <code>ProtocolCompatibilityMatrix</code> </p> <code>cost_calculator</code> <p>Path cost calculator</p> <p> TYPE: <code>PathCostCalculator</code> </p> <code>config</code> <p>Routing configuration</p> <p> TYPE: <code>RoutingConfig | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.ProtocolAwareDijkstra.find_optimal_route","title":"<code>find_optimal_route(source, target, source_protocol, target_protocol=None, max_hops=None)</code>","text":"<p>Find optimal protocol-aware route.</p> <p>Algorithm 1 from formal model: 1. Initialize dist[source, source_protocol] = 0 2. For each state (u, p_in) in priority queue:    a. For each neighbor v with edge (u,v):       b. For each protocol p_out \u2208 \u03a6(u,v):          - cost = dist[u, p_in] + w(u,v, p_out) + \u03c4(p_in, p_out, u)          - if cost &lt; dist[v, p_out]: update 3. Return optimal path to (target, target_protocol)</p> PARAMETER DESCRIPTION <code>source</code> <p>Source agent ID</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>Target agent ID</p> <p> TYPE: <code>str</code> </p> <code>source_protocol</code> <p>Protocol at source</p> <p> TYPE: <code>ProtocolName</code> </p> <code>target_protocol</code> <p>Required protocol at target (optional)</p> <p> TYPE: <code>ProtocolName | None</code> DEFAULT: <code>None</code> </p> <code>max_hops</code> <p>Maximum hops (overrides config)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OptimalRoute | None</code> <p>OptimalRoute if path exists, None otherwise</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.ProtocolAwareDijkstra.find_all_routes","title":"<code>find_all_routes(source, target, source_protocol, max_routes=5, max_cost_factor=1.5)</code>","text":"<p>Find multiple alternative routes.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source agent ID</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>Target agent ID</p> <p> TYPE: <code>str</code> </p> <code>source_protocol</code> <p>Protocol at source</p> <p> TYPE: <code>ProtocolName</code> </p> <code>max_routes</code> <p>Maximum number of routes to return</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> <code>max_cost_factor</code> <p>Max cost as factor of optimal (e.g., 1.5 = 50% worse)</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.5</code> </p> RETURNS DESCRIPTION <code>list[OptimalRoute]</code> <p>List of routes sorted by cost</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.ProtocolAwareDijkstra.get_statistics","title":"<code>get_statistics()</code>","text":"<p>Get routing statistics.</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.ProtocolAwareDijkstra.reset_statistics","title":"<code>reset_statistics()</code>","text":"<p>Reset routing statistics.</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.ProtocolConstrainedBFS","title":"<code>ProtocolConstrainedBFS</code>","text":"<p>Protocol-Constrained BFS (Algorithm 2 from formal model).</p> <p>Minimum-hop routing ignoring costs \u2014 returns shortest path by hop count with protocol compatibility checks. Uses BFS instead of priority queue.</p> <p>State space: (agent_id, incoming_protocol)</p> Usage <p>bfs = ProtocolConstrainedBFS(graph, compatibility_matrix, cost_calculator) route = bfs.find_shortest_path(\"agent1\", \"agent3\", ProtocolName.MCP)</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.ProtocolConstrainedBFS.__init__","title":"<code>__init__(graph, compatibility_matrix, cost_calculator, config=None)</code>","text":"<p>Initialize Protocol-Constrained BFS.</p> PARAMETER DESCRIPTION <code>graph</code> <p>Protocol graph with agents and edges</p> <p> TYPE: <code>ProtocolGraph</code> </p> <code>compatibility_matrix</code> <p>Protocol compatibility information</p> <p> TYPE: <code>ProtocolCompatibilityMatrix</code> </p> <code>cost_calculator</code> <p>Path cost calculator (for route cost annotation)</p> <p> TYPE: <code>PathCostCalculator</code> </p> <code>config</code> <p>Routing configuration</p> <p> TYPE: <code>RoutingConfig | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.ProtocolConstrainedBFS.find_shortest_path","title":"<code>find_shortest_path(source, target, source_protocol, target_protocol=None, max_hops=None)</code>","text":"<p>Find shortest path by hop count with protocol constraints.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source agent ID</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>Target agent ID</p> <p> TYPE: <code>str</code> </p> <code>source_protocol</code> <p>Protocol at source</p> <p> TYPE: <code>ProtocolName</code> </p> <code>target_protocol</code> <p>Required protocol at target (optional)</p> <p> TYPE: <code>ProtocolName | None</code> DEFAULT: <code>None</code> </p> <code>max_hops</code> <p>Maximum hops (overrides config)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OptimalRoute | None</code> <p>OptimalRoute with minimum hops, or None if unreachable</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.ResilientRouter","title":"<code>ResilientRouter</code>","text":"<p>Resilient Multi-Protocol Router (Algorithm 3 from formal model).</p> <p>Three failover strategies: 1. Same-edge protocol fallback \u2014 try alternative protocols on current edge 2. Alternate path \u2014 reroute using different protocol 3. Gateway insertion \u2014 route via gateway nodes</p> <p>Creates a residual graph excluding failed protocols/agents, then routes on the degraded topology.</p> Usage <p>router = ResilientRouter(graph, compatibility_matrix, cost_calculator) route = router.find_resilient_route(     \"agent1\", \"agent3\", ProtocolName.MCP,     failed_protocols={ProtocolName.A2A}, )</p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.ResilientRouter.__init__","title":"<code>__init__(graph, compatibility_matrix, cost_calculator, config=None)</code>","text":"<p>Initialize Resilient Router.</p> PARAMETER DESCRIPTION <code>graph</code> <p>Protocol graph</p> <p> TYPE: <code>ProtocolGraph</code> </p> <code>compatibility_matrix</code> <p>Protocol compatibility information</p> <p> TYPE: <code>ProtocolCompatibilityMatrix</code> </p> <code>cost_calculator</code> <p>Path cost calculator</p> <p> TYPE: <code>PathCostCalculator</code> </p> <code>config</code> <p>Routing configuration</p> <p> TYPE: <code>RoutingConfig | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/protocols/routing/#agenticraft_foundation.protocols.routing.ResilientRouter.find_resilient_route","title":"<code>find_resilient_route(source, target, source_protocol, failed_protocols=None, failed_agents=None, max_hops=None)</code>","text":"<p>Find route avoiding failed protocols and agents.</p> <p>Strategy order: 1. Try routing on the residual graph (excluding failures) 2. If direct routing fails, try via gateway nodes</p> PARAMETER DESCRIPTION <code>source</code> <p>Source agent ID</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>Target agent ID</p> <p> TYPE: <code>str</code> </p> <code>source_protocol</code> <p>Protocol at source</p> <p> TYPE: <code>ProtocolName</code> </p> <code>failed_protocols</code> <p>Protocols to avoid</p> <p> TYPE: <code>set[ProtocolName] | None</code> DEFAULT: <code>None</code> </p> <code>failed_agents</code> <p>Agents to avoid</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> <code>max_hops</code> <p>Maximum hops (overrides config)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OptimalRoute | None</code> <p>OptimalRoute on degraded topology, or None if unreachable</p>"},{"location":"api/protocols/semantic-routing/","title":"agenticraft_foundation.protocols.semantic_routing","text":"<p>Semantic routing using capability embeddings and protocol affinity scoring.</p> <p>Semantic Protocol-Aware Routing (Algorithm 4).</p> <p>Routes messages based on semantic similarity of capabilities, combined with protocol affinity and path cost.</p> <p>Score: similarity(cap_q, cap_a) \u00d7 affinity(p, cap_a) / (1 + cost(\u03c0))</p> <p>Zero external dependencies \u2014 uses pure Python bag-of-words with cosine similarity for capability embeddings.</p> <p>Falls back to ProtocolAwareDijkstra when embeddings are unavailable.</p>"},{"location":"api/protocols/semantic-routing/#agenticraft_foundation.protocols.semantic_routing.CapabilityEmbedding","title":"<code>CapabilityEmbedding</code>  <code>dataclass</code>","text":"<p>Vector representation of a capability for semantic matching.</p> <p>Uses bag-of-words (BoW) with optional TF-IDF weighting. Zero external dependencies.</p>"},{"location":"api/protocols/semantic-routing/#agenticraft_foundation.protocols.semantic_routing.CapabilityEmbedding.capability","title":"<code>capability</code>  <code>instance-attribute</code>","text":"<p>Original capability string</p>"},{"location":"api/protocols/semantic-routing/#agenticraft_foundation.protocols.semantic_routing.CapabilityEmbedding.vector","title":"<code>vector = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Sparse vector: token \u2192 weight</p>"},{"location":"api/protocols/semantic-routing/#agenticraft_foundation.protocols.semantic_routing.CapabilityEmbedding.from_text","title":"<code>from_text(capability)</code>  <code>classmethod</code>","text":"<p>Create embedding from capability text.</p> <p>Tokenizes on underscores, hyphens, spaces, and camelCase boundaries.</p>"},{"location":"api/protocols/semantic-routing/#agenticraft_foundation.protocols.semantic_routing.CapabilityEmbedding.similarity","title":"<code>similarity(other)</code>","text":"<p>Compute cosine similarity with another embedding.</p>"},{"location":"api/protocols/semantic-routing/#agenticraft_foundation.protocols.semantic_routing.SemanticRouteCandidate","title":"<code>SemanticRouteCandidate</code>  <code>dataclass</code>","text":"<p>A candidate agent for semantic routing.</p>"},{"location":"api/protocols/semantic-routing/#agenticraft_foundation.protocols.semantic_routing.SemanticRouteCandidate.agent_id","title":"<code>agent_id</code>  <code>instance-attribute</code>","text":"<p>Agent identifier</p>"},{"location":"api/protocols/semantic-routing/#agenticraft_foundation.protocols.semantic_routing.SemanticRouteCandidate.capability_similarity","title":"<code>capability_similarity</code>  <code>instance-attribute</code>","text":"<p>Semantic similarity of agent's capabilities to query</p>"},{"location":"api/protocols/semantic-routing/#agenticraft_foundation.protocols.semantic_routing.SemanticRouteCandidate.protocol_affinity","title":"<code>protocol_affinity</code>  <code>instance-attribute</code>","text":"<p>Protocol affinity score</p>"},{"location":"api/protocols/semantic-routing/#agenticraft_foundation.protocols.semantic_routing.SemanticRouteCandidate.path_cost","title":"<code>path_cost</code>  <code>instance-attribute</code>","text":"<p>Estimated path cost from source</p>"},{"location":"api/protocols/semantic-routing/#agenticraft_foundation.protocols.semantic_routing.SemanticRouteCandidate.composite_score","title":"<code>composite_score</code>  <code>instance-attribute</code>","text":"<p>Combined routing score</p>"},{"location":"api/protocols/semantic-routing/#agenticraft_foundation.protocols.semantic_routing.SemanticRouteCandidate.matched_capability","title":"<code>matched_capability</code>  <code>instance-attribute</code>","text":"<p>Best matching capability on this agent</p>"},{"location":"api/protocols/semantic-routing/#agenticraft_foundation.protocols.semantic_routing.SemanticRouter","title":"<code>SemanticRouter</code>","text":"<p>Semantic protocol-aware routing.</p> <p>Finds the best agent to handle a capability query by balancing: 1. Semantic similarity between requested and available capabilities 2. Protocol affinity for the agent's protocols 3. Path cost from source to agent</p> <p>Score = similarity \u00d7 affinity / (1 + cost)</p>"},{"location":"api/protocols/semantic-routing/#agenticraft_foundation.protocols.semantic_routing.SemanticRouter.__init__","title":"<code>__init__(graph, affinity_matrix=None, similarity_threshold=0.1)</code>","text":"<p>Initialize semantic router.</p> PARAMETER DESCRIPTION <code>graph</code> <p>Protocol graph</p> <p> TYPE: <code>ProtocolGraph</code> </p> <code>affinity_matrix</code> <p>Capability-protocol affinity matrix</p> <p> TYPE: <code>CapabilityAffinityMatrix | None</code> DEFAULT: <code>None</code> </p> <code>similarity_threshold</code> <p>Minimum similarity to consider a match</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p>"},{"location":"api/protocols/semantic-routing/#agenticraft_foundation.protocols.semantic_routing.SemanticRouter.find_best_agent","title":"<code>find_best_agent(query_capability, source, source_protocol, top_k=5)</code>","text":"<p>Find best agents for a capability query.</p> PARAMETER DESCRIPTION <code>query_capability</code> <p>Requested capability</p> <p> TYPE: <code>str</code> </p> <code>source</code> <p>Source agent ID</p> <p> TYPE: <code>str</code> </p> <code>source_protocol</code> <p>Source agent's protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>top_k</code> <p>Number of top candidates to return</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> RETURNS DESCRIPTION <code>list[SemanticRouteCandidate]</code> <p>Sorted list of SemanticRouteCandidate (best first)</p>"},{"location":"api/protocols/semantic/","title":"agenticraft_foundation.protocols.semantic","text":"<p>Semantic routing implementations for capability-based agent discovery.</p> <p>Semantic preservation verification.</p> <p>Verifies Definition 9 (Semantic Preservation): meaning(m) = meaning(T_{p\u2192p'}(m)). Protocol translations must preserve semantic content, and round-trip preservation T\u207b\u00b9(T(m)) \u2248 m.</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticViolationType","title":"<code>SemanticViolationType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Types of semantic violations.</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticViolationType.FIELD_MISSING","title":"<code>FIELD_MISSING = 'field_missing'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Required field is missing after translation</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticViolationType.FIELD_MODIFIED","title":"<code>FIELD_MODIFIED = 'field_modified'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Field value was unexpectedly modified</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticViolationType.TYPE_MISMATCH","title":"<code>TYPE_MISMATCH = 'type_mismatch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Field type changed during translation</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticViolationType.STRUCTURE_CHANGED","title":"<code>STRUCTURE_CHANGED = 'structure_changed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Overall message structure was altered</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticViolationType.ROUND_TRIP_FAILED","title":"<code>ROUND_TRIP_FAILED = 'round_trip_failed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>T\u207b\u00b9(T(m)) \u2260 m</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticViolationType.SEMANTIC_DRIFT","title":"<code>SEMANTIC_DRIFT = 'semantic_drift'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Semantic meaning has drifted beyond threshold</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticViolation","title":"<code>SemanticViolation</code>  <code>dataclass</code>","text":"<p>A specific semantic violation detected during verification.</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticViolation.violation_type","title":"<code>violation_type</code>  <code>instance-attribute</code>","text":"<p>Type of violation</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticViolation.field_path","title":"<code>field_path</code>  <code>instance-attribute</code>","text":"<p>Path to the affected field (e.g., 'payload.data.value')</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticViolation.original_value","title":"<code>original_value = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Original value before translation</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticViolation.translated_value","title":"<code>translated_value = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Value after translation</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticViolation.message","title":"<code>message = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Human-readable description</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticViolation.severity","title":"<code>severity = 'warning'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Severity: 'info', 'warning', 'error', 'critical'</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticVerificationResult","title":"<code>SemanticVerificationResult</code>  <code>dataclass</code>","text":"<p>Result of semantic preservation check.</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticVerificationResult.preserved","title":"<code>preserved</code>  <code>instance-attribute</code>","text":"<p>Whether semantics were fully preserved</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticVerificationResult.original_hash","title":"<code>original_hash</code>  <code>instance-attribute</code>","text":"<p>Semantic hash of original message</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticVerificationResult.translated_hash","title":"<code>translated_hash</code>  <code>instance-attribute</code>","text":"<p>Semantic hash of translated message</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticVerificationResult.round_trip_hash","title":"<code>round_trip_hash = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Semantic hash after round-trip translation (if performed)</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticVerificationResult.semantic_distance","title":"<code>semantic_distance = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Distance between original and translated (0.0 = identical, 1.0 = different)</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticVerificationResult.violations","title":"<code>violations = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of detected violations</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticVerificationResult.verification_time_ms","title":"<code>verification_time_ms = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Time taken for verification in milliseconds</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticVerificationResult.has_violations","title":"<code>has_violations</code>  <code>property</code>","text":"<p>Check if any violations were detected.</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticVerificationResult.critical_violations","title":"<code>critical_violations</code>  <code>property</code>","text":"<p>Get only critical violations.</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticVerificationResult.round_trip_preserved","title":"<code>round_trip_preserved</code>  <code>property</code>","text":"<p>Check if round-trip preservation holds.</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticVerificationResult.get_summary","title":"<code>get_summary()</code>","text":"<p>Get verification summary.</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.ProtocolMessage","title":"<code>ProtocolMessage</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for messages that can be semantically verified.</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.ProtocolMessage.semantic_fields","title":"<code>semantic_fields</code>  <code>property</code>","text":"<p>Fields that carry semantic meaning.</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.ProtocolMessage.protocol_metadata","title":"<code>protocol_metadata</code>  <code>property</code>","text":"<p>Protocol-specific metadata (not semantic).</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.ProtocolTranslator","title":"<code>ProtocolTranslator</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for translators that can translate messages.</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.ProtocolTranslator.translate","title":"<code>translate(message)</code>","text":"<p>Translate a message to target protocol.</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.ProtocolTranslator.reverse_translate","title":"<code>reverse_translate(message)</code>","text":"<p>Translate back to source protocol.</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.VerificationConfig","title":"<code>VerificationConfig</code>  <code>dataclass</code>","text":"<p>Configuration for semantic verification.</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.VerificationConfig.semantic_distance_threshold","title":"<code>semantic_distance_threshold = 0.1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum allowed semantic distance (0.0 to 1.0)</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.VerificationConfig.require_round_trip","title":"<code>require_round_trip = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to require round-trip verification</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.VerificationConfig.strict_type_checking","title":"<code>strict_type_checking = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to check field types strictly</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.VerificationConfig.ignore_fields","title":"<code>ignore_fields = field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fields to ignore during comparison</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.VerificationConfig.critical_fields","title":"<code>critical_fields = field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fields that must be preserved exactly</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticPreservationVerifier","title":"<code>SemanticPreservationVerifier</code>","text":"<p>Verify semantic preservation in protocol translations.</p> <p>Implements Definition 9 (Semantic Preservation): meaning(m) = meaning(T_{p\u2192p'}(m))</p> <p>Checks: - Field preservation - Type preservation - Structure preservation - Round-trip preservation: T\u207b\u00b9(T(m)) \u2248 m</p> Usage <p>verifier = SemanticPreservationVerifier()</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticPreservationVerifier--verify-a-translation","title":"Verify a translation","text":"<p>result = verifier.verify_translation(     original=original_message,     translated=translated_message, )</p> <p>if not result.preserved:     for violation in result.violations:         print(f\"Violation: {violation.message}\")</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticPreservationVerifier--verify-round-trip","title":"Verify round-trip","text":"<p>result = verifier.verify_round_trip(     message=original_message,     forward_translator=mcp_to_a2a,     reverse_translator=a2a_to_mcp, )</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticPreservationVerifier.__init__","title":"<code>__init__(config=None)</code>","text":"<p>Initialize semantic preservation verifier.</p> PARAMETER DESCRIPTION <code>config</code> <p>Verification configuration</p> <p> TYPE: <code>VerificationConfig | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticPreservationVerifier.verify_translation","title":"<code>verify_translation(original, translated)</code>","text":"<p>Verify semantic preservation in a translation.</p> PARAMETER DESCRIPTION <code>original</code> <p>Original message</p> <p> TYPE: <code>dict[str, Any] | ProtocolMessage</code> </p> <code>translated</code> <p>Translated message</p> <p> TYPE: <code>dict[str, Any] | ProtocolMessage</code> </p> RETURNS DESCRIPTION <code>SemanticVerificationResult</code> <p>SemanticVerificationResult with preservation status</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticPreservationVerifier.verify_round_trip","title":"<code>verify_round_trip(message, forward_translator, reverse_translator)</code>","text":"<p>Verify round-trip preservation: T\u207b\u00b9(T(m)) \u2248 m.</p> PARAMETER DESCRIPTION <code>message</code> <p>Original message</p> <p> TYPE: <code>dict[str, Any] | ProtocolMessage</code> </p> <code>forward_translator</code> <p>Translator from source to target protocol</p> <p> TYPE: <code>ProtocolTranslator</code> </p> <code>reverse_translator</code> <p>Translator from target back to source</p> <p> TYPE: <code>ProtocolTranslator</code> </p> RETURNS DESCRIPTION <code>SemanticVerificationResult</code> <p>SemanticVerificationResult with round-trip verification</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticPreservationVerifier.verify_output","title":"<code>verify_output(output, expected_schema)</code>","text":"<p>Verify output matches expected schema semantically.</p> PARAMETER DESCRIPTION <code>output</code> <p>Actual output</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>expected_schema</code> <p>Expected schema with field types</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>SemanticVerificationResult</code> <p>SemanticVerificationResult</p>"},{"location":"api/protocols/semantic/#agenticraft_foundation.protocols.semantic.SemanticPreservationVerifier.get_statistics","title":"<code>get_statistics()</code>","text":"<p>Get verification statistics.</p>"},{"location":"api/protocols/specifications/","title":"agenticraft_foundation.protocols.specifications","text":"<p>Formal protocol specifications \u2014 property definitions for protocol verification.</p> <p>Formal protocol specifications for verifying routing correctness.</p> <p>Provides executable formal specifications following the pattern from <code>specifications/consensus_spec.py</code>.</p> <p>Key properties: - ProtocolValidPath: all (u,v) in path use supported protocols - SemanticPreservation: meaning(m) = meaning(T_{p\u2192p'}(m)) - OptimalRouting: no path with lower cost exists</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolPropertyType","title":"<code>ProtocolPropertyType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Types of protocol formal properties.</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolPropertyType.VALIDITY","title":"<code>VALIDITY = 'validity'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Path validity constraints</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolPropertyType.SEMANTIC","title":"<code>SEMANTIC = 'semantic'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Semantic preservation constraints</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolPropertyType.OPTIMALITY","title":"<code>OPTIMALITY = 'optimality'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optimality constraints</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolPropertyType.INVARIANT","title":"<code>INVARIANT = 'invariant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Invariants that must always hold</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolPropertyStatus","title":"<code>ProtocolPropertyStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Status of protocol property verification.</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolPropertyResult","title":"<code>ProtocolPropertyResult</code>  <code>dataclass</code>","text":"<p>Result of protocol property verification.</p> ATTRIBUTE DESCRIPTION <code>property_name</code> <p>Name of the property checked</p> <p> TYPE: <code>str</code> </p> <code>property_type</code> <p>Type of property</p> <p> TYPE: <code>ProtocolPropertyType</code> </p> <code>status</code> <p>Verification status</p> <p> TYPE: <code>ProtocolPropertyStatus</code> </p> <code>message</code> <p>Human-readable message</p> <p> TYPE: <code>str</code> </p> <code>counterexample</code> <p>Counterexample if violated</p> <p> TYPE: <code>Any | None</code> </p> <code>details</code> <p>Additional verification details</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>timestamp</code> <p>When verification was performed</p> <p> TYPE: <code>float</code> </p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolPropertyResult.is_satisfied","title":"<code>is_satisfied()</code>","text":"<p>Check if property was satisfied.</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolFormalProperty","title":"<code>ProtocolFormalProperty</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for protocol formal properties.</p> <p>Properties are executable specifications that can be checked against protocol routing states.</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolFormalProperty.__init__","title":"<code>__init__(name, property_type)</code>","text":"<p>Initialize property.</p> PARAMETER DESCRIPTION <code>name</code> <p>Property name</p> <p> TYPE: <code>str</code> </p> <code>property_type</code> <p>Type of property</p> <p> TYPE: <code>ProtocolPropertyType</code> </p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolFormalProperty.check","title":"<code>check(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Check if property holds.</p> RETURNS DESCRIPTION <code>ProtocolPropertyResult</code> <p>ProtocolPropertyResult with verification outcome</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolValidPath","title":"<code>ProtocolValidPath</code>","text":"<p>               Bases: <code>ProtocolFormalProperty</code></p> <p>Protocol-valid path property.</p> <p>Constraint: \u2200 (u,v) \u2208 \u03c0: p\u1d62 \u2208 \u03a6(u,v)</p> <p>Verifies that every edge in the path supports the protocol used on it.</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolValidPath.__init__","title":"<code>__init__()</code>","text":"<p>Initialize ProtocolValidPath property.</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolValidPath.check","title":"<code>check(path=None, protocol_sequence=None, graph=None, **kwargs)</code>","text":"<p>Check if path is protocol-valid.</p> PARAMETER DESCRIPTION <code>path</code> <p>Sequence of agent IDs</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>protocol_sequence</code> <p>Protocol used on each edge</p> <p> TYPE: <code>list[ProtocolName] | None</code> DEFAULT: <code>None</code> </p> <code>graph</code> <p>Protocol graph</p> <p> TYPE: <code>ProtocolGraph | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ProtocolPropertyResult</code> <p>ProtocolPropertyResult indicating validity</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.SemanticPreservation","title":"<code>SemanticPreservation</code>","text":"<p>               Bases: <code>ProtocolFormalProperty</code></p> <p>Semantic preservation property.</p> <p>Constraint: meaning(m) = meaning(T_{p\u2192p'}(m))</p> <p>Verifies that protocol translations preserve semantic meaning.</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.SemanticPreservation.__init__","title":"<code>__init__(max_semantic_loss=0.1)</code>","text":"<p>Initialize SemanticPreservation property.</p> PARAMETER DESCRIPTION <code>max_semantic_loss</code> <p>Maximum allowed semantic loss (0.0 to 1.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.SemanticPreservation.check","title":"<code>check(route=None, semantic_loss=None, **kwargs)</code>","text":"<p>Check if semantic preservation holds.</p> PARAMETER DESCRIPTION <code>route</code> <p>OptimalRoute with semantic_loss_estimate</p> <p> TYPE: <code>OptimalRoute | None</code> DEFAULT: <code>None</code> </p> <code>semantic_loss</code> <p>Direct semantic loss value (alternative to route)</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ProtocolPropertyResult</code> <p>ProtocolPropertyResult indicating preservation</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.OptimalRouting","title":"<code>OptimalRouting</code>","text":"<p>               Bases: <code>ProtocolFormalProperty</code></p> <p>Optimal routing property.</p> <p>Constraint: No path \u03c0' exists with cost(\u03c0') &lt; cost(\u03c0)</p> <p>Verifies that the chosen route is optimal among alternatives.</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.OptimalRouting.__init__","title":"<code>__init__(tolerance=0.001)</code>","text":"<p>Initialize OptimalRouting property.</p> PARAMETER DESCRIPTION <code>tolerance</code> <p>Tolerance for floating-point comparison</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.001</code> </p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.OptimalRouting.check","title":"<code>check(route=None, all_routes=None, **kwargs)</code>","text":"<p>Check if route is optimal.</p> PARAMETER DESCRIPTION <code>route</code> <p>The route claimed to be optimal</p> <p> TYPE: <code>OptimalRoute | None</code> DEFAULT: <code>None</code> </p> <code>all_routes</code> <p>All possible routes for comparison</p> <p> TYPE: <code>list[OptimalRoute] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ProtocolPropertyResult</code> <p>ProtocolPropertyResult indicating optimality</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.TranslationBoundProperty","title":"<code>TranslationBoundProperty</code>","text":"<p>               Bases: <code>ProtocolFormalProperty</code></p> <p>Translation bound property.</p> <p>Constraint: Number of protocol translations \u2264 max_translations</p> <p>Verifies that routing doesn't exceed translation limits.</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.TranslationBoundProperty.__init__","title":"<code>__init__(max_translations=3)</code>","text":"<p>Initialize TranslationBoundProperty.</p> PARAMETER DESCRIPTION <code>max_translations</code> <p>Maximum allowed translations</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.TranslationBoundProperty.check","title":"<code>check(route=None, num_translations=None, **kwargs)</code>","text":"<p>Check if translation count is within bounds.</p> PARAMETER DESCRIPTION <code>route</code> <p>OptimalRoute to check</p> <p> TYPE: <code>OptimalRoute | None</code> DEFAULT: <code>None</code> </p> <code>num_translations</code> <p>Direct translation count (alternative)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ProtocolPropertyResult</code> <p>ProtocolPropertyResult indicating if bound holds</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolResilience","title":"<code>ProtocolResilience</code>","text":"<p>               Bases: <code>ProtocolFormalProperty</code></p> <p>k-Protocol resilience verification.</p> <p>Theorem 1: A mesh achieves at most (|P|-1)-protocol resilience. Verifies that removing any k-1 protocols preserves graph connectivity.</p> <p>This checks: for each subset S of protocols with |S| = k-1, removing all edges that ONLY support protocols in S still leaves the graph connected.</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolResilience.__init__","title":"<code>__init__(k=1)</code>","text":"<p>Initialize ProtocolResilience property.</p> PARAMETER DESCRIPTION <code>k</code> <p>Resilience level to verify. The mesh is k-protocol-resilient if it remains connected when any k-1 protocols fail.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolResilience.check","title":"<code>check(graph=None, **kwargs)</code>","text":"<p>Check if mesh is k-protocol-resilient.</p> PARAMETER DESCRIPTION <code>graph</code> <p>Protocol graph to verify</p> <p> TYPE: <code>ProtocolGraph | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ProtocolPropertyResult</code> <p>ProtocolPropertyResult indicating resilience status</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolSpecification","title":"<code>ProtocolSpecification</code>","text":"<p>Complete specification for protocol routing.</p> <p>Combines all protocol properties and provides verification API.</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolSpecification.__init__","title":"<code>__init__(max_semantic_loss=0.1, max_translations=3, custom_properties=None)</code>","text":"<p>Initialize specification.</p> PARAMETER DESCRIPTION <code>max_semantic_loss</code> <p>Threshold for semantic preservation</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p> <code>max_translations</code> <p>Maximum allowed translations</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>custom_properties</code> <p>Additional custom properties</p> <p> TYPE: <code>list[ProtocolFormalProperty] | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolSpecification.verify","title":"<code>verify(route, graph, all_routes=None)</code>","text":"<p>Verify all properties for a route.</p> PARAMETER DESCRIPTION <code>route</code> <p>Route to verify</p> <p> TYPE: <code>OptimalRoute</code> </p> <code>graph</code> <p>Protocol graph</p> <p> TYPE: <code>ProtocolGraph</code> </p> <code>all_routes</code> <p>Alternative routes for optimality check</p> <p> TYPE: <code>list[OptimalRoute] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[ProtocolPropertyResult]</code> <p>List of property results</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolSpecification.verify_validity","title":"<code>verify_validity(path, protocol_sequence, graph)</code>","text":"<p>Verify only path validity.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to verify</p> <p> TYPE: <code>list[str]</code> </p> <code>protocol_sequence</code> <p>Protocols used</p> <p> TYPE: <code>list[ProtocolName]</code> </p> <code>graph</code> <p>Protocol graph</p> <p> TYPE: <code>ProtocolGraph</code> </p> RETURNS DESCRIPTION <code>ProtocolPropertyResult</code> <p>Validity property result</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolSpecification.is_valid","title":"<code>is_valid(route, graph)</code>","text":"<p>Check if route satisfies all properties.</p> PARAMETER DESCRIPTION <code>route</code> <p>Route to check</p> <p> TYPE: <code>OptimalRoute</code> </p> <code>graph</code> <p>Protocol graph</p> <p> TYPE: <code>ProtocolGraph</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if all properties satisfied</p>"},{"location":"api/protocols/specifications/#agenticraft_foundation.protocols.specifications.ProtocolSpecification.summary","title":"<code>summary(route, graph, all_routes=None)</code>","text":"<p>Generate verification summary.</p> PARAMETER DESCRIPTION <code>route</code> <p>Route to summarize</p> <p> TYPE: <code>OptimalRoute</code> </p> <code>graph</code> <p>Protocol graph</p> <p> TYPE: <code>ProtocolGraph</code> </p> <code>all_routes</code> <p>Alternative routes</p> <p> TYPE: <code>list[OptimalRoute] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Human-readable summary</p>"},{"location":"api/protocols/transformers/","title":"agenticraft_foundation.protocols.transformers","text":"<p>Composable protocol message transformers \\(T: M_p \\to M_{p'} \\cup \\{\\bot\\}\\) with lossless, lossy, and destructive classification.</p> <p>Composable Protocol Transformers.</p> <p>Models protocol transformers as composable algebraic objects:</p> <pre><code>T_{p\u2192p'}: M\u209a \u2192 M\u209a' \u222a {\u22a5}\n</code></pre> <p>With identity and composition laws: - Identity: T_{p\u2192p} = id (no transformation) - Composition: T_{p\u2192p''} = T_{p'\u2192p''} \u2218 T_{p\u2192p'}</p> <p>Implements Theorem 6: Lossless/lossy classification. A transformer is lossless iff T\u207b\u00b9(T(m)) = m for all m \u2208 M\u209a.</p> <p>Usage::</p> <pre><code>registry = TransformerRegistry()\nregistry.register(mcp_to_a2a)\nregistry.register(a2a_to_mcp)\n\n# Auto-compose: MCP \u2192 A2A \u2192 ANP\ncomposed = registry.get_transformer(ProtocolName.MCP, ProtocolName.ANP)\nresult = composed.transform(message)\n</code></pre>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformerClassification","title":"<code>TransformerClassification</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Classification of a protocol transformer (Theorem 6).</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformerClassification.LOSSLESS","title":"<code>LOSSLESS = 'lossless'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>T\u207b\u00b9(T(m)) = m for all m \u2014 perfect round-trip</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformerClassification.LOSSY","title":"<code>LOSSY = 'lossy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>T\u207b\u00b9(T(m)) \u2248 m \u2014 some information loss</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformerClassification.DESTRUCTIVE","title":"<code>DESTRUCTIVE = 'destructive'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>T\u207b\u00b9(T(m)) may be \u22a5 \u2014 significant information loss</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformResult","title":"<code>TransformResult</code>  <code>dataclass</code>","text":"<p>Result of a protocol transformation.</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformResult.success","title":"<code>success</code>  <code>instance-attribute</code>","text":"<p>Whether the transformation succeeded</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformResult.message","title":"<code>message = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transformed message (None if failed, i.e., \u22a5)</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformResult.source_protocol","title":"<code>source_protocol = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Source protocol</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformResult.target_protocol","title":"<code>target_protocol = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Target protocol</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformResult.fields_preserved","title":"<code>fields_preserved = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of semantic fields preserved</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformResult.fields_lost","title":"<code>fields_lost = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of semantic fields lost</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformResult.metadata","title":"<code>metadata = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transformation metadata</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformResult.preservation_ratio","title":"<code>preservation_ratio</code>  <code>property</code>","text":"<p>Ratio of preserved fields to total fields.</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.BaseProtocolTransformer","title":"<code>BaseProtocolTransformer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for protocol transformers.</p> <p>T_{p\u2192p'}: M\u209a \u2192 M\u209a' \u222a {\u22a5}</p> <p>Subclasses implement the actual transformation logic for specific protocol pairs.</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.BaseProtocolTransformer.source_protocol","title":"<code>source_protocol</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Source protocol.</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.BaseProtocolTransformer.target_protocol","title":"<code>target_protocol</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Target protocol.</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.BaseProtocolTransformer.classification","title":"<code>classification</code>  <code>property</code>","text":"<p>Transformer classification (default: lossy).</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.BaseProtocolTransformer.transform","title":"<code>transform(message)</code>  <code>abstractmethod</code>","text":"<p>Transform a message from source to target protocol.</p> PARAMETER DESCRIPTION <code>message</code> <p>Message in source protocol format</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>TransformResult</code> <p>TransformResult with transformed message or failure (\u22a5)</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.IdentityTransformer","title":"<code>IdentityTransformer</code>","text":"<p>               Bases: <code>BaseProtocolTransformer</code></p> <p>Identity transformer: T_{p\u2192p} = id.</p> <p>Returns the message unchanged. Always lossless.</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.ComposedTransformer","title":"<code>ComposedTransformer</code>","text":"<p>               Bases: <code>BaseProtocolTransformer</code></p> <p>Composition of two transformers: T_{p\u2192p''} = T_{p'\u2192p''} \u2218 T_{p\u2192p'}.</p> <p>Applies first transformer, then second transformer to the result.</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.ComposedTransformer.classification","title":"<code>classification</code>  <code>property</code>","text":"<p>Composition classification: worst of the two.</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformerRegistry","title":"<code>TransformerRegistry</code>","text":"<p>Registry of protocol transformers with automatic composition.</p> <p>Manages registered transformers and computes composed transformers for protocol pairs that don't have direct transformers.</p> <p>Usage::</p> <pre><code>registry = TransformerRegistry()\nregistry.register(mcp_to_a2a_transformer)\nregistry.register(a2a_to_anp_transformer)\n\n# Direct lookup\nt = registry.get_transformer(ProtocolName.MCP, ProtocolName.A2A)\n\n# Auto-composed (MCP\u2192A2A\u2192ANP)\nt = registry.get_transformer(ProtocolName.MCP, ProtocolName.ANP)\n</code></pre>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformerRegistry.registered_pairs","title":"<code>registered_pairs</code>  <code>property</code>","text":"<p>Get all registered transformer pairs (excluding identity).</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformerRegistry.register","title":"<code>register(transformer)</code>","text":"<p>Register a transformer.</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformerRegistry.has_transformer","title":"<code>has_transformer(source, target)</code>","text":"<p>Check if a direct transformer exists.</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformerRegistry.get_direct_transformer","title":"<code>get_direct_transformer(source, target)</code>","text":"<p>Get a direct (non-composed) transformer.</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformerRegistry.get_transformer","title":"<code>get_transformer(source, target)</code>","text":"<p>Get a transformer, composing if needed.</p> <p>First checks for a direct transformer. If not found, attempts to compose via a single intermediate protocol (BFS depth 1).</p> PARAMETER DESCRIPTION <code>source</code> <p>Source protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>target</code> <p>Target protocol</p> <p> TYPE: <code>ProtocolName</code> </p> RETURNS DESCRIPTION <code>BaseProtocolTransformer | None</code> <p>Transformer or None if no path exists</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformerRegistry.get_all_paths","title":"<code>get_all_paths(source, target, max_hops=3)</code>","text":"<p>Find all transformation paths from source to target.</p> <p>Uses BFS to find paths up to max_hops length.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>target</code> <p>Target protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>max_hops</code> <p>Maximum number of intermediate transformations</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> RETURNS DESCRIPTION <code>list[list[ProtocolName]]</code> <p>List of protocol paths (including source and target)</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformerRegistry.compose_path","title":"<code>compose_path(path)</code>","text":"<p>Compose a transformer from a protocol path.</p> PARAMETER DESCRIPTION <code>path</code> <p>List of protocols [p1, p2, ..., pn]</p> <p> TYPE: <code>list[ProtocolName]</code> </p> RETURNS DESCRIPTION <code>BaseProtocolTransformer | None</code> <p>Composed transformer p1\u2192p2\u2192...\u2192pn, or None if any hop is missing</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformerRegistry.verify_round_trip","title":"<code>verify_round_trip(protocol_a, protocol_b, test_message)</code>","text":"<p>Verify round-trip preservation: T\u207b\u00b9(T(m)) = m.</p> PARAMETER DESCRIPTION <code>protocol_a</code> <p>First protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>protocol_b</code> <p>Second protocol</p> <p> TYPE: <code>ProtocolName</code> </p> <code>test_message</code> <p>Test message to verify with</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if round-trip preserves the message</p>"},{"location":"api/protocols/transformers/#agenticraft_foundation.protocols.transformers.TransformerRegistry.get_statistics","title":"<code>get_statistics()</code>","text":"<p>Get registry statistics.</p>"},{"location":"api/protocols/workflow/","title":"agenticraft_foundation.protocols.workflow","text":"<p>Protocol workflow model \\(W = (T, \\prec, \\rho)\\) \u2014 task definitions, precedence ordering, protocol assignment, validation, and optimal assignment.</p> <p>Protocol Workflow Model: W = (T, \u227a, \u03c1).</p> <p>Formal model for protocol-aware workflow composition.</p> <ul> <li>T: Set of tasks (nodes in the workflow DAG)</li> <li>\u227a: Precedence relation (directed edges, forming a DAG)</li> <li>\u03c1: T \u2192 P assigns each task to a protocol</li> </ul> <p>Implements: - Workflow executability verification (Theorem 9 conditions) - Optimal protocol assignment via DP (tree-structured) and greedy (general DAGs) - Translation cost minimization across task boundaries</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowTaskStatus","title":"<code>WorkflowTaskStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Status of a workflow task.</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowTask","title":"<code>WorkflowTask</code>  <code>dataclass</code>","text":"<p>A task in the protocol workflow.</p> <p>Each task has an ID, required capabilities, and an assigned protocol.</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowTask.task_id","title":"<code>task_id</code>  <code>instance-attribute</code>","text":"<p>Unique task identifier</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowTask.capabilities","title":"<code>capabilities = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Capabilities required to execute this task</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowTask.assigned_protocol","title":"<code>assigned_protocol = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Protocol assigned to this task (\u03c1(t))</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowTask.compatible_protocols","title":"<code>compatible_protocols = field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Protocols that can execute this task</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowTask.assigned_agent","title":"<code>assigned_agent = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Agent assigned to execute this task</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowTask.metadata","title":"<code>metadata = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Additional task metadata</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowTask.status","title":"<code>status = WorkflowTaskStatus.PENDING</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current task status</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowEdge","title":"<code>WorkflowEdge</code>  <code>dataclass</code>","text":"<p>Precedence edge in the workflow DAG.</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowEdge.source","title":"<code>source</code>  <code>instance-attribute</code>","text":"<p>Predecessor task ID</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowEdge.target","title":"<code>target</code>  <code>instance-attribute</code>","text":"<p>Successor task ID</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowEdge.data_dependency","title":"<code>data_dependency = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether the edge represents a data dependency</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.ProtocolWorkflow","title":"<code>ProtocolWorkflow</code>  <code>dataclass</code>","text":"<p>Protocol workflow model: W = (T, \u227a, \u03c1).</p> <p>Represents a directed acyclic graph of tasks with protocol assignments.</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.ProtocolWorkflow.workflow_id","title":"<code>workflow_id</code>  <code>instance-attribute</code>","text":"<p>Unique workflow identifier</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.ProtocolWorkflow.tasks","title":"<code>tasks = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Task set T, keyed by task_id</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.ProtocolWorkflow.edges","title":"<code>edges = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Precedence relation \u227a</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.ProtocolWorkflow.add_task","title":"<code>add_task(task_id, capabilities=None, compatible_protocols=None, assigned_protocol=None, metadata=None)</code>","text":"<p>Add a task to the workflow.</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.ProtocolWorkflow.add_precedence","title":"<code>add_precedence(source, target, data_dependency=True)</code>","text":"<p>Add a precedence edge: source \u227a target (source must complete before target).</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.ProtocolWorkflow.predecessors","title":"<code>predecessors(task_id)</code>","text":"<p>Get predecessor task IDs.</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.ProtocolWorkflow.successors","title":"<code>successors(task_id)</code>","text":"<p>Get successor task IDs.</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.ProtocolWorkflow.roots","title":"<code>roots()</code>","text":"<p>Get tasks with no predecessors (entry points).</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.ProtocolWorkflow.leaves","title":"<code>leaves()</code>","text":"<p>Get tasks with no successors (exit points).</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.ProtocolWorkflow.topological_sort","title":"<code>topological_sort()</code>","text":"<p>Return tasks in topological order. Raises ValueError if cycle detected.</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.ProtocolWorkflow.is_tree","title":"<code>is_tree()</code>","text":"<p>Check if the workflow DAG is a tree (each node has at most one predecessor).</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.ProtocolWorkflow.translation_points","title":"<code>translation_points()</code>","text":"<p>Find edges where protocol translation is needed.</p> <p>Returns list of (source_task, target_task, source_protocol, target_protocol).</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.ProtocolWorkflow.total_translation_cost","title":"<code>total_translation_cost(base_cost_per_translation=0.1)</code>","text":"<p>Calculate total protocol translation cost across the workflow.</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowValidationResult","title":"<code>WorkflowValidationResult</code>  <code>dataclass</code>","text":"<p>Result of workflow validation.</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowValidationResult.valid","title":"<code>valid</code>  <code>instance-attribute</code>","text":"<p>Whether the workflow is executable</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowValidationResult.errors","title":"<code>errors = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Validation errors</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowValidationResult.warnings","title":"<code>warnings = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Validation warnings</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowValidationResult.translation_count","title":"<code>translation_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of protocol translations needed</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowValidationResult.estimated_cost","title":"<code>estimated_cost = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Estimated total execution cost</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowValidator","title":"<code>WorkflowValidator</code>","text":"<p>Validate workflow executability.</p> <p>Checks Theorem 9 conditions: 1. The workflow forms a valid DAG (no cycles) 2. Every task has an assigned protocol 3. Every task's assigned protocol is in its compatible set 4. For each precedence edge, the protocols are compatible    (directly or via translation)</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.WorkflowValidator.validate","title":"<code>validate(workflow, graph=None)</code>","text":"<p>Validate workflow executability.</p> PARAMETER DESCRIPTION <code>workflow</code> <p>The protocol workflow to validate</p> <p> TYPE: <code>ProtocolWorkflow</code> </p> <code>graph</code> <p>Optional protocol graph for agent-level validation</p> <p> TYPE: <code>ProtocolGraph | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>WorkflowValidationResult</code> <p>WorkflowValidationResult with validation outcome</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.OptimalProtocolAssigner","title":"<code>OptimalProtocolAssigner</code>","text":"<p>Assign protocols to tasks minimizing total translation cost.</p> <p>For tree-structured workflows: DP in O(|T| * |P|^2). For general DAGs: greedy heuristic.</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.OptimalProtocolAssigner.assign","title":"<code>assign(workflow)</code>","text":"<p>Assign protocols to minimize translation cost.</p> <p>Uses DP for trees, greedy for general DAGs.</p> PARAMETER DESCRIPTION <code>workflow</code> <p>The workflow to assign protocols for</p> <p> TYPE: <code>ProtocolWorkflow</code> </p> RETURNS DESCRIPTION <code>dict[str, ProtocolName]</code> <p>Mapping from task_id to assigned protocol</p>"},{"location":"api/protocols/workflow/#agenticraft_foundation.protocols.workflow.OptimalProtocolAssigner.apply_assignment","title":"<code>apply_assignment(workflow, assignment)</code>","text":"<p>Apply a protocol assignment to the workflow tasks.</p>"},{"location":"api/specifications/","title":"specifications","text":"<p>Formal consensus properties, weighted quorum consensus, and bidirectional MAS theory mappings.</p> <p>Formal specifications for distributed protocols.</p> <p>This module provides executable specifications for verifying correctness of consensus and coordination protocols.</p>"},{"location":"api/specifications/#submodules","title":"Submodules","text":"Module Description <code>consensus_spec</code> Consensus properties \u2014 Agreement, Validity, Integrity, Termination <code>weighted_consensus_spec</code> Weighted quorum consensus with \\(2W/3\\) threshold <code>mas_mappings</code> MAS theory mappings \u2014 BDI, Joint Intentions, SharedPlans, Contract Net"},{"location":"api/specifications/consensus-spec/","title":"agenticraft_foundation.specifications.consensus_spec","text":"<p>Formal consensus properties \u2014 Agreement, Validity, Integrity, and Termination.</p> <p>Formal specifications for consensus protocols.</p> <p>This module provides executable formal specifications for verifying consensus protocol correctness, based on distributed systems theory.</p> <p>Key properties verified: - Safety: Agreement, Validity, Integrity - Liveness: Termination</p> <p>References: - Fischer, Lynch, Paterson (1985) - Impossibility of consensus - Castro &amp; Liskov (1999) - PBFT - Lamport (1998) - Paxos Made Simple</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.PropertyType","title":"<code>PropertyType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Types of formal properties.</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.PropertyStatus","title":"<code>PropertyStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Status of property verification.</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.PropertyResult","title":"<code>PropertyResult</code>  <code>dataclass</code>","text":"<p>Result of property verification.</p> ATTRIBUTE DESCRIPTION <code>property_name</code> <p>Name of the property checked</p> <p> TYPE: <code>str</code> </p> <code>property_type</code> <p>Type of property (safety, liveness, etc.)</p> <p> TYPE: <code>PropertyType</code> </p> <code>status</code> <p>Verification status</p> <p> TYPE: <code>PropertyStatus</code> </p> <code>message</code> <p>Human-readable message</p> <p> TYPE: <code>str</code> </p> <code>counterexample</code> <p>Counterexample if violated</p> <p> TYPE: <code>Any | None</code> </p> <code>trace</code> <p>Execution trace leading to violation</p> <p> TYPE: <code>list[str]</code> </p> <code>timestamp</code> <p>When verification was performed</p> <p> TYPE: <code>float</code> </p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.PropertyResult.is_satisfied","title":"<code>is_satisfied()</code>","text":"<p>Check if property was satisfied.</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.ConsensusState","title":"<code>ConsensusState</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>State of a consensus instance.</p> ATTRIBUTE DESCRIPTION <code>instance_id</code> <p>Unique identifier for this consensus instance</p> <p> TYPE: <code>str</code> </p> <code>participants</code> <p>Set of participant IDs</p> <p> TYPE: <code>set[str]</code> </p> <code>proposed_values</code> <p>Values proposed by each participant</p> <p> TYPE: <code>dict[str, T]</code> </p> <code>decisions</code> <p>Final decisions by each participant</p> <p> TYPE: <code>dict[str, T]</code> </p> <code>messages</code> <p>Messages exchanged</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> <code>round</code> <p>Current round number</p> <p> TYPE: <code>int</code> </p> <code>is_terminated</code> <p>Whether consensus has terminated</p> <p> TYPE: <code>bool</code> </p> <code>metadata</code> <p>Additional state metadata</p> <p> TYPE: <code>dict[str, Any]</code> </p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.FormalProperty","title":"<code>FormalProperty</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Base class for formal properties.</p> <p>Properties are executable specifications that can be checked against consensus states.</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.FormalProperty.__init__","title":"<code>__init__(name, property_type)</code>","text":"<p>Initialize property.</p> PARAMETER DESCRIPTION <code>name</code> <p>Property name</p> <p> TYPE: <code>str</code> </p> <code>property_type</code> <p>Type of property</p> <p> TYPE: <code>PropertyType</code> </p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.FormalProperty.check","title":"<code>check(state)</code>  <code>abstractmethod</code>","text":"<p>Check if property holds for given state.</p> PARAMETER DESCRIPTION <code>state</code> <p>Consensus state to check</p> <p> TYPE: <code>ConsensusState[T]</code> </p> RETURNS DESCRIPTION <code>PropertyResult</code> <p>PropertyResult with verification outcome</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.Agreement","title":"<code>Agreement</code>","text":"<p>               Bases: <code>FormalProperty[Any]</code></p> <p>Agreement property: No two correct processes decide differently.</p> <p>Formally: For all correct processes p and q, if p decides v and q decides v', then v = v'.</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.Agreement.__init__","title":"<code>__init__(correct_processes=None)</code>","text":"<p>Initialize Agreement property.</p> PARAMETER DESCRIPTION <code>correct_processes</code> <p>Set of correct (non-faulty) process IDs. If None, all participants are assumed correct.</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.Agreement.check","title":"<code>check(state)</code>","text":"<p>Check Agreement property.</p> PARAMETER DESCRIPTION <code>state</code> <p>Consensus state to check</p> <p> TYPE: <code>ConsensusState[Any]</code> </p> RETURNS DESCRIPTION <code>PropertyResult</code> <p>PropertyResult indicating if Agreement holds</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.Validity","title":"<code>Validity</code>","text":"<p>               Bases: <code>FormalProperty[Any]</code></p> <p>Validity property: Decided value was proposed by some process.</p> <p>Formally: If a correct process decides v, then v was proposed by some process.</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.Validity.__init__","title":"<code>__init__(correct_processes=None)</code>","text":"<p>Initialize Validity property.</p> PARAMETER DESCRIPTION <code>correct_processes</code> <p>Set of correct process IDs</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.Validity.check","title":"<code>check(state)</code>","text":"<p>Check Validity property.</p> PARAMETER DESCRIPTION <code>state</code> <p>Consensus state to check</p> <p> TYPE: <code>ConsensusState[Any]</code> </p> RETURNS DESCRIPTION <code>PropertyResult</code> <p>PropertyResult indicating if Validity holds</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.Integrity","title":"<code>Integrity</code>","text":"<p>               Bases: <code>FormalProperty[Any]</code></p> <p>Integrity property: A process decides at most once.</p> <p>Formally: For all correct processes p, p decides at most once. This is implicitly tracked by the decision being final.</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.Integrity.__init__","title":"<code>__init__(decision_history=None)</code>","text":"<p>Initialize Integrity property.</p> PARAMETER DESCRIPTION <code>decision_history</code> <p>Historical decisions per process</p> <p> TYPE: <code>dict[str, list[Any]] | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.Integrity.check","title":"<code>check(state)</code>","text":"<p>Check Integrity property.</p> PARAMETER DESCRIPTION <code>state</code> <p>Consensus state to check</p> <p> TYPE: <code>ConsensusState[Any]</code> </p> RETURNS DESCRIPTION <code>PropertyResult</code> <p>PropertyResult indicating if Integrity holds</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.Termination","title":"<code>Termination</code>","text":"<p>               Bases: <code>FormalProperty[Any]</code></p> <p>Termination property: Every correct process eventually decides.</p> <p>This is a liveness property that requires eventual progress. Formally: Every correct process eventually decides some value.</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.Termination.__init__","title":"<code>__init__(correct_processes=None, timeout_rounds=100)</code>","text":"<p>Initialize Termination property.</p> PARAMETER DESCRIPTION <code>correct_processes</code> <p>Set of correct process IDs</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> <code>timeout_rounds</code> <p>Maximum rounds before timeout</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.Termination.check","title":"<code>check(state)</code>","text":"<p>Check Termination property.</p> PARAMETER DESCRIPTION <code>state</code> <p>Consensus state to check</p> <p> TYPE: <code>ConsensusState[Any]</code> </p> RETURNS DESCRIPTION <code>PropertyResult</code> <p>PropertyResult indicating if Termination holds/progresses</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.ConsensusSpecification","title":"<code>ConsensusSpecification</code>","text":"<p>Complete specification for consensus protocols.</p> <p>Combines all consensus properties and provides verification API.</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.ConsensusSpecification.__init__","title":"<code>__init__(correct_processes=None, custom_properties=None)</code>","text":"<p>Initialize specification.</p> PARAMETER DESCRIPTION <code>correct_processes</code> <p>Set of correct process IDs</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> <code>custom_properties</code> <p>Additional custom properties to check</p> <p> TYPE: <code>list[FormalProperty[Any]] | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.ConsensusSpecification.verify","title":"<code>verify(state)</code>","text":"<p>Verify all properties against state.</p> PARAMETER DESCRIPTION <code>state</code> <p>Consensus state to verify</p> <p> TYPE: <code>ConsensusState[Any]</code> </p> RETURNS DESCRIPTION <code>list[PropertyResult]</code> <p>List of PropertyResults for all properties</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.ConsensusSpecification.verify_safety","title":"<code>verify_safety(state)</code>","text":"<p>Verify only safety properties.</p> PARAMETER DESCRIPTION <code>state</code> <p>Consensus state to verify</p> <p> TYPE: <code>ConsensusState[Any]</code> </p> RETURNS DESCRIPTION <code>list[PropertyResult]</code> <p>List of PropertyResults for safety properties</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.ConsensusSpecification.verify_liveness","title":"<code>verify_liveness(state)</code>","text":"<p>Verify only liveness properties.</p> PARAMETER DESCRIPTION <code>state</code> <p>Consensus state to verify</p> <p> TYPE: <code>ConsensusState[Any]</code> </p> RETURNS DESCRIPTION <code>list[PropertyResult]</code> <p>List of PropertyResults for liveness properties</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.ConsensusSpecification.is_valid","title":"<code>is_valid(state)</code>","text":"<p>Check if state satisfies all safety properties.</p> PARAMETER DESCRIPTION <code>state</code> <p>Consensus state to check</p> <p> TYPE: <code>ConsensusState[Any]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if all safety properties satisfied</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.ConsensusSpecification.summary","title":"<code>summary(state)</code>","text":"<p>Generate verification summary.</p> PARAMETER DESCRIPTION <code>state</code> <p>Consensus state to summarize</p> <p> TYPE: <code>ConsensusState[Any]</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Human-readable summary</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.InvariantChecker","title":"<code>InvariantChecker</code>  <code>dataclass</code>","text":"<p>Runtime invariant checker for consensus protocols.</p> <p>Monitors state transitions and checks invariants are maintained.</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.InvariantChecker.add_invariant","title":"<code>add_invariant(invariant)</code>","text":"<p>Add an invariant to check.</p> PARAMETER DESCRIPTION <code>invariant</code> <p>Invariant property to monitor</p> <p> TYPE: <code>FormalProperty[Any]</code> </p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.InvariantChecker.check","title":"<code>check(state)</code>","text":"<p>Check all invariants against current state.</p> PARAMETER DESCRIPTION <code>state</code> <p>Current consensus state</p> <p> TYPE: <code>ConsensusState[Any]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if all invariants hold</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.InvariantChecker.get_violations","title":"<code>get_violations()</code>","text":"<p>Get all recorded violations.</p> RETURNS DESCRIPTION <code>list[PropertyResult]</code> <p>List of violation results</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.InvariantChecker.clear","title":"<code>clear()</code>","text":"<p>Clear violation history.</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.create_byzantine_spec","title":"<code>create_byzantine_spec(n, f)</code>","text":"<p>Create specification for Byzantine fault tolerant consensus.</p> <p>Requires n &gt;= 3f + 1 for safety.</p> PARAMETER DESCRIPTION <code>n</code> <p>Total number of processes</p> <p> TYPE: <code>int</code> </p> <code>f</code> <p>Maximum Byzantine failures</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConsensusSpecification</code> <p>ConsensusSpecification configured for BFT</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.create_crash_spec","title":"<code>create_crash_spec(n, f)</code>","text":"<p>Create specification for crash fault tolerant consensus.</p> <p>Requires n &gt;= 2f + 1 for safety.</p> PARAMETER DESCRIPTION <code>n</code> <p>Total number of processes</p> <p> TYPE: <code>int</code> </p> <code>f</code> <p>Maximum crash failures</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConsensusSpecification</code> <p>ConsensusSpecification configured for CFT</p>"},{"location":"api/specifications/consensus-spec/#agenticraft_foundation.specifications.consensus_spec.hash_state","title":"<code>hash_state(state)</code>","text":"<p>Compute hash of consensus state for verification.</p> PARAMETER DESCRIPTION <code>state</code> <p>State to hash</p> <p> TYPE: <code>ConsensusState[Any]</code> </p> RETURNS DESCRIPTION <code>str</code> <p>SHA256 hash of state</p>"},{"location":"api/specifications/mas-mappings/","title":"agenticraft_foundation.specifications.mas_mappings","text":"<p>Bidirectional MAS theory mappings \u2014 BDI, Joint Intentions, SharedPlans, and Contract Net with formal property preservation.</p> <p>Classical Multi-Agent Systems (MAS) formal mappings.</p> <p>Maps classical MAS theories to mesh coordination primitives:</p> <ol> <li> <p>BDI (Belief-Desire-Intention):    Beliefs \u2192 context state, Desires \u2192 task objectives, Intentions \u2192 active assignments</p> </li> <li> <p>Joint Intentions (Cohen &amp; Levesque):    Mutual belief \u2192 consensus state, Persistent goal \u2192 task completion</p> </li> <li> <p>SharedPlans (Grosz &amp; Kraus):    Recipe \u2192 task decomposition DAG, Subgroup plans \u2192 agent clusters</p> </li> <li> <p>Contract Net Protocol (Smith 1980):    Manager broadcasts CFP \u2192 bidders respond \u2192 manager awards</p> </li> </ol> <p>Each mapping provides bidirectional transformations between classical MAS concepts and mesh coordination state, with property preservation verification.</p> <p>References: - Rao &amp; Georgeff (1995) - BDI agents - Cohen &amp; Levesque (1990) - Intention is choice with commitment - Grosz &amp; Kraus (1996) - Collaborative plans - Smith (1980) - Contract Net Protocol</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.MASTheory","title":"<code>MASTheory</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Classical MAS theories.</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.MASTheory.BDI","title":"<code>BDI = 'bdi'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Belief-Desire-Intention architecture</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.MASTheory.JOINT_INTENTIONS","title":"<code>JOINT_INTENTIONS = 'joint_intentions'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Cohen &amp; Levesque's Joint Intentions</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.MASTheory.SHARED_PLANS","title":"<code>SHARED_PLANS = 'shared_plans'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Grosz &amp; Kraus's SharedPlans</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.MASTheory.CONTRACT_NET","title":"<code>CONTRACT_NET = 'contract_net'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Smith's Contract Net Protocol</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.MeshState","title":"<code>MeshState</code>  <code>dataclass</code>","text":"<p>Representation of mesh coordination state.</p> <p>Common structure that all MAS mappings convert to/from.</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.MeshState.agents","title":"<code>agents = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Agent states: agent_id \u2192 {capabilities, assignments, status, ...}</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.MeshState.tasks","title":"<code>tasks = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Task states: task_id \u2192 {objective, status, assigned_agent, ...}</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.MeshState.consensus","title":"<code>consensus = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Consensus state: {round, decisions, proposed_values, ...}</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.MeshState.messages","title":"<code>messages = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Message history</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.BDIState","title":"<code>BDIState</code>  <code>dataclass</code>","text":"<p>BDI agent mental state.</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.BDIState.beliefs","title":"<code>beliefs = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Agent's beliefs about the world</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.BDIState.desires","title":"<code>desires = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Agent's desires (goals)</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.BDIState.intentions","title":"<code>intentions = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Agent's committed intentions (active plans)</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.BDIState.agent_id","title":"<code>agent_id = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Owning agent</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.BDIMapping","title":"<code>BDIMapping</code>","text":"<p>Map BDI mental state to/from mesh coordination state.</p> <ul> <li>Beliefs \u2192 agent context state (world model)</li> <li>Desires \u2192 task objectives (unassigned goals)</li> <li>Intentions \u2192 active task assignments (committed plans)</li> </ul>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.BDIMapping.to_mesh","title":"<code>to_mesh(bdi_states)</code>  <code>staticmethod</code>","text":"<p>Convert BDI states to mesh state.</p> PARAMETER DESCRIPTION <code>bdi_states</code> <p>BDI states keyed by agent_id</p> <p> TYPE: <code>dict[str, BDIState]</code> </p> RETURNS DESCRIPTION <code>MeshState</code> <p>MeshState representation</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.BDIMapping.from_mesh","title":"<code>from_mesh(mesh)</code>  <code>staticmethod</code>","text":"<p>Convert mesh state to BDI states.</p> PARAMETER DESCRIPTION <code>mesh</code> <p>Mesh coordination state</p> <p> TYPE: <code>MeshState</code> </p> RETURNS DESCRIPTION <code>dict[str, BDIState]</code> <p>BDI states keyed by agent_id</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.JointIntentionState","title":"<code>JointIntentionState</code>  <code>dataclass</code>","text":"<p>Joint Intention state (Cohen &amp; Levesque).</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.JointIntentionState.team","title":"<code>team = field(default_factory=set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Team members</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.JointIntentionState.mutual_beliefs","title":"<code>mutual_beliefs = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mutually believed facts</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.JointIntentionState.persistent_goal","title":"<code>persistent_goal = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The persistent goal the team is committed to</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.JointIntentionState.joint_commitment","title":"<code>joint_commitment = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether the team has a joint commitment</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.JointIntentionState.goal_status","title":"<code>goal_status = 'active'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Status: active, achieved, impossible, abandoned</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.JointIntentionMapping","title":"<code>JointIntentionMapping</code>","text":"<p>Map Joint Intentions to/from mesh coordination.</p> <ul> <li>Mutual belief \u2192 consensus state (agreed-upon facts)</li> <li>Persistent goal \u2192 task with completion criteria</li> <li>Joint commitment \u2192 all agents assigned to same task</li> </ul>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.JointIntentionMapping.to_mesh","title":"<code>to_mesh(ji_state)</code>  <code>staticmethod</code>","text":"<p>Convert Joint Intention state to mesh state.</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.JointIntentionMapping.from_mesh","title":"<code>from_mesh(mesh)</code>  <code>staticmethod</code>","text":"<p>Convert mesh state to Joint Intention state.</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.SharedPlanState","title":"<code>SharedPlanState</code>  <code>dataclass</code>","text":"<p>SharedPlans state (Grosz &amp; Kraus).</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.SharedPlanState.recipe","title":"<code>recipe = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Task decomposition: parent_task \u2192 [subtasks]</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.SharedPlanState.task_descriptions","title":"<code>task_descriptions = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Task descriptions: task_id \u2192 description</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.SharedPlanState.subgroup_assignments","title":"<code>subgroup_assignments = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Subgroup plans: task_id \u2192 assigned agents</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.SharedPlanState.partial_plan","title":"<code>partial_plan = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether the plan is still being elaborated</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.SharedPlanMapping","title":"<code>SharedPlanMapping</code>","text":"<p>Map SharedPlans to/from mesh coordination.</p> <ul> <li>Recipe \u2192 task decomposition DAG</li> <li>Subgroup plans \u2192 agent cluster assignments</li> </ul>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.SharedPlanMapping.to_mesh","title":"<code>to_mesh(sp_state)</code>  <code>staticmethod</code>","text":"<p>Convert SharedPlan state to mesh state.</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.SharedPlanMapping.from_mesh","title":"<code>from_mesh(mesh)</code>  <code>staticmethod</code>","text":"<p>Convert mesh state to SharedPlan state.</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetPhase","title":"<code>ContractNetPhase</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Phases of the Contract Net Protocol.</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetPhase.ANNOUNCEMENT","title":"<code>ANNOUNCEMENT = 'announcement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Manager announces task (CFP)</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetPhase.BIDDING","title":"<code>BIDDING = 'bidding'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Bidders submit proposals</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetPhase.EVALUATION","title":"<code>EVALUATION = 'evaluation'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Manager evaluates bids</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetPhase.AWARDING","title":"<code>AWARDING = 'awarding'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Manager awards contract</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetPhase.EXECUTION","title":"<code>EXECUTION = 'execution'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Contractor executes task</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetPhase.REPORTING","title":"<code>REPORTING = 'reporting'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Contractor reports results</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetState","title":"<code>ContractNetState</code>  <code>dataclass</code>","text":"<p>Contract Net Protocol state.</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetState.manager","title":"<code>manager = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Manager agent ID</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetState.task","title":"<code>task = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Task being contracted</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetState.phase","title":"<code>phase = ContractNetPhase.ANNOUNCEMENT</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current phase</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetState.bids","title":"<code>bids = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Bids received: bidder_id \u2192 bid details</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetState.winner","title":"<code>winner = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Winning bidder</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetState.result","title":"<code>result = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Execution result</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetMapping","title":"<code>ContractNetMapping</code>","text":"<p>Map Contract Net Protocol to/from mesh coordination.</p> <ul> <li>Manager broadcasts CFP \u2192 task announcement message</li> <li>Bidders respond \u2192 agent capability advertisements</li> <li>Manager awards \u2192 task assignment</li> </ul>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetMapping.to_mesh","title":"<code>to_mesh(cn_state)</code>  <code>staticmethod</code>","text":"<p>Convert Contract Net state to mesh state.</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.ContractNetMapping.from_mesh","title":"<code>from_mesh(mesh)</code>  <code>staticmethod</code>","text":"<p>Convert mesh state to Contract Net state.</p>"},{"location":"api/specifications/mas-mappings/#agenticraft_foundation.specifications.mas_mappings.verify_mapping_preservation","title":"<code>verify_mapping_preservation(original_mesh, mapping_to, mapping_from, to_func='to_mesh', from_func='from_mesh')</code>","text":"<p>Verify that a MAS mapping preserves key properties.</p> <p>Checks: 1. Agent count is preserved 2. Task count is preserved 3. Assignment relationships are preserved</p> PARAMETER DESCRIPTION <code>original_mesh</code> <p>Original mesh state</p> <p> TYPE: <code>MeshState</code> </p> <code>mapping_to</code> <p>Mapping class with from_mesh method</p> <p> TYPE: <code>Any</code> </p> <code>mapping_from</code> <p>Mapping class with to_mesh method</p> <p> TYPE: <code>Any</code> </p> <code>to_func</code> <p>Name of the to_mesh method</p> <p> TYPE: <code>str</code> DEFAULT: <code>'to_mesh'</code> </p> <code>from_func</code> <p>Name of the from_mesh method</p> <p> TYPE: <code>str</code> DEFAULT: <code>'from_mesh'</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Verification results</p>"},{"location":"api/specifications/weighted-consensus/","title":"agenticraft_foundation.specifications.weighted_consensus_spec","text":"<p>Weighted quorum consensus \u2014 quality-weighted agents with \\(2W/3\\) quorum threshold for agreement, validity, and quorum intersection.</p> <p>Weighted Byzantine Fault Tolerance specifications.</p> <p>Extends consensus specifications with quality-weighted quorum consensus.</p> <p>Key concepts: - Each agent has a weight w_i based on historical reliability - Weighted quorum requires total weight &gt;= 2W/3 (not just count) - Weight-based leader rotation for liveness</p> <p>References: - Cachin et al. (2000) - Random oracles in Constantinople - Malkhi &amp; Reiter (1998) - Byzantine quorum systems</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedConsensusState","title":"<code>WeightedConsensusState</code>  <code>dataclass</code>","text":"<p>Consensus state with per-agent quality weights.</p> <p>Extends ConsensusState with weight information for quality-weighted quorum consensus.</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedConsensusState.consensus_state","title":"<code>consensus_state</code>  <code>instance-attribute</code>","text":"<p>Underlying consensus state</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedConsensusState.weights","title":"<code>weights = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Per-agent quality weights (w_i). Higher = more reliable.</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedConsensusState.weight_history","title":"<code>weight_history = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Historical weight records per agent</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedConsensusState.total_weight","title":"<code>total_weight</code>  <code>property</code>","text":"<p>Total weight W = sum(w_i).</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedConsensusState.quorum_threshold","title":"<code>quorum_threshold</code>  <code>property</code>","text":"<p>Weighted quorum threshold: 2W/3.</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedConsensusState.weight_of","title":"<code>weight_of(participant)</code>","text":"<p>Get weight of a participant (default 1.0).</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedConsensusState.weight_of_set","title":"<code>weight_of_set(participants)</code>","text":"<p>Get total weight of a set of participants.</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedConsensusState.is_quorum","title":"<code>is_quorum(participants)</code>","text":"<p>Check if a set of participants forms a weighted quorum.</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedConsensusState.decided_weight","title":"<code>decided_weight()</code>","text":"<p>Total weight of participants that have decided.</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedAgreement","title":"<code>WeightedAgreement</code>","text":"<p>               Bases: <code>FormalProperty[Any]</code></p> <p>Weighted Agreement: Correct processes with sufficient weight agree.</p> <p>For weighted quorum systems, agreement is enforced among processes whose combined weight exceeds the quorum threshold.</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedAgreement.__init__","title":"<code>__init__(min_agreement_weight=None)</code>","text":"<p>Initialize WeightedAgreement.</p> PARAMETER DESCRIPTION <code>min_agreement_weight</code> <p>Minimum combined weight for agreement. If None, uses 2W/3 threshold.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedAgreement.check","title":"<code>check(state, **kwargs)</code>","text":"<p>Check weighted agreement property.</p> <p>Accepts WeightedConsensusState via kwargs['weighted_state'] or wraps a regular ConsensusState with unit weights.</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedValidity","title":"<code>WeightedValidity</code>","text":"<p>               Bases: <code>FormalProperty[Any]</code></p> <p>Weighted Validity: Decided value was proposed by a weighted quorum.</p> <p>Strengthens standard validity \u2014 the decided value must have been proposed by a set of processes with sufficient combined weight.</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedValidity.__init__","title":"<code>__init__(min_proposal_weight=None)</code>","text":"<p>Initialize WeightedValidity.</p> PARAMETER DESCRIPTION <code>min_proposal_weight</code> <p>Minimum weight of proposers for validity. If None, any single proposer suffices (standard validity).</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedValidity.check","title":"<code>check(state, **kwargs)</code>","text":"<p>Check weighted validity.</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedQuorum","title":"<code>WeightedQuorum</code>","text":"<p>               Bases: <code>FormalProperty[Any]</code></p> <p>Weighted Quorum intersection property.</p> <p>Verifies that any two quorums have sufficient intersection weight to guarantee agreement. For BFT: any two quorums must share honest weight &gt; W/3.</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedQuorum.__init__","title":"<code>__init__(byzantine_weight=0.0)</code>","text":"<p>Initialize WeightedQuorum.</p> PARAMETER DESCRIPTION <code>byzantine_weight</code> <p>Maximum total weight of Byzantine processes.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.WeightedQuorum.check","title":"<code>check(state, **kwargs)</code>","text":"<p>Check quorum intersection property.</p> <p>Verifies: For any two quorums Q1, Q2: weight(Q1 \u2229 Q2) &gt; byzantine_weight</p>"},{"location":"api/specifications/weighted-consensus/#agenticraft_foundation.specifications.weighted_consensus_spec.select_weighted_leader","title":"<code>select_weighted_leader(weighted_state, round_number)</code>","text":"<p>Select leader based on weight-proportional rotation.</p> <p>Higher-weight agents get selected more frequently.</p> PARAMETER DESCRIPTION <code>weighted_state</code> <p>Weighted consensus state</p> <p> TYPE: <code>WeightedConsensusState</code> </p> <code>round_number</code> <p>Current round number</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>ID of selected leader</p>"},{"location":"api/topology/","title":"topology","text":"<p>Spectral graph analysis for agent network topology \u2014 Laplacian decomposition, algebraic connectivity, bridge detection, and hypergraph group coordination.</p> <p>Network topology analysis for distributed systems.</p> <p>This module provides graph-theoretic tools for analyzing and optimizing network topologies in distributed systems.</p> <p>Key features: - Graph Laplacian spectral analysis - Algebraic connectivity (\u03bb\u2082) computation - Consensus convergence bounds - Connectivity analysis and fault tolerance verification</p>"},{"location":"api/topology/#submodules","title":"Submodules","text":"Module Description <code>laplacian</code> Laplacian matrix analysis, algebraic connectivity \\(\\lambda_2\\), consensus bounds <code>connectivity</code> Vertex/edge connectivity, bridge detection, component analysis <code>hypergraph</code> Hypergraph topology for group coordination with \\(L_H = D_v - H W D_e^{-1} H^T\\)"},{"location":"api/topology/connectivity/","title":"agenticraft_foundation.topology.connectivity","text":"<p>Graph connectivity analysis \u2014 vertex connectivity, edge connectivity, bridge detection, and connected components.</p> <p>Network connectivity analysis for distributed systems.</p> <p>This module provides tools for analyzing and verifying network connectivity properties important for distributed consensus and fault tolerance.</p> <p>Key concepts: - k-connectivity: Graph remains connected after removing any k-1 nodes - Vertex cuts: Minimum set of vertices whose removal disconnects the graph - Robustness: Ability to maintain connectivity under failures</p>"},{"location":"api/topology/connectivity/#agenticraft_foundation.topology.connectivity.ConnectivityAnalysis","title":"<code>ConnectivityAnalysis</code>  <code>dataclass</code>","text":"<p>Results of connectivity analysis.</p> ATTRIBUTE DESCRIPTION <code>is_connected</code> <p>Whether graph is connected</p> <p> TYPE: <code>bool</code> </p> <code>vertex_connectivity</code> <p>Minimum nodes to remove to disconnect (\u03ba)</p> <p> TYPE: <code>int</code> </p> <code>edge_connectivity</code> <p>Minimum edges to remove to disconnect (\u03bb)</p> <p> TYPE: <code>int</code> </p> <code>articulation_points</code> <p>Nodes whose removal disconnects the graph</p> <p> TYPE: <code>list[str]</code> </p> <code>bridges</code> <p>Edges whose removal disconnects the graph</p> <p> TYPE: <code>list[tuple[str, str]]</code> </p> <code>k_connected</code> <p>Maximum k for which graph is k-connected</p> <p> TYPE: <code>int</code> </p> <code>biconnected_components</code> <p>List of biconnected component node sets</p> <p> TYPE: <code>list[set[str]]</code> </p> <code>strongly_connected</code> <p>Whether graph is strongly connected (for directed)</p> <p> TYPE: <code>bool</code> </p> <code>weakly_connected</code> <p>Whether underlying undirected graph is connected</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/topology/connectivity/#agenticraft_foundation.topology.connectivity.ConnectivityAnalysis.summary","title":"<code>summary()</code>","text":"<p>Generate human-readable summary.</p>"},{"location":"api/topology/connectivity/#agenticraft_foundation.topology.connectivity.ConnectivityAnalysis.can_tolerate_failures","title":"<code>can_tolerate_failures(f)</code>","text":"<p>Check if graph can tolerate f node failures.</p> PARAMETER DESCRIPTION <code>f</code> <p>Number of failures</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if graph remains connected after f failures</p>"},{"location":"api/topology/connectivity/#agenticraft_foundation.topology.connectivity.FaultToleranceAnalysis","title":"<code>FaultToleranceAnalysis</code>  <code>dataclass</code>","text":"<p>Analysis of fault tolerance capabilities.</p> ATTRIBUTE DESCRIPTION <code>crash_tolerance</code> <p>Maximum crash failures tolerable (f &lt; n/2)</p> <p> TYPE: <code>int</code> </p> <code>byzantine_tolerance</code> <p>Maximum Byzantine failures (f &lt; n/3)</p> <p> TYPE: <code>int</code> </p> <code>critical_nodes</code> <p>Nodes whose failure most impacts connectivity</p> <p> TYPE: <code>list[str]</code> </p> <code>redundancy_score</code> <p>Score indicating redundancy level (0-1)</p> <p> TYPE: <code>float</code> </p> <code>suggested_redundancy</code> <p>Suggested edges to improve fault tolerance</p> <p> TYPE: <code>list[tuple[str, str]]</code> </p>"},{"location":"api/topology/connectivity/#agenticraft_foundation.topology.connectivity.FaultToleranceAnalysis.summary","title":"<code>summary()</code>","text":"<p>Generate human-readable summary.</p>"},{"location":"api/topology/connectivity/#agenticraft_foundation.topology.connectivity.ConnectivityAnalyzer","title":"<code>ConnectivityAnalyzer</code>","text":"<p>Analyzes network connectivity properties.</p>"},{"location":"api/topology/connectivity/#agenticraft_foundation.topology.connectivity.ConnectivityAnalyzer.__init__","title":"<code>__init__(graph)</code>","text":"<p>Initialize analyzer with graph.</p> PARAMETER DESCRIPTION <code>graph</code> <p>Network graph to analyze</p> <p> TYPE: <code>NetworkGraph</code> </p>"},{"location":"api/topology/connectivity/#agenticraft_foundation.topology.connectivity.ConnectivityAnalyzer.analyze","title":"<code>analyze()</code>","text":"<p>Perform full connectivity analysis.</p> RETURNS DESCRIPTION <code>ConnectivityAnalysis</code> <p>ConnectivityAnalysis with results</p>"},{"location":"api/topology/connectivity/#agenticraft_foundation.topology.connectivity.ConnectivityAnalyzer.analyze_fault_tolerance","title":"<code>analyze_fault_tolerance()</code>","text":"<p>Analyze fault tolerance capabilities.</p> RETURNS DESCRIPTION <code>FaultToleranceAnalysis</code> <p>FaultToleranceAnalysis with results</p>"},{"location":"api/topology/connectivity/#agenticraft_foundation.topology.connectivity.verify_consensus_requirements","title":"<code>verify_consensus_requirements(graph, fault_model='crash', f=1)</code>","text":"<p>Verify graph meets consensus requirements for given fault model.</p> PARAMETER DESCRIPTION <code>graph</code> <p>Network graph</p> <p> TYPE: <code>NetworkGraph</code> </p> <code>fault_model</code> <p>Type of failures (\"crash\" or \"byzantine\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'crash'</code> </p> <code>f</code> <p>Number of failures to tolerate</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>tuple[bool, str]</code> <p>Tuple of (meets_requirements, explanation)</p>"},{"location":"api/topology/hypergraph/","title":"agenticraft_foundation.topology.hypergraph","text":"<p>Hypergraph topology for group coordination \u2014 incidence matrices, hypergraph Laplacian \\(L_H = D_v - H W D_e^{-1} H^T\\), and group coordination metrics.</p> <p>Hypergraph extension for multi-agent group coordination.</p> <p>Extends the graph model with hyperedges that connect &gt;2 agents, enabling formal analysis of group communication patterns.</p> <p>Hypergraph H = (V, E_h) where each hyperedge e \u2208 E_h \u2286 2^V can connect any subset of vertices.</p> <p>Key features: - Hyperedge management for group coordination patterns - Hypergraph Laplacian: L_H = D_v - H W D_e^{-1} H^T - Group coordination analysis (consensus time for multi-party patterns) - Conversion from/to standard graphs</p> <p>References: - Zhou et al. (2006) - Learning with Hypergraphs - Agarwal et al. (2006) - Higher Order Learning with Graphs</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.Hyperedge","title":"<code>Hyperedge</code>  <code>dataclass</code>","text":"<p>A hyperedge connecting multiple nodes.</p> <p>Unlike standard edges, a hyperedge can connect any number of nodes, modeling group communication patterns (broadcast, scatter-gather, consensus).</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.Hyperedge.edge_id","title":"<code>edge_id</code>  <code>instance-attribute</code>","text":"<p>Unique hyperedge identifier</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.Hyperedge.nodes","title":"<code>nodes</code>  <code>instance-attribute</code>","text":"<p>Set of connected node IDs</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.Hyperedge.weight","title":"<code>weight = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hyperedge weight</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.Hyperedge.metadata","title":"<code>metadata = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Additional edge metadata</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.Hyperedge.degree","title":"<code>degree</code>  <code>property</code>","text":"<p>Hyperedge degree (number of nodes it connects).</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.Hyperedge.contains","title":"<code>contains(node_id)</code>","text":"<p>Check if a node is in this hyperedge.</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphAnalysis","title":"<code>HypergraphAnalysis</code>  <code>dataclass</code>","text":"<p>Results of hypergraph spectral analysis.</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphAnalysis.num_nodes","title":"<code>num_nodes</code>  <code>instance-attribute</code>","text":"<p>Number of nodes</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphAnalysis.num_hyperedges","title":"<code>num_hyperedges</code>  <code>instance-attribute</code>","text":"<p>Number of hyperedges</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphAnalysis.avg_hyperedge_degree","title":"<code>avg_hyperedge_degree</code>  <code>instance-attribute</code>","text":"<p>Average number of nodes per hyperedge</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphAnalysis.max_hyperedge_degree","title":"<code>max_hyperedge_degree</code>  <code>instance-attribute</code>","text":"<p>Maximum hyperedge degree</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphAnalysis.algebraic_connectivity","title":"<code>algebraic_connectivity</code>  <code>instance-attribute</code>","text":"<p>Algebraic connectivity (\u03bb\u2082) of hypergraph Laplacian</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphAnalysis.eigenvalues","title":"<code>eigenvalues</code>  <code>instance-attribute</code>","text":"<p>Eigenvalues of hypergraph Laplacian</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphAnalysis.consensus_bound","title":"<code>consensus_bound</code>  <code>instance-attribute</code>","text":"<p>Estimated consensus convergence time</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphAnalysis.is_connected","title":"<code>is_connected</code>  <code>instance-attribute</code>","text":"<p>Whether the hypergraph is connected</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork","title":"<code>HypergraphNetwork</code>","text":"<p>Hypergraph network for group coordination analysis.</p> <p>H = (V, E_h) with weighted hyperedges.</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork.nodes","title":"<code>nodes</code>  <code>property</code>","text":"<p>Get all nodes.</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork.hyperedges","title":"<code>hyperedges</code>  <code>property</code>","text":"<p>Get all hyperedges.</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork.add_node","title":"<code>add_node(node_id, metadata=None)</code>","text":"<p>Add a node to the hypergraph.</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork.add_hyperedge","title":"<code>add_hyperedge(edge_id, nodes, weight=1.0, metadata=None)</code>","text":"<p>Add a hyperedge connecting multiple nodes.</p> <p>All referenced nodes must exist. Missing nodes are auto-added.</p> PARAMETER DESCRIPTION <code>edge_id</code> <p>Unique edge identifier</p> <p> TYPE: <code>str</code> </p> <code>nodes</code> <p>Set of node IDs to connect</p> <p> TYPE: <code>set[str]</code> </p> <code>weight</code> <p>Edge weight</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>metadata</code> <p>Additional metadata</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Hyperedge</code> <p>The created Hyperedge</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork.remove_hyperedge","title":"<code>remove_hyperedge(edge_id)</code>","text":"<p>Remove a hyperedge.</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork.node_degree","title":"<code>node_degree(node_id)</code>","text":"<p>Get degree of a node (number of hyperedges it belongs to).</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork.node_weighted_degree","title":"<code>node_weighted_degree(node_id)</code>","text":"<p>Get weighted degree: sum of weights of incident hyperedges.</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork.incident_edges","title":"<code>incident_edges(node_id)</code>","text":"<p>Get hyperedges incident to a node.</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork.neighbors","title":"<code>neighbors(node_id)</code>","text":"<p>Get all nodes connected to a node via any hyperedge.</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork.is_connected","title":"<code>is_connected()</code>","text":"<p>Check if the hypergraph is connected via BFS.</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork.incidence_matrix","title":"<code>incidence_matrix()</code>","text":"<p>Compute incidence matrix H.</p> <p><code>H[v][e] = 1</code> if node v is in hyperedge e, 0 otherwise.</p> RETURNS DESCRIPTION <code>tuple[list[str], list[str], list[list[float]]]</code> <p>(node_ids, edge_ids, matrix H)</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork.laplacian_matrix","title":"<code>laplacian_matrix()</code>","text":"<p>Compute hypergraph Laplacian: L_H = D_v - H W D_e^{-1} H^T.</p> <p>Where: - D_v: diagonal node degree matrix - W: diagonal hyperedge weight matrix - D_e: diagonal hyperedge degree matrix - H: incidence matrix</p> RETURNS DESCRIPTION <code>tuple[list[str], list[list[float]]]</code> <p>(node_ids, Laplacian matrix)</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork.analyze","title":"<code>analyze()</code>","text":"<p>Perform spectral analysis of the hypergraph.</p> <p>Computes eigenvalues of the hypergraph Laplacian and derives connectivity and consensus convergence metrics.</p> RETURNS DESCRIPTION <code>HypergraphAnalysis</code> <p>HypergraphAnalysis with spectral properties</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork.from_graph","title":"<code>from_graph(edges, weights=None)</code>  <code>classmethod</code>","text":"<p>Create a hypergraph from a standard graph.</p> <p>Each edge becomes a 2-hyperedge.</p> PARAMETER DESCRIPTION <code>edges</code> <p>List of (source, target) pairs</p> <p> TYPE: <code>list[tuple[str, str]]</code> </p> <code>weights</code> <p>Optional edge weights</p> <p> TYPE: <code>dict[tuple[str, str], float] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>HypergraphNetwork</code> <p>HypergraphNetwork with 2-hyperedges</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork.clique_expansion","title":"<code>clique_expansion(groups, weights=None)</code>  <code>classmethod</code>","text":"<p>Create a hypergraph from clique groups.</p> <p>Each group of nodes becomes a hyperedge.</p> PARAMETER DESCRIPTION <code>groups</code> <p>List of node groups</p> <p> TYPE: <code>list[set[str]]</code> </p> <code>weights</code> <p>Optional weights per group</p> <p> TYPE: <code>list[float] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>HypergraphNetwork</code> <p>HypergraphNetwork</p>"},{"location":"api/topology/hypergraph/#agenticraft_foundation.topology.hypergraph.HypergraphNetwork.analyze_group_coordination","title":"<code>analyze_group_coordination()</code>","text":"<p>Analyze group coordination patterns.</p> <p>Returns metrics about how effectively the hypergraph supports multi-party coordination.</p>"},{"location":"api/topology/laplacian/","title":"agenticraft_foundation.topology.laplacian","text":"<p>Laplacian matrix analysis \u2014 spectral decomposition, algebraic connectivity (\\(\\lambda_2\\)), and consensus convergence bounds.</p> <p>Graph Laplacian analysis for network topology optimization.</p> <p>This module provides spectral analysis tools for understanding and optimizing distributed system topologies based on graph-theoretic principles.</p> <p>Key concepts: - Algebraic Connectivity (\u03bb\u2082): Second smallest eigenvalue of Laplacian - Fiedler Vector: Eigenvector corresponding to \u03bb\u2082 - Consensus Convergence: T = O(n log n / \u03bb\u2082)</p> <p>References: - Fiedler, M. (1973). Algebraic connectivity of graphs. - Olfati-Saber, R. (2006). Flocking for multi-agent dynamic systems.</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.TopologyType","title":"<code>TopologyType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Common network topology types.</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.Node","title":"<code>Node</code>  <code>dataclass</code>","text":"<p>A node in the network graph.</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>Unique identifier</p> <p> TYPE: <code>str</code> </p> <code>neighbors</code> <p>Set of neighbor node IDs</p> <p> TYPE: <code>set[str]</code> </p> <code>weight</code> <p>Optional weight for weighted graphs</p> <p> TYPE: <code>float</code> </p> <code>metadata</code> <p>Additional node metadata</p> <p> TYPE: <code>dict[str, Any]</code> </p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.Edge","title":"<code>Edge</code>  <code>dataclass</code>","text":"<p>An edge in the network graph.</p> ATTRIBUTE DESCRIPTION <code>source</code> <p>Source node ID</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>Target node ID</p> <p> TYPE: <code>str</code> </p> <code>weight</code> <p>Edge weight (default 1.0)</p> <p> TYPE: <code>float</code> </p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.LaplacianAnalysis","title":"<code>LaplacianAnalysis</code>  <code>dataclass</code>","text":"<p>Results of Laplacian spectral analysis.</p> ATTRIBUTE DESCRIPTION <code>num_nodes</code> <p>Number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> <code>num_edges</code> <p>Number of edges in the graph</p> <p> TYPE: <code>int</code> </p> <code>algebraic_connectivity</code> <p>Second smallest eigenvalue (\u03bb\u2082)</p> <p> TYPE: <code>float</code> </p> <code>spectral_gap</code> <p>Gap between \u03bb\u2081 and \u03bb\u2082</p> <p> TYPE: <code>float</code> </p> <code>fiedler_vector</code> <p>Eigenvector for \u03bb\u2082 (maps node ID to value)</p> <p> TYPE: <code>dict[str, float]</code> </p> <code>eigenvalues</code> <p>All eigenvalues in ascending order</p> <p> TYPE: <code>list[float]</code> </p> <code>consensus_bound</code> <p>Upper bound on consensus convergence time</p> <p> TYPE: <code>float</code> </p> <code>diameter_estimate</code> <p>Estimated graph diameter from spectral properties</p> <p> TYPE: <code>float</code> </p> <code>bottleneck_edges</code> <p>Edges with high Fiedler values (potential bottlenecks)</p> <p> TYPE: <code>list[tuple[str, str]]</code> </p> <code>suggested_edges</code> <p>Suggested edges to add for improved connectivity</p> <p> TYPE: <code>list[tuple[str, str]]</code> </p> <code>is_connected</code> <p>Whether the graph is connected</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.LaplacianAnalysis.summary","title":"<code>summary()</code>","text":"<p>Generate human-readable summary.</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.NetworkGraph","title":"<code>NetworkGraph</code>","text":"<p>Network graph for topology analysis.</p> <p>Provides methods for building and analyzing network topologies using graph Laplacian spectral analysis.</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.NetworkGraph.node_count","title":"<code>node_count</code>  <code>property</code>","text":"<p>Number of nodes.</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.NetworkGraph.edge_count","title":"<code>edge_count</code>  <code>property</code>","text":"<p>Number of edges.</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.NetworkGraph.__init__","title":"<code>__init__()</code>","text":"<p>Initialize empty graph.</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.NetworkGraph.add_node","title":"<code>add_node(node_id, weight=1.0, **metadata)</code>","text":"<p>Add a node to the graph.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Unique node identifier</p> <p> TYPE: <code>str</code> </p> <code>weight</code> <p>Node weight</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>**metadata</code> <p>Additional metadata</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Node</code> <p>The created Node</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.NetworkGraph.add_edge","title":"<code>add_edge(source, target, weight=1.0, bidirectional=True)</code>","text":"<p>Add an edge to the graph.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source node ID</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>Target node ID</p> <p> TYPE: <code>str</code> </p> <code>weight</code> <p>Edge weight</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>bidirectional</code> <p>If True, add edge in both directions</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Edge</code> <p>The created Edge</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.NetworkGraph.remove_node","title":"<code>remove_node(node_id)</code>","text":"<p>Remove a node and all its edges.</p> PARAMETER DESCRIPTION <code>node_id</code> <p>Node to remove</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if node was removed</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.NetworkGraph.get_node","title":"<code>get_node(node_id)</code>","text":"<p>Get a node by ID.</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.NetworkGraph.get_nodes","title":"<code>get_nodes()</code>","text":"<p>Get all nodes.</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.NetworkGraph.get_edges","title":"<code>get_edges()</code>","text":"<p>Get all edges.</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.NetworkGraph.analyze","title":"<code>analyze()</code>","text":"<p>Perform spectral analysis on the graph.</p> RETURNS DESCRIPTION <code>LaplacianAnalysis</code> <p>LaplacianAnalysis with spectral properties</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.NetworkGraph.create_ring","title":"<code>create_ring(n, node_prefix='node')</code>  <code>classmethod</code>","text":"<p>Create a ring topology.</p> PARAMETER DESCRIPTION <code>n</code> <p>Number of nodes</p> <p> TYPE: <code>int</code> </p> <code>node_prefix</code> <p>Prefix for node IDs</p> <p> TYPE: <code>str</code> DEFAULT: <code>'node'</code> </p> RETURNS DESCRIPTION <code>NetworkGraph</code> <p>NetworkGraph with ring topology</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.NetworkGraph.create_complete","title":"<code>create_complete(n, node_prefix='node')</code>  <code>classmethod</code>","text":"<p>Create a complete (fully connected) topology.</p> PARAMETER DESCRIPTION <code>n</code> <p>Number of nodes</p> <p> TYPE: <code>int</code> </p> <code>node_prefix</code> <p>Prefix for node IDs</p> <p> TYPE: <code>str</code> DEFAULT: <code>'node'</code> </p> RETURNS DESCRIPTION <code>NetworkGraph</code> <p>NetworkGraph with complete topology</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.NetworkGraph.create_star","title":"<code>create_star(n, node_prefix='node')</code>  <code>classmethod</code>","text":"<p>Create a star topology.</p> PARAMETER DESCRIPTION <code>n</code> <p>Number of nodes (including center)</p> <p> TYPE: <code>int</code> </p> <code>node_prefix</code> <p>Prefix for node IDs</p> <p> TYPE: <code>str</code> DEFAULT: <code>'node'</code> </p> RETURNS DESCRIPTION <code>NetworkGraph</code> <p>NetworkGraph with star topology</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.NetworkGraph.create_mesh","title":"<code>create_mesh(rows, cols, node_prefix='node')</code>  <code>classmethod</code>","text":"<p>Create a 2D mesh/grid topology.</p> PARAMETER DESCRIPTION <code>rows</code> <p>Number of rows</p> <p> TYPE: <code>int</code> </p> <code>cols</code> <p>Number of columns</p> <p> TYPE: <code>int</code> </p> <code>node_prefix</code> <p>Prefix for node IDs</p> <p> TYPE: <code>str</code> DEFAULT: <code>'node'</code> </p> RETURNS DESCRIPTION <code>NetworkGraph</code> <p>NetworkGraph with mesh topology</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.analyze_consensus_time","title":"<code>analyze_consensus_time(graph, epsilon=0.01)</code>","text":"<p>Estimate consensus convergence time.</p> <p>For linear consensus protocols, convergence time is bounded by: T = O(log(1/\u03b5) / \u03bb\u2082)</p> PARAMETER DESCRIPTION <code>graph</code> <p>Network graph to analyze</p> <p> TYPE: <code>NetworkGraph</code> </p> <code>epsilon</code> <p>Convergence tolerance</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.01</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Estimated convergence time</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.compare_topologies","title":"<code>compare_topologies(topologies)</code>","text":"<p>Compare multiple network topologies.</p> PARAMETER DESCRIPTION <code>topologies</code> <p>Dictionary mapping topology name to graph</p> <p> TYPE: <code>dict[str, NetworkGraph]</code> </p> RETURNS DESCRIPTION <code>dict[str, LaplacianAnalysis]</code> <p>Dictionary mapping topology name to analysis</p>"},{"location":"api/topology/laplacian/#agenticraft_foundation.topology.laplacian.optimal_topology_for_consensus","title":"<code>optimal_topology_for_consensus(n, max_edges=None)</code>","text":"<p>Find optimal topology for consensus with edge budget.</p> <p>If unconstrained, complete graph is optimal (\u03bb\u2082 = n). With edge constraints, we optimize for maximum \u03bb\u2082.</p> PARAMETER DESCRIPTION <code>n</code> <p>Number of nodes</p> <p> TYPE: <code>int</code> </p> <code>max_edges</code> <p>Maximum number of edges (None = unconstrained)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>tuple[NetworkGraph, LaplacianAnalysis]</code> <p>Tuple of (optimal graph, analysis)</p>"},{"location":"api/verification/","title":"verification","text":"<p>Verification tools for distributed systems: runtime invariant checking, structured counterexample generation, CTL temporal logic model checking, and probabilistic verification (DTMC).</p> <p>Verification tools for distributed systems.</p> <p>This module provides: - Runtime invariant checking and state transition monitoring - Structured counterexample generation for refinement/equivalence failures - CTL temporal logic model checking - Probabilistic verification (DTMC reachability, steady-state, expected steps)</p>"},{"location":"api/verification/#submodules","title":"Submodules","text":"Module Description <code>invariant_checker</code> Runtime state assertions, transition monitoring, violation tracking <code>counterexamples</code> Structured counterexample generation for refinement/equivalence failures <code>temporal</code> CTL formula AST and backward fixpoint model checking <code>probabilistic</code> DTMC reachability, steady-state distribution, expected steps"},{"location":"api/verification/counterexamples/","title":"agenticraft_foundation.verification.counterexamples","text":"<p>Structured counterexample generation for refinement and equivalence failures.</p> <p>Given a raw counterexample trace from refinement or equivalence checking, this module walks through both LTS step-by-step, identifies the exact divergence point, and produces human-readable explanations.</p> <p>Structured counterexample generation for refinement and equivalence failures.</p> <p>This module provides: - Annotated trace explanations showing exactly where and why verification fails - Divergence point identification in refinement failures - Distinguishing event analysis for equivalence failures</p> <p>Theory: Synchronized product of spec/impl LTS + BFS divergence search (Roscoe, 1994 - Theory and Practice of Concurrency).</p> <p>Given a refinement or equivalence failure with a raw counterexample trace, this module walks the trace through both LTS step-by-step, recording what each side can do at each point, and identifies the exact divergence.</p>"},{"location":"api/verification/counterexamples/#agenticraft_foundation.verification.counterexamples.StepStatus","title":"<code>StepStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Status of a single step in an annotated trace.</p>"},{"location":"api/verification/counterexamples/#agenticraft_foundation.verification.counterexamples.AnnotatedStep","title":"<code>AnnotatedStep</code>  <code>dataclass</code>","text":"<p>A single step in an annotated trace.</p> ATTRIBUTE DESCRIPTION <code>event</code> <p>The event performed at this step.</p> <p> TYPE: <code>Event</code> </p> <code>status</code> <p>Whether this step was OK or a VIOLATION.</p> <p> TYPE: <code>StepStatus</code> </p> <code>spec_available</code> <p>Events available in the spec LTS at this point.</p> <p> TYPE: <code>frozenset[Event]</code> </p> <code>impl_available</code> <p>Events available in the impl LTS at this point.</p> <p> TYPE: <code>frozenset[Event]</code> </p> <code>spec_states</code> <p>Set of spec state IDs after tau-closure at this point.</p> <p> TYPE: <code>frozenset[int]</code> </p> <code>impl_states</code> <p>Set of impl state IDs after tau-closure at this point.</p> <p> TYPE: <code>frozenset[int]</code> </p>"},{"location":"api/verification/counterexamples/#agenticraft_foundation.verification.counterexamples.CounterexampleExplanation","title":"<code>CounterexampleExplanation</code>  <code>dataclass</code>","text":"<p>Structured explanation of why a verification check failed.</p> <p>Provides a human-readable summary, an annotated trace showing each step's status, and the precise divergence point where spec and impl disagree.</p> ATTRIBUTE DESCRIPTION <code>summary</code> <p>Human-readable summary of the failure.</p> <p> TYPE: <code>str</code> </p> <code>annotated_trace</code> <p>List of annotated steps showing the trace walkthrough.</p> <p> TYPE: <code>list[AnnotatedStep]</code> </p> <code>divergence_point</code> <p>Index in the trace where divergence occurs, or -1 if the trace itself is the issue (e.g., empty trace divergence).</p> <p> TYPE: <code>int</code> </p> <code>spec_allowed</code> <p>Events the spec allows at the divergence point.</p> <p> TYPE: <code>frozenset[Event]</code> </p> <code>impl_attempted</code> <p>The event the impl attempted (or None for refusal issues).</p> <p> TYPE: <code>Event | None</code> </p> <code>failure_kind</code> <p>The kind of failure (\"trace\", \"failures\", \"equivalence\").</p> <p> TYPE: <code>str</code> </p> <code>raw_counterexample</code> <p>The original raw counterexample from the checker.</p> <p> TYPE: <code>Trace | Failure | None</code> </p>"},{"location":"api/verification/counterexamples/#agenticraft_foundation.verification.counterexamples.explain_refinement_failure","title":"<code>explain_refinement_failure(spec, impl, result)</code>","text":"<p>Generate a structured explanation for a refinement failure.</p> <p>Takes the raw counterexample from a refinement check and walks it through both spec and impl LTS, identifying the exact divergence point.</p> PARAMETER DESCRIPTION <code>spec</code> <p>The specification process or LTS.</p> <p> TYPE: <code>Process | LTS</code> </p> <code>impl</code> <p>The implementation process or LTS.</p> <p> TYPE: <code>Process | LTS</code> </p> <code>result</code> <p>The RefinementResult containing the raw counterexample.</p> <p> TYPE: <code>RefinementResult</code> </p> RETURNS DESCRIPTION <code>CounterexampleExplanation</code> <p>CounterexampleExplanation with annotated trace and divergence details.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If result indicates refinement holds (no failure to explain).</p>"},{"location":"api/verification/counterexamples/#agenticraft_foundation.verification.counterexamples.explain_equivalence_failure","title":"<code>explain_equivalence_failure(p, q, result)</code>","text":"<p>Generate a structured explanation for an equivalence failure.</p> <p>Takes the raw witness trace from an equivalence check and walks it through both LTS, identifying where the two processes first disagree.</p> PARAMETER DESCRIPTION <code>p</code> <p>The first process or LTS.</p> <p> TYPE: <code>Process | LTS</code> </p> <code>q</code> <p>The second process or LTS.</p> <p> TYPE: <code>Process | LTS</code> </p> <code>result</code> <p>The EquivalenceResult containing the raw witness.</p> <p> TYPE: <code>EquivalenceResult</code> </p> RETURNS DESCRIPTION <code>CounterexampleExplanation</code> <p>CounterexampleExplanation with annotated trace and divergence details.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If result indicates equivalence holds (no failure to explain).</p>"},{"location":"api/verification/counterexamples/#agenticraft_foundation.verification.counterexamples.find_minimal_counterexample","title":"<code>find_minimal_counterexample(spec, impl, max_trace_length=50)</code>","text":"<p>Find the shortest counterexample trace and explain it.</p> <p>Performs a BFS over the synchronized product of spec and impl LTS to find the shortest trace where they diverge.</p> PARAMETER DESCRIPTION <code>spec</code> <p>The specification process or LTS.</p> <p> TYPE: <code>Process | LTS</code> </p> <code>impl</code> <p>The implementation process or LTS.</p> <p> TYPE: <code>Process | LTS</code> </p> <code>max_trace_length</code> <p>Maximum trace length to search.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>CounterexampleExplanation | None</code> <p>CounterexampleExplanation for the shortest diverging trace,</p> <code>CounterexampleExplanation | None</code> <p>or None if impl refines spec up to max_trace_length.</p>"},{"location":"api/verification/invariant-checker/","title":"agenticraft_foundation.verification.invariant_checker","text":"<p>Runtime invariant checker \u2014 register invariants, check state transitions, track violations.</p> <p>Runtime invariant checking for distributed systems.</p> <p>This module provides tools for runtime verification of distributed system invariants, enabling early detection of protocol violations.</p> <p>Features: - State transition monitoring - Invariant assertion and logging - Violation reporting and debugging - Thread-safe concurrent access via RLock</p> Thread Safety <p>All mutable state in InvariantRegistry is protected by RLock, enabling safe concurrent invariant checking across threads.</p> <p>Version: 0.1.0 Date: 2025-12-20</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.ViolationSeverity","title":"<code>ViolationSeverity</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Severity levels for invariant violations.</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.Invariant","title":"<code>Invariant</code>  <code>dataclass</code>","text":"<p>A runtime invariant to be checked.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Descriptive name</p> <p> TYPE: <code>str</code> </p> <code>condition</code> <p>Function that returns True if invariant holds</p> <p> TYPE: <code>Callable[..., bool]</code> </p> <code>severity</code> <p>Severity level if violated</p> <p> TYPE: <code>ViolationSeverity</code> </p> <code>message</code> <p>Message to log on violation</p> <p> TYPE: <code>str</code> </p> <code>enabled</code> <p>Whether invariant checking is enabled</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.Invariant.check","title":"<code>check(*args, **kwargs)</code>","text":"<p>Check if invariant holds.</p> PARAMETER DESCRIPTION <code>*args</code> <p>Arguments to pass to condition</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Keyword arguments to pass to condition</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if invariant holds</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.Violation","title":"<code>Violation</code>  <code>dataclass</code>","text":"<p>Record of an invariant violation.</p> ATTRIBUTE DESCRIPTION <code>invariant_name</code> <p>Name of violated invariant</p> <p> TYPE: <code>str</code> </p> <code>severity</code> <p>Severity of violation</p> <p> TYPE: <code>ViolationSeverity</code> </p> <code>message</code> <p>Violation message</p> <p> TYPE: <code>str</code> </p> <code>context</code> <p>Context at time of violation</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>timestamp</code> <p>When violation occurred</p> <p> TYPE: <code>float</code> </p> <code>stack_trace</code> <p>Optional stack trace</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.InvariantRegistry","title":"<code>InvariantRegistry</code>","text":"<p>Registry for managing system invariants.</p> <p>Provides centralized management of invariants with checking and violation tracking.</p> Thread Safety <p>All mutable state is protected by RLock, enabling safe concurrent access from multiple threads. RLock is used (vs Lock) to allow re-entrant calls from violation handlers.</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.InvariantRegistry.__init__","title":"<code>__init__(name='default')</code>","text":"<p>Initialize registry.</p> PARAMETER DESCRIPTION <code>name</code> <p>Registry name for logging</p> <p> TYPE: <code>str</code> DEFAULT: <code>'default'</code> </p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.InvariantRegistry.register","title":"<code>register(name, condition, severity=ViolationSeverity.ERROR, message='')</code>","text":"<p>Register a new invariant.</p> <p>Thread-safe: Protected by RLock.</p> PARAMETER DESCRIPTION <code>name</code> <p>Unique name for invariant</p> <p> TYPE: <code>str</code> </p> <code>condition</code> <p>Function returning True if invariant holds</p> <p> TYPE: <code>Callable[..., bool]</code> </p> <code>severity</code> <p>Severity level if violated</p> <p> TYPE: <code>ViolationSeverity</code> DEFAULT: <code>ERROR</code> </p> <code>message</code> <p>Message to log on violation</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> RETURNS DESCRIPTION <code>Invariant</code> <p>The registered Invariant</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.InvariantRegistry.unregister","title":"<code>unregister(name)</code>","text":"<p>Unregister an invariant.</p> <p>Thread-safe: Protected by RLock.</p> PARAMETER DESCRIPTION <code>name</code> <p>Invariant name to remove</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if invariant was removed</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.InvariantRegistry.check","title":"<code>check(name, *args, context=None, **kwargs)</code>","text":"<p>Check a specific invariant.</p> <p>Thread-safe: Protected by RLock. The invariant condition is evaluated outside the lock to avoid blocking concurrent access during potentially long-running checks.</p> PARAMETER DESCRIPTION <code>name</code> <p>Invariant name to check</p> <p> TYPE: <code>str</code> </p> <code>*args</code> <p>Arguments to pass to invariant condition</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>context</code> <p>Additional context for violation reporting</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Keyword arguments to pass to condition</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if invariant holds</p> RAISES DESCRIPTION <code>KeyError</code> <p>If invariant not found</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.InvariantRegistry.check_all","title":"<code>check_all(*args, context=None, **kwargs)</code>","text":"<p>Check all registered invariants.</p> <p>Thread-safe: Iterates over a snapshot of invariant names.</p> PARAMETER DESCRIPTION <code>*args</code> <p>Arguments to pass to invariant conditions</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>context</code> <p>Additional context for violation reporting</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Keyword arguments to pass to conditions</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>List of violated invariant names</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.InvariantRegistry.on_violation","title":"<code>on_violation(handler)</code>","text":"<p>Register a violation handler.</p> <p>Thread-safe: Protected by RLock.</p> PARAMETER DESCRIPTION <code>handler</code> <p>Function to call on violation</p> <p> TYPE: <code>Callable[[Violation], None]</code> </p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.InvariantRegistry.get_violations","title":"<code>get_violations(since=None, severity=None)</code>","text":"<p>Get recorded violations.</p> <p>Thread-safe: Returns a snapshot copy of violations.</p> PARAMETER DESCRIPTION <code>since</code> <p>Only violations after this timestamp</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>severity</code> <p>Filter by severity level</p> <p> TYPE: <code>ViolationSeverity | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Violation]</code> <p>List of matching violations</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.InvariantRegistry.clear_violations","title":"<code>clear_violations()</code>","text":"<p>Clear all recorded violations.</p> <p>Thread-safe: Protected by RLock.</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.InvariantRegistry.enable","title":"<code>enable()</code>","text":"<p>Enable invariant checking.</p> <p>Thread-safe: Protected by RLock.</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.InvariantRegistry.disable","title":"<code>disable()</code>","text":"<p>Disable invariant checking.</p> <p>Thread-safe: Protected by RLock.</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.InvariantRegistry.stats","title":"<code>stats()</code>","text":"<p>Get checking statistics.</p> <p>Thread-safe: Returns a snapshot of statistics.</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Dictionary with check and violation counts</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.InvariantRegistry.record_violation","title":"<code>record_violation(violation)</code>","text":"<p>Record a violation directly.</p> <p>Thread-safe: Protected by RLock. Used by assert_invariant for direct violation recording.</p> PARAMETER DESCRIPTION <code>violation</code> <p>The violation to record.</p> <p> TYPE: <code>Violation</code> </p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.StateTransitionMonitor","title":"<code>StateTransitionMonitor</code>","text":"<p>Monitors state transitions and checks invariants.</p> <p>Useful for verifying state machine correctness.</p> Thread Safety <p>All mutable state is protected by RLock for safe concurrent access.</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.StateTransitionMonitor.current_state","title":"<code>current_state</code>  <code>property</code>","text":"<p>Get current state.</p> <p>Thread-safe: Protected by RLock.</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.StateTransitionMonitor.__init__","title":"<code>__init__(name='state_monitor', valid_transitions=None)</code>","text":"<p>Initialize monitor.</p> PARAMETER DESCRIPTION <code>name</code> <p>Monitor name</p> <p> TYPE: <code>str</code> DEFAULT: <code>'state_monitor'</code> </p> <code>valid_transitions</code> <p>Map of state to valid next states</p> <p> TYPE: <code>dict[str, set[str]] | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.StateTransitionMonitor.set_valid_transitions","title":"<code>set_valid_transitions(transitions)</code>","text":"<p>Set valid state transitions.</p> <p>Thread-safe: Protected by RLock.</p> PARAMETER DESCRIPTION <code>transitions</code> <p>Map of state to valid next states</p> <p> TYPE: <code>dict[str, set[str]]</code> </p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.StateTransitionMonitor.transition","title":"<code>transition(new_state)</code>","text":"<p>Record a state transition.</p> <p>Thread-safe: Protected by RLock.</p> PARAMETER DESCRIPTION <code>new_state</code> <p>The new state</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if transition is valid</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.StateTransitionMonitor.get_history","title":"<code>get_history()</code>","text":"<p>Get transition history.</p> <p>Thread-safe: Returns a copy of the history.</p> RETURNS DESCRIPTION <code>list[tuple[str, str, float]]</code> <p>List of (from_state, to_state, timestamp) tuples</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.StateTransitionMonitor.get_invalid_transitions","title":"<code>get_invalid_transitions()</code>","text":"<p>Get invalid transitions that occurred.</p> <p>Thread-safe: Returns a copy of invalid transitions.</p> RETURNS DESCRIPTION <code>list[tuple[str, str]]</code> <p>List of (from_state, to_state) tuples</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.StateTransitionMonitor.reset","title":"<code>reset()</code>","text":"<p>Reset monitor state.</p> <p>Thread-safe: Protected by RLock.</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.register_invariant","title":"<code>register_invariant(name, condition, severity=ViolationSeverity.ERROR, message='', registry=None)</code>","text":"<p>Register an invariant in the default or specified registry.</p> PARAMETER DESCRIPTION <code>name</code> <p>Unique name for invariant</p> <p> TYPE: <code>str</code> </p> <code>condition</code> <p>Function returning True if invariant holds</p> <p> TYPE: <code>Callable[..., bool]</code> </p> <code>severity</code> <p>Severity level if violated</p> <p> TYPE: <code>ViolationSeverity</code> DEFAULT: <code>ERROR</code> </p> <code>message</code> <p>Message to log on violation</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>registry</code> <p>Registry to use (default if None)</p> <p> TYPE: <code>InvariantRegistry | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Invariant</code> <p>The registered Invariant</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.check_invariant","title":"<code>check_invariant(name, *args, context=None, registry=None, **kwargs)</code>","text":"<p>Check an invariant in the default or specified registry.</p> PARAMETER DESCRIPTION <code>name</code> <p>Invariant name to check</p> <p> TYPE: <code>str</code> </p> <code>*args</code> <p>Arguments to pass to invariant condition</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>context</code> <p>Additional context for violation reporting</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>registry</code> <p>Registry to use (default if None)</p> <p> TYPE: <code>InvariantRegistry | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Keyword arguments to pass to condition</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if invariant holds</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.invariant","title":"<code>invariant(name, condition=None, severity=ViolationSeverity.ERROR, message='')</code>","text":"<p>Decorator to add invariant checking to a function.</p> <p>The invariant is checked before and after the function executes.</p> PARAMETER DESCRIPTION <code>name</code> <p>Invariant name</p> <p> TYPE: <code>str</code> </p> <code>condition</code> <p>Condition to check (receives function args)</p> <p> TYPE: <code>Callable[..., bool] | None</code> DEFAULT: <code>None</code> </p> <code>severity</code> <p>Severity level if violated</p> <p> TYPE: <code>ViolationSeverity</code> DEFAULT: <code>ERROR</code> </p> <code>message</code> <p>Message to log on violation</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P, R]], Callable[P, R]]</code> <p>Decorated function</p> Example <p>@invariant(     \"positive_balance\",     lambda self: self.balance &gt;= 0,     message=\"Balance cannot be negative\" ) def withdraw(self, amount):     self.balance -= amount</p>"},{"location":"api/verification/invariant-checker/#agenticraft_foundation.verification.invariant_checker.assert_invariant","title":"<code>assert_invariant(condition, message='Assertion failed', severity=ViolationSeverity.ERROR)</code>","text":"<p>Assert an invariant condition.</p> <p>Thread-safe: Uses thread-safe record_violation method.</p> PARAMETER DESCRIPTION <code>condition</code> <p>Condition that should be true</p> <p> TYPE: <code>bool</code> </p> <code>message</code> <p>Message if condition is false</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Assertion failed'</code> </p> <code>severity</code> <p>Severity of violation</p> <p> TYPE: <code>ViolationSeverity</code> DEFAULT: <code>ERROR</code> </p> RAISES DESCRIPTION <code>AssertionError</code> <p>If condition is false and severity is FATAL</p>"},{"location":"api/verification/probabilistic/","title":"agenticraft_foundation.verification.probabilistic","text":"<p>Probabilistic verification for Discrete-Time Markov Chains (DTMC).</p> <p>Provides DTMC representation, reachability probability computation, steady-state distribution, and expected steps analysis. Based on Hansson &amp; Jonsson (1994) and Baier &amp; Katoen Ch. 10.</p> <p>Probabilistic verification for Discrete-Time Markov Chains (DTMC).</p> <p>This module provides: - DTMC representation with labeled states and probabilistic transitions - Reachability probability computation (linear system solving) - Steady-state distribution (power iteration) - Expected steps to reach target states - DTMC validation (probability sum = 1.0 per state)</p> <p>Theory: Hansson &amp; Jonsson (1994), PCTL model checking. Algorithms from Baier &amp; Katoen, \"Principles of Model Checking\", Chapter 10.</p> <p>Key insight for LLM agents: agents are inherently stochastic. The LTS/CSP framework handles non-determinism (what CAN happen), but DTMC handles probability (how LIKELY things are). This module bridges the gap.</p> <p>Implementation uses pure Python (no numpy/scipy dependency): - Gaussian elimination for small systems (&lt; 100 states) - Value iteration fallback for larger systems</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.ProbabilisticTransition","title":"<code>ProbabilisticTransition</code>  <code>dataclass</code>","text":"<p>A probabilistic transition: source \u2500p\u2192 target.</p> ATTRIBUTE DESCRIPTION <code>source</code> <p>Source state ID.</p> <p> TYPE: <code>int</code> </p> <code>target</code> <p>Target state ID.</p> <p> TYPE: <code>int</code> </p> <code>probability</code> <p>Transition probability (0 &lt; p &lt;= 1).</p> <p> TYPE: <code>float</code> </p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.DTMCState","title":"<code>DTMCState</code>  <code>dataclass</code>","text":"<p>A state in a DTMC.</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>State identifier.</p> <p> TYPE: <code>int</code> </p> <code>labels</code> <p>Set of atomic propositions holding in this state.</p> <p> TYPE: <code>set[str]</code> </p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.DTMC","title":"<code>DTMC</code>  <code>dataclass</code>","text":"<p>Discrete-Time Markov Chain.</p> <p>A DTMC is a tuple (S, P, \u03b9, AP, L) where: - S: finite set of states - P: S \u00d7 S \u2192 [0,1] transition probability matrix - \u03b9: initial distribution (here: single initial state) - AP: set of atomic propositions - L: S \u2192 2^AP labeling function</p> ATTRIBUTE DESCRIPTION <code>states</code> <p>Mapping from state IDs to DTMCState objects.</p> <p> TYPE: <code>dict[int, DTMCState]</code> </p> <code>transitions</code> <p>List of probabilistic transitions.</p> <p> TYPE: <code>list[ProbabilisticTransition]</code> </p> <code>initial_state</code> <p>ID of the initial state.</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.DTMC.num_states","title":"<code>num_states</code>  <code>property</code>","text":"<p>Number of states.</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.DTMC.num_transitions","title":"<code>num_transitions</code>  <code>property</code>","text":"<p>Number of transitions.</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.DTMC.add_state","title":"<code>add_state(state_id, labels=None)</code>","text":"<p>Add a state to the DTMC.</p> PARAMETER DESCRIPTION <code>state_id</code> <p>Unique state identifier.</p> <p> TYPE: <code>int</code> </p> <code>labels</code> <p>Set of atomic propositions for this state.</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DTMCState</code> <p>The created DTMCState.</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.DTMC.add_transition","title":"<code>add_transition(source, target, probability)</code>","text":"<p>Add a probabilistic transition.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source state ID.</p> <p> TYPE: <code>int</code> </p> <code>target</code> <p>Target state ID.</p> <p> TYPE: <code>int</code> </p> <code>probability</code> <p>Transition probability (must be in (0, 1]).</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>ProbabilisticTransition</code> <p>The created ProbabilisticTransition.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If probability is not in (0, 1] or states don't exist.</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.DTMC.get_transitions_from","title":"<code>get_transitions_from(state_id)</code>","text":"<p>Get all transitions from a state.</p> PARAMETER DESCRIPTION <code>state_id</code> <p>The source state.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>list[ProbabilisticTransition]</code> <p>List of transitions from the state.</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.DTMC.get_transition_probability","title":"<code>get_transition_probability(source, target)</code>","text":"<p>Get the probability of transitioning from source to target.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source state ID.</p> <p> TYPE: <code>int</code> </p> <code>target</code> <p>Target state ID.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Transition probability, or 0.0 if no transition exists.</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.DTMC.successors","title":"<code>successors(state_id)</code>","text":"<p>Get successor states with their probabilities.</p> PARAMETER DESCRIPTION <code>state_id</code> <p>The source state.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>list[tuple[int, float]]</code> <p>List of (target_state, probability) tuples.</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.DTMC.states_with_label","title":"<code>states_with_label(label)</code>","text":"<p>Get all states with a given label.</p> PARAMETER DESCRIPTION <code>label</code> <p>The atomic proposition to search for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>set[int]</code> <p>Set of state IDs with the given label.</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.DTMC.states_with_labels","title":"<code>states_with_labels(labels)</code>","text":"<p>Get all states with any of the given labels.</p> PARAMETER DESCRIPTION <code>labels</code> <p>Set of atomic propositions.</p> <p> TYPE: <code>set[str]</code> </p> RETURNS DESCRIPTION <code>set[int]</code> <p>Set of state IDs with at least one of the given labels.</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.DTMC.is_absorbing","title":"<code>is_absorbing(state_id)</code>","text":"<p>Check if a state is absorbing (self-loop with probability 1).</p> PARAMETER DESCRIPTION <code>state_id</code> <p>The state to check.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the state is absorbing.</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.DTMC.validate","title":"<code>validate()</code>","text":"<p>Validate the DTMC.</p> <p>Checks that: 1. All states have outgoing transitions 2. Outgoing probabilities sum to 1.0 for each state 3. All transition targets exist</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the DTMC is malformed.</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.ProbabilisticResult","title":"<code>ProbabilisticResult</code>  <code>dataclass</code>","text":"<p>Result of a probabilistic verification query.</p> ATTRIBUTE DESCRIPTION <code>probability</code> <p>The probability for the initial state.</p> <p> TYPE: <code>float</code> </p> <code>per_state</code> <p>Probability for each state.</p> <p> TYPE: <code>dict[int, float]</code> </p> <code>is_certain</code> <p>True if probability is 1.0.</p> <p> TYPE: <code>bool</code> </p> <code>is_impossible</code> <p>True if probability is 0.0.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.ProbabilisticResult.is_certain","title":"<code>is_certain</code>  <code>property</code>","text":"<p>True if probability is 1.0 (within tolerance).</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.ProbabilisticResult.is_impossible","title":"<code>is_impossible</code>  <code>property</code>","text":"<p>True if probability is 0.0 (within tolerance).</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.SteadyStateResult","title":"<code>SteadyStateResult</code>  <code>dataclass</code>","text":"<p>Result of steady-state distribution computation.</p> ATTRIBUTE DESCRIPTION <code>distribution</code> <p>Mapping from state ID to steady-state probability.</p> <p> TYPE: <code>dict[int, float]</code> </p> <code>converged</code> <p>Whether the computation converged.</p> <p> TYPE: <code>bool</code> </p> <code>iterations</code> <p>Number of iterations used.</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.ExpectedStepsResult","title":"<code>ExpectedStepsResult</code>  <code>dataclass</code>","text":"<p>Result of expected steps computation.</p> ATTRIBUTE DESCRIPTION <code>expected</code> <p>Expected number of steps from the initial state.</p> <p> TYPE: <code>float</code> </p> <code>per_state</code> <p>Expected steps from each state.</p> <p> TYPE: <code>dict[int, float]</code> </p> <code>is_infinite</code> <p>True if target is unreachable (infinite expected steps).</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.ExpectedStepsResult.is_infinite","title":"<code>is_infinite</code>  <code>property</code>","text":"<p>True if expected steps is infinite.</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.check_reachability","title":"<code>check_reachability(dtmc, target_labels=None, target_states=None)</code>","text":"<p>Compute reachability probabilities for target states.</p> <p>Computes Pr(\u25c7 target) \u2014 the probability of eventually reaching a state with the given labels, from each state.</p> <p>The algorithm: 1. Partition states into:    - target states: prob = 1.0    - states that can't reach target: prob = 0.0    - remaining: solve linear system p(s) = \u03a3 P(s,s') \u00d7 p(s') 2. Solve via Gaussian elimination (small) or value iteration (large).</p> PARAMETER DESCRIPTION <code>dtmc</code> <p>The DTMC to analyze.</p> <p> TYPE: <code>DTMC</code> </p> <code>target_labels</code> <p>Labels identifying target states (at least one must match).</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> <code>target_states</code> <p>Explicit set of target state IDs. If both are given, the union is used.</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ProbabilisticResult</code> <p>ProbabilisticResult with probabilities per state.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If neither target_labels nor target_states is provided.</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.steady_state","title":"<code>steady_state(dtmc, max_iterations=_MAX_ITERATIONS)</code>","text":"<p>Compute the steady-state (stationary) distribution.</p> <p>For ergodic chains, computes \u03c0 such that \u03c0 = \u03c0P. For absorbing chains, computes the absorption probabilities.</p> <p>Uses power iteration: \u03c0_{k+1} = \u03c0_k \u00d7 P.</p> PARAMETER DESCRIPTION <code>dtmc</code> <p>The DTMC.</p> <p> TYPE: <code>DTMC</code> </p> <code>max_iterations</code> <p>Maximum iterations for convergence.</p> <p> TYPE: <code>int</code> DEFAULT: <code>_MAX_ITERATIONS</code> </p> RETURNS DESCRIPTION <code>SteadyStateResult</code> <p>SteadyStateResult with distribution and convergence info.</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.expected_steps","title":"<code>expected_steps(dtmc, target_labels=None, target_states=None)</code>","text":"<p>Compute expected number of steps to reach target states.</p> <p>Solves: e(s) = 1 + \u03a3 P(s,s') \u00d7 e(s') for non-target states. Target states: e(s) = 0. States that can't reach target: e(s) = \u221e.</p> PARAMETER DESCRIPTION <code>dtmc</code> <p>The DTMC.</p> <p> TYPE: <code>DTMC</code> </p> <code>target_labels</code> <p>Labels identifying target states.</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> <code>target_states</code> <p>Explicit set of target state IDs.</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ExpectedStepsResult</code> <p>ExpectedStepsResult with expected steps per state.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If neither target_labels nor target_states is provided.</p>"},{"location":"api/verification/probabilistic/#agenticraft_foundation.verification.probabilistic.build_dtmc_from_lts","title":"<code>build_dtmc_from_lts(lts_states, lts_transitions, initial_state=0)</code>","text":"<p>Build a DTMC from explicit state/transition descriptions.</p> <p>Convenience function for creating DTMCs from dictionaries.</p> PARAMETER DESCRIPTION <code>lts_states</code> <p>Mapping from state ID to label sets.</p> <p> TYPE: <code>dict[int, set[str]]</code> </p> <code>lts_transitions</code> <p>Mapping from state ID to list of (target, probability) tuples.</p> <p> TYPE: <code>dict[int, list[tuple[int, float]]]</code> </p> <code>initial_state</code> <p>The initial state ID.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>DTMC</code> <p>A validated DTMC.</p>"},{"location":"api/verification/temporal/","title":"agenticraft_foundation.verification.temporal","text":"<p>CTL (Computation Tree Logic) temporal model checking over LTS.</p> <p>Provides a formula AST (Atomic, Not, And, Or, EX, EF, EG, EU, AX, AF, AG, AU) and bottom-up model checking via backward fixpoint computation. Based on Clarke &amp; Emerson (1981) and Baier &amp; Katoen Ch. 4 &amp; 6.</p> <p>CTL (Computation Tree Logic) temporal model checking.</p> <p>This module provides: - CTL formula AST (Atomic, Not, And, Or, EX, EF, EG, EU, AX, AF, AG, AU) - Bottom-up model checking via backward fixpoint computation - Counterexample trace generation for failing properties</p> <p>Theory: Clarke &amp; Emerson (1981), Turing Award 2007. Algorithms from Baier &amp; Katoen, \"Principles of Model Checking\", Chapters 4 (CTL) and 6 (fixpoint characterization).</p> <p>CTL Semantics (over Kripke structures / LTS): - EX \u03c6: there Exists a neXt state satisfying \u03c6 - AX \u03c6: All neXt states satisfy \u03c6 - EF \u03c6: there Exists a path where \u03c6 holds in some Future state - AF \u03c6: on All paths, \u03c6 holds in some Future state - EG \u03c6: there Exists a path where \u03c6 holds Globally - AG \u03c6: on All paths, \u03c6 holds Globally - E[\u03c6 U \u03c8]: there Exists a path where \u03c6 holds Until \u03c8 - A[\u03c6 U \u03c8]: on All paths, \u03c6 holds Until \u03c8</p> <p>The model checking algorithm evaluates formulas bottom-up: - Base case: Atomic propositions evaluated via labeling function - Boolean: set operations (complement, intersection, union) - EX: backward one-step (predecessors) - EF: least fixpoint via BFS backward from sat(\u03c6) - EG: greatest fixpoint via iterative removal - EU: least fixpoint combining sat(\u03c8) and EX - Universal quantifiers (AX, AF, AG, AU): defined as duals of existential</p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.Labeling","title":"<code>Labeling = dict[int, set[str]]</code>  <code>module-attribute</code>","text":"<p>Mapping from state IDs to sets of atomic proposition names.</p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.CTLFormula","title":"<code>CTLFormula</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for CTL formulas.</p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.Atomic","title":"<code>Atomic</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CTLFormula</code></p> <p>Atomic proposition: holds in states labeled with the given proposition.</p> ATTRIBUTE DESCRIPTION <code>prop</code> <p>The name of the atomic proposition.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.Not","title":"<code>Not</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CTLFormula</code></p> <p>Negation: \u00ac\u03c6.</p> ATTRIBUTE DESCRIPTION <code>formula</code> <p>The formula to negate.</p> <p> TYPE: <code>CTLFormula</code> </p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.And","title":"<code>And</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CTLFormula</code></p> <p>Conjunction: \u03c6 \u2227 \u03c8.</p> ATTRIBUTE DESCRIPTION <code>left</code> <p>Left conjunct.</p> <p> TYPE: <code>CTLFormula</code> </p> <code>right</code> <p>Right conjunct.</p> <p> TYPE: <code>CTLFormula</code> </p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.Or","title":"<code>Or</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CTLFormula</code></p> <p>Disjunction: \u03c6 \u2228 \u03c8.</p> ATTRIBUTE DESCRIPTION <code>left</code> <p>Left disjunct.</p> <p> TYPE: <code>CTLFormula</code> </p> <code>right</code> <p>Right disjunct.</p> <p> TYPE: <code>CTLFormula</code> </p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.Implies","title":"<code>Implies</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CTLFormula</code></p> <p>Implication: \u03c6 \u2192 \u03c8 (syntactic sugar for \u00ac\u03c6 \u2228 \u03c8).</p> ATTRIBUTE DESCRIPTION <code>left</code> <p>Antecedent.</p> <p> TYPE: <code>CTLFormula</code> </p> <code>right</code> <p>Consequent.</p> <p> TYPE: <code>CTLFormula</code> </p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.EX","title":"<code>EX</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CTLFormula</code></p> <p>EX \u03c6: there exists a next state satisfying \u03c6.</p> ATTRIBUTE DESCRIPTION <code>formula</code> <p>The formula that must hold in some successor.</p> <p> TYPE: <code>CTLFormula</code> </p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.EF","title":"<code>EF</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CTLFormula</code></p> <p>EF \u03c6: there exists a path where \u03c6 eventually holds.</p> <p>Equivalent to E[True U \u03c6].</p> ATTRIBUTE DESCRIPTION <code>formula</code> <p>The formula that must eventually hold.</p> <p> TYPE: <code>CTLFormula</code> </p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.EG","title":"<code>EG</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CTLFormula</code></p> <p>EG \u03c6: there exists a path where \u03c6 holds globally.</p> ATTRIBUTE DESCRIPTION <code>formula</code> <p>The formula that must hold on all states of some path.</p> <p> TYPE: <code>CTLFormula</code> </p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.EU","title":"<code>EU</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CTLFormula</code></p> <p>E[\u03c6 U \u03c8]: there exists a path where \u03c6 holds until \u03c8 holds.</p> ATTRIBUTE DESCRIPTION <code>left</code> <p>The formula that must hold until right holds.</p> <p> TYPE: <code>CTLFormula</code> </p> <code>right</code> <p>The formula that must eventually hold.</p> <p> TYPE: <code>CTLFormula</code> </p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.AX","title":"<code>AX</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CTLFormula</code></p> <p>AX \u03c6: all next states satisfy \u03c6.</p> <p>Equivalent to \u00acEX(\u00ac\u03c6).</p> ATTRIBUTE DESCRIPTION <code>formula</code> <p>The formula that must hold in all successors.</p> <p> TYPE: <code>CTLFormula</code> </p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.AF","title":"<code>AF</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CTLFormula</code></p> <p>AF \u03c6: on all paths, \u03c6 eventually holds.</p> <p>Equivalent to \u00acEG(\u00ac\u03c6).</p> ATTRIBUTE DESCRIPTION <code>formula</code> <p>The formula that must eventually hold on all paths.</p> <p> TYPE: <code>CTLFormula</code> </p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.AG","title":"<code>AG</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CTLFormula</code></p> <p>AG \u03c6: on all paths, \u03c6 holds globally.</p> <p>Equivalent to \u00acEF(\u00ac\u03c6).</p> ATTRIBUTE DESCRIPTION <code>formula</code> <p>The formula that must hold on all paths globally.</p> <p> TYPE: <code>CTLFormula</code> </p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.AU","title":"<code>AU</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CTLFormula</code></p> <p>A[\u03c6 U \u03c8]: on all paths, \u03c6 holds until \u03c8 holds.</p> ATTRIBUTE DESCRIPTION <code>left</code> <p>The formula that must hold until right holds.</p> <p> TYPE: <code>CTLFormula</code> </p> <code>right</code> <p>The formula that must eventually hold.</p> <p> TYPE: <code>CTLFormula</code> </p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.ModelCheckResult","title":"<code>ModelCheckResult</code>  <code>dataclass</code>","text":"<p>Result of CTL model checking.</p> ATTRIBUTE DESCRIPTION <code>satisfied</code> <p>Whether the formula holds in the initial state.</p> <p> TYPE: <code>bool</code> </p> <code>satisfying_states</code> <p>Set of states where the formula holds.</p> <p> TYPE: <code>set[int]</code> </p> <code>counterexample</code> <p>A trace to a violating state (if not satisfied), found via BFS from the initial state.</p> <p> TYPE: <code>Trace | None</code> </p> <code>formula</code> <p>The formula that was checked.</p> <p> TYPE: <code>CTLFormula | None</code> </p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.model_check","title":"<code>model_check(system, formula, labeling, max_counterexample_length=100)</code>","text":"<p>Check whether a CTL formula holds in the initial state of a system.</p> <p>Performs bottom-up evaluation of the formula over the LTS state space.</p> PARAMETER DESCRIPTION <code>system</code> <p>The system to check (CSP process or LTS).</p> <p> TYPE: <code>Process | LTS</code> </p> <code>formula</code> <p>The CTL formula to verify.</p> <p> TYPE: <code>CTLFormula</code> </p> <code>labeling</code> <p>Mapping from state IDs to sets of atomic propositions.</p> <p> TYPE: <code>Labeling</code> </p> <code>max_counterexample_length</code> <p>Maximum length for counterexample traces.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> RETURNS DESCRIPTION <code>ModelCheckResult</code> <p>ModelCheckResult with satisfaction status, satisfying states,</p> <code>ModelCheckResult</code> <p>and counterexample trace if the property fails.</p> Example <p>labeling = {0: {\"init\"}, 1: {\"processing\"}, 2: {\"done\"}} result = model_check(lts, AG(Not(Atomic(\"error\"))), labeling) result.satisfied True</p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.check_safety","title":"<code>check_safety(system, bad_prop, labeling)</code>","text":"<p>Check a safety property: AG(\u00acbad_prop).</p> <p>Convenience function for the common pattern of verifying that a \"bad\" state is never reached.</p> PARAMETER DESCRIPTION <code>system</code> <p>The system to check.</p> <p> TYPE: <code>Process | LTS</code> </p> <code>bad_prop</code> <p>Atomic proposition labeling \"bad\" states.</p> <p> TYPE: <code>str</code> </p> <code>labeling</code> <p>State labeling function.</p> <p> TYPE: <code>Labeling</code> </p> RETURNS DESCRIPTION <code>ModelCheckResult</code> <p>ModelCheckResult \u2014 satisfied means the bad state is unreachable.</p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.check_liveness","title":"<code>check_liveness(system, good_prop, labeling)</code>","text":"<p>Check a liveness property: AF(good_prop).</p> <p>Convenience function for verifying that a \"good\" state is eventually reached on all paths.</p> PARAMETER DESCRIPTION <code>system</code> <p>The system to check.</p> <p> TYPE: <code>Process | LTS</code> </p> <code>good_prop</code> <p>Atomic proposition labeling \"good\" states.</p> <p> TYPE: <code>str</code> </p> <code>labeling</code> <p>State labeling function.</p> <p> TYPE: <code>Labeling</code> </p> RETURNS DESCRIPTION <code>ModelCheckResult</code> <p>ModelCheckResult \u2014 satisfied means the good state is always eventually reached.</p>"},{"location":"api/verification/temporal/#agenticraft_foundation.verification.temporal.check_invariant","title":"<code>check_invariant(system, invariant_prop, labeling)</code>","text":"<p>Check an invariant property: AG(invariant_prop).</p> <p>Convenience function for verifying that a property holds in all reachable states.</p> PARAMETER DESCRIPTION <code>system</code> <p>The system to check.</p> <p> TYPE: <code>Process | LTS</code> </p> <code>invariant_prop</code> <p>Atomic proposition that should hold everywhere.</p> <p> TYPE: <code>str</code> </p> <code>labeling</code> <p>State labeling function.</p> <p> TYPE: <code>Labeling</code> </p> RETURNS DESCRIPTION <code>ModelCheckResult</code> <p>ModelCheckResult \u2014 satisfied means the invariant holds globally.</p>"},{"location":"concepts/","title":"Concepts Overview","text":"<p>AgentiCraft Foundation provides a formal methods substrate for building verifiable multi-agent systems. Rather than treating agents as opaque black boxes, the foundation layer models agent interactions using established formalisms from concurrency theory, session types, spectral graph theory, and distributed systems. Every coordination pattern, routing decision, and consensus protocol maps to a mathematically grounded primitive with provable properties.</p> <p>This section introduces the core theoretical concepts that underpin the library. Each page defines the key abstractions, shows how they map to code, and links to the corresponding API reference and tutorials.</p>"},{"location":"concepts/#concept-areas","title":"Concept Areas","text":"Concept Description Page Process Algebra (CSP) Hoare's Communicating Sequential Processes with 13 operators for modeling concurrent agent coordination process-algebra.md Multiparty Session Types Honda-Yoshida-Carbone formalism for specifying and verifying multi-party communication protocols session-types.md Protocol Graph Model Multi-protocol mesh modeled as a weighted graph with protocol-aware routing and transformation protocol-graph.md Spectral Topology Spectral graph theory applied to agent network analysis, consensus convergence, and hypergraph extensions spectral-topology.md Consensus &amp; MAS Mappings Formal consensus properties and bidirectional mappings to classical multi-agent systems theory consensus.md Complexity &amp; Fault Models Catalogued complexity bounds for distributed algorithms and fault models including LLM-specific failure modes complexity.md Verification Invariant checking, counterexample generation, CTL temporal logic, and probabilistic (DTMC) verification verification.md"},{"location":"concepts/#how-to-read-these-pages","title":"How to Read These Pages","text":"<p>Each concept page follows a consistent structure:</p> <ol> <li>Overview -- what the formalism is and why it matters for multi-agent systems</li> <li>Key Definitions -- precise mathematical definitions with notation</li> <li>How It Maps to Code -- import paths and usage examples</li> <li>Diagrams -- Mermaid visualizations of key workflows and hierarchies</li> <li>Further Reading -- links to API reference, tutorials, and foundational papers</li> </ol>"},{"location":"concepts/complexity/","title":"Complexity &amp; Fault Models","text":""},{"location":"concepts/complexity/#overview","title":"Overview","text":"<p>Distributed multi-agent systems operate under fundamental theoretical constraints. This page catalogues the complexity bounds for core distributed algorithms -- consensus, gossip, leader election, broadcast, and mesh communication -- and defines the fault models that govern failure behavior, including four LLM-specific failure modes that extend the classical taxonomy.</p> <p>Understanding these bounds is essential for choosing the right coordination strategy: some problems have provable lower bounds that no algorithm can beat, and some failure modes require specific architectural mitigations.</p>"},{"location":"concepts/complexity/#complexity-bounds","title":"Complexity Bounds","text":""},{"location":"concepts/complexity/#consensus","title":"Consensus","text":"Setting Metric Bound Notes Synchronous, crash failures Rounds \\(O(f + 1)\\) \\(f\\) = max crash failures; tight Synchronous, Byzantine Message complexity \\(\\Theta(n^2)\\) Quadratic message overhead unavoidable Asynchronous, crash (FLP) Deterministic Impossible No deterministic protocol solves consensus with even 1 crash failure Asynchronous, randomized Expected rounds \\(O(n)\\) Ben-Or's protocol; exponential in worst case Partially synchronous Rounds after GST \\(O(f + 1)\\) DLS/PBFT model; requires \\(n \\geq 3f + 1\\)"},{"location":"concepts/complexity/#gossip","title":"Gossip","text":"Setting Metric Bound Notes Random gossip (push) Rounds to converge \\(O(\\log n)\\) With high probability Random gossip (push-pull) Rounds to converge \\(O(\\log \\log n)\\) Doubly logarithmic -- very fast Total messages Messages \\(O(n \\log n)\\) Each round: \\(n\\) messages Diameter-bounded Rounds \\(O(D \\log n)\\) \\(D\\) = network diameter Byzantine gossip Messages \\(O(n^2 \\log n)\\) Needs authentication or signatures"},{"location":"concepts/complexity/#leader-election","title":"Leader Election","text":"Setting Metric Bound Notes Synchronous ring Messages \\(O(n)\\) LCR algorithm Asynchronous ring Messages \\(\\Omega(n \\log n)\\) Proven lower bound (Burns 1980) General network, async Messages \\(O(n \\log n)\\) GHS algorithm With unique IDs Messages \\(O(n)\\) If topology is known"},{"location":"concepts/complexity/#broadcast","title":"Broadcast","text":"Setting Metric Bound Notes Flooding Messages \\(O(n^2)\\) Every node forwards to all neighbors Spanning tree Messages \\(O(n)\\) After tree construction Spanning tree Rounds \\(O(\\log n)\\) for balanced tree \\(O(n)\\) worst case (path graph) Reliable broadcast (async) Messages \\(O(n^2)\\) Bracha's protocol Byzantine reliable broadcast Messages \\(O(n^2)\\) Requires \\(n \\geq 3f + 1\\)"},{"location":"concepts/complexity/#mesh-communication","title":"Mesh Communication","text":"Topology Messages per broadcast Rounds per broadcast Notes Full mesh \\(O(n)\\) \\(O(1)\\) Direct delivery Tree \\(O(n)\\) \\(O(\\log n)\\) balanced, \\(O(n)\\) worst Height-dependent Ring \\(O(n)\\) \\(O(n)\\) Sequential propagation Hypercube \\(O(n \\log n)\\) \\(O(\\log n)\\) Dimension-by-dimension \\(k\\)-regular expander \\(O(kn)\\) \\(O(\\log n)\\) Constant spectral gap"},{"location":"concepts/complexity/#fault-models","title":"Fault Models","text":""},{"location":"concepts/complexity/#classical-fault-models","title":"Classical Fault Models","text":"Model Description Behavior Crash-Stop Process halts permanently and does not recover Simplest model; process is either correct or stopped Crash-Recovery Process halts and may restart with stable storage intact Models transient failures; recovered process rejoins with persisted state Byzantine Process exhibits arbitrary behavior -- may send conflicting messages, lie, or collude Worst-case adversarial model; requires \\(n \\geq 3f + 1\\) to tolerate \\(f\\) faults Omission Process fails to send or receive some messages but otherwise behaves correctly Models network partitions and message loss"},{"location":"concepts/complexity/#llm-specific-fault-models","title":"LLM-Specific Fault Models","text":"<p>LLM-based agents exhibit failure modes that do not fit neatly into the classical taxonomy. AgentiCraft Foundation defines four additional fault models:</p> Model Description Classical Analog Mitigation Hallucination Agent produces confident but factually incorrect output Byzantine -- the output is wrong but indistinguishable from correct without external verification Ensemble voting, factual grounding, cross-agent verification Prompt Injection External input manipulates the agent's behavior, overriding instructions Byzantine -- the agent acts against its specification due to adversarial input Input sanitization, instruction hierarchy, session isolation Non-Determinism Same input produces different outputs across invocations Omission -- from the system's perspective, the expected output may not arrive Temperature control, majority voting, deterministic decoding Context Overflow Input exceeds the model's context window, causing truncation or failure Crash-Recovery -- the agent effectively crashes on that input but can recover on shorter inputs Context windowing, summarization, hierarchical decomposition"},{"location":"concepts/complexity/#fault-model-hierarchy","title":"Fault Model Hierarchy","text":"<p>The classical fault models form a strict hierarchy of increasing severity:</p> \\[\\text{Crash-Stop} \\subset \\text{Crash-Recovery} \\subset \\text{Omission} \\subset \\text{Byzantine}\\] <p>Any algorithm that tolerates Byzantine faults also tolerates all weaker fault models. The LLM-specific models map into this hierarchy at their analog positions but may require domain-specific detection mechanisms.</p>"},{"location":"concepts/complexity/#impossibility-results","title":"Impossibility Results","text":""},{"location":"concepts/complexity/#flp-impossibility-fischer-lynch-paterson-1985","title":"FLP Impossibility (Fischer, Lynch, Paterson 1985)","text":"<p>No deterministic consensus protocol can guarantee termination in an asynchronous system with even one crash failure.</p> <p>Formally: there is no deterministic algorithm that satisfies Agreement, Validity, and Termination simultaneously in an asynchronous message-passing system where at least one process may crash.</p> <p>This is a fundamental result. Practical systems work around FLP through:</p> <ul> <li>Randomization: Ben-Or's protocol achieves consensus with probability 1</li> <li>Failure detectors: Chandra-Toueg's unreliable failure detector \\(\\diamond S\\) is sufficient</li> <li>Partial synchrony: DLS model assumes the system is eventually synchronous after an unknown Global Stabilization Time (GST)</li> </ul>"},{"location":"concepts/complexity/#byzantine-fault-tolerance-bound","title":"Byzantine Fault Tolerance Bound","text":"<p>Tolerating \\(f\\) Byzantine faults requires at least \\(n \\geq 3f + 1\\) processes.</p> <p>This means: - 4 agents can tolerate 1 Byzantine fault - 7 agents can tolerate 2 Byzantine faults - In general, more than two-thirds of agents must be correct</p> <p>For LLM agents with hallucination faults (Byzantine analog), this translates to requiring at least 3 agents to detect 1 hallucinating agent via majority vote.</p>"},{"location":"concepts/complexity/#how-it-maps-to-code","title":"How It Maps to Code","text":"<pre><code>from agenticraft_foundation.complexity import (\n    CONSENSUS_BOUNDS, GOSSIP_BOUNDS, IMPOSSIBILITY_RESULTS,\n    FaultModel, validate_fault_tolerance,\n    consensus_complexity, get_impossibility,\n)\n\n# Query consensus complexity bounds\nfor bound in CONSENSUS_BOUNDS:\n    print(f\"{bound.algorithm}: {bound.time_complexity} ({bound.synchrony_model})\")\n\n# Analyze consensus complexity for a specific configuration\nanalysis = consensus_complexity(n_agents=7, fault_model=FaultModel.BYZANTINE)\nprint(f\"Message complexity: {analysis.message_complexity}\")\nprint(f\"Round complexity: {analysis.round_complexity}\")\n\n# Validate fault tolerance requirements\nresult = validate_fault_tolerance(\n    n_agents=7,\n    max_faults=2,\n    fault_model=FaultModel.BYZANTINE,\n)\nprint(f\"Tolerant: {result}\")  # True: 7 &gt;= 3*2 + 1\n\n# Check impossibility results\nflp = get_impossibility(\"FLP\")\nprint(f\"{flp.name}: {flp.description}\")\n</code></pre>"},{"location":"concepts/complexity/#further-reading","title":"Further Reading","text":"<ul> <li>API Reference: complexity/bounds</li> <li>Tutorial: Consensus Verification</li> </ul>"},{"location":"concepts/complexity/#references","title":"References","text":"<ul> <li>M.J. Fischer, N.A. Lynch, M.S. Paterson, \"Impossibility of Distributed Consensus with One Faulty Process,\" Journal of the ACM, 32(2), 1985.</li> <li>M. Castro, B. Liskov, \"Practical Byzantine Fault Tolerance,\" OSDI, 1999.</li> </ul>"},{"location":"concepts/consensus/","title":"Consensus &amp; MAS Mappings","text":""},{"location":"concepts/consensus/#overview","title":"Overview","text":"<p>Consensus is the fundamental problem in distributed systems: how do multiple agents agree on a single value despite failures, delays, and disagreements? AgentiCraft Foundation formalizes the four classical consensus properties, extends them with quality-weighted quorums for LLM-based agents, and provides bidirectional mappings to established multi-agent systems (MAS) theories -- BDI, Joint Intentions, SharedPlans, and Contract Net.</p>"},{"location":"concepts/consensus/#consensus-properties","title":"Consensus Properties","text":"<p>The four classical consensus properties, originally formalized for distributed processes, apply directly to multi-agent coordination.</p>"},{"location":"concepts/consensus/#agreement","title":"Agreement","text":"<p>No two correct processes decide differently.</p> \\[\\forall \\, p_i, p_j \\in \\text{Correct} : \\text{decision}(p_i) = \\text{decision}(p_j)\\] <p>In an agent mesh, this means all non-faulty agents converge on the same answer, plan, or action.</p>"},{"location":"concepts/consensus/#validity","title":"Validity","text":"<p>The decided value was proposed by some correct process.</p> \\[\\text{decision}(p_i) \\in \\{\\text{proposal}(p_j) \\mid p_j \\in \\text{Correct}\\}\\] <p>This prevents the consensus mechanism from inventing values -- the outcome must originate from an actual agent's proposal.</p>"},{"location":"concepts/consensus/#integrity","title":"Integrity","text":"<p>Every correct process decides at most once.</p> \\[\\forall \\, p_i \\in \\text{Correct} : |\\{\\text{decision}(p_i)\\}| \\leq 1\\] <p>Once an agent commits to a decision, it does not change its mind.</p>"},{"location":"concepts/consensus/#termination","title":"Termination","text":"<p>Every correct process eventually decides.</p> \\[\\forall \\, p_i \\in \\text{Correct} : \\exists \\, t : \\text{decided}(p_i, t) = \\text{true}\\] <p>The protocol does not run forever -- all correct agents reach a decision in bounded time (in synchronous systems) or with probability 1 (in randomized asynchronous systems).</p>"},{"location":"concepts/consensus/#weighted-consensus","title":"Weighted Consensus","text":"<p>In LLM-based multi-agent systems, not all agents are equally reliable. An agent with a history of accurate responses should carry more weight than one prone to hallucination. Weighted consensus assigns quality weights \\(w_i \\in [0, 1]\\) to each agent \\(i\\) based on historical reliability metrics, and requires weighted quorums rather than simple majorities.</p> <p>Let \\(W = \\sum_{i} w_i\\) be the total weight of all agents.</p>"},{"location":"concepts/consensus/#weighted-agreement","title":"Weighted Agreement","text":"<p>No two correct weighted quorums decide differently.</p> \\[\\forall \\, Q_1, Q_2 \\subseteq \\text{Correct} : \\left(\\sum_{i \\in Q_1} w_i &gt; \\frac{2W}{3} \\wedge \\sum_{j \\in Q_2} w_j &gt; \\frac{2W}{3}\\right) \\implies \\text{decision}(Q_1) = \\text{decision}(Q_2)\\]"},{"location":"concepts/consensus/#weighted-validity","title":"Weighted Validity","text":"<p>Decided values must come from proposals with sufficient aggregate weight.</p> \\[\\text{decision} \\in \\left\\{\\text{proposal}(p_j) \\;\\middle|\\; \\sum_{p_k \\in \\text{supporters}(p_j)} w_k &gt; \\frac{W}{3}\\right\\}\\]"},{"location":"concepts/consensus/#weighted-quorum-intersection","title":"Weighted Quorum Intersection","text":"<p>Any two quorums share an honest-majority overlap, ensuring conflicting decisions are impossible.</p> \\[\\forall \\, Q_1, Q_2 : \\sum_{i \\in Q_1 \\cap Q_2 \\cap \\text{Correct}} w_i &gt; \\frac{W}{3}\\] <p>This property is the weighted generalization of the classical requirement \\(n \\geq 3f + 1\\). It ensures that even if some high-weight agents are Byzantine, the overlap between any two quorums contains enough honest weight to prevent disagreement.</p>"},{"location":"concepts/consensus/#mas-theory-mappings","title":"MAS Theory Mappings","text":"<p>AgentiCraft Foundation provides bidirectional mappings between formal consensus primitives and four classical multi-agent systems theories. Each mapping preserves the formal properties of both sides -- consensus properties map to MAS invariants, and MAS constructs map to verifiable consensus configurations.</p> Theory Mapping Formal Preservation BDI (Belief-Desire-Intention) Beliefs \\(\\leftrightarrow\\) context state; Desires \\(\\leftrightarrow\\) task objectives; Intentions \\(\\leftrightarrow\\) active assignments Intention persistence \\(\\leftrightarrow\\) consensus integrity Joint Intentions (Cohen &amp; Levesque) Mutual belief \\(\\leftrightarrow\\) consensus state; Persistent goal \\(\\leftrightarrow\\) task completion condition Joint commitment \\(\\leftrightarrow\\) agreement property SharedPlans (Grosz &amp; Kraus) Recipe \\(\\leftrightarrow\\) task decomposition DAG; Subgroup plans \\(\\leftrightarrow\\) agent cluster assignments Plan completeness \\(\\leftrightarrow\\) termination property Contract Net (Smith 1980) Manager broadcasts CFP \\(\\leftrightarrow\\) proposal phase; Bidders respond \\(\\leftrightarrow\\) vote phase; Manager awards \\(\\leftrightarrow\\) decision phase; Execution reports \\(\\leftrightarrow\\) commitment Contract binding \\(\\leftrightarrow\\) validity property"},{"location":"concepts/consensus/#bdi-mapping","title":"BDI Mapping","text":"<p>The Belief-Desire-Intention architecture maps naturally to consensus:</p> <ul> <li>Beliefs are the agent's local state -- what it knows about the world and other agents. In consensus, this corresponds to the agent's view of proposed values and received messages.</li> <li>Desires are the agent's objectives. In a consensus context, the desire is to reach agreement on a value that satisfies the task.</li> <li>Intentions are the agent's committed plans. Once consensus is reached, the decided value becomes an intention that persists (integrity property).</li> </ul>"},{"location":"concepts/consensus/#joint-intentions-mapping","title":"Joint Intentions Mapping","text":"<p>Cohen and Levesque's Joint Intentions theory models how agents form and maintain shared commitments:</p> <ul> <li>Mutual belief corresponds to the consensus state -- all agents believe the same decided value.</li> <li>Persistent goal corresponds to the task completion condition -- agents maintain their commitment until the goal is achieved or known to be impossible.</li> </ul>"},{"location":"concepts/consensus/#sharedplans-mapping","title":"SharedPlans Mapping","text":"<p>Grosz and Kraus's SharedPlans theory models collaborative activity through hierarchical plan structures:</p> <ul> <li>Recipe (the plan structure) maps to the task decomposition DAG in a workflow.</li> <li>Subgroup plans map to agent cluster assignments -- which subset of agents is responsible for which subtask.</li> </ul>"},{"location":"concepts/consensus/#contract-net-mapping","title":"Contract Net Mapping","text":"<p>Smith's Contract Net Protocol maps directly to a single round of consensus:</p> <ul> <li>Manager broadcasts a Call For Proposals (CFP) -- analogous to the proposal phase</li> <li>Bidders respond with bids -- analogous to the voting phase</li> <li>Manager selects and awards -- analogous to the decision phase</li> <li>Execution and reporting -- analogous to the commitment phase</li> </ul>"},{"location":"concepts/consensus/#verification","title":"Verification","text":"<p>Each mapping is verified programmatically through <code>verify_mapping_preservation()</code>, which checks that the formal properties of the source theory are maintained through the mapping and back.</p>"},{"location":"concepts/consensus/#how-it-maps-to-code","title":"How It Maps to Code","text":"<pre><code>from agenticraft_foundation.specifications import (\n    ConsensusSpecification, ConsensusState,\n    Agreement, Validity, Integrity, Termination,\n    WeightedConsensusState, WeightedAgreement, WeightedValidity,\n    BDIMapping, JointIntentionMapping,\n    SharedPlanMapping, ContractNetMapping,\n    verify_mapping_preservation,\n)\n\n# Create a consensus specification and verify properties\nspec = ConsensusSpecification()\nstate = ConsensusState(\n    proposals={\"agent-0\": \"plan-A\", \"agent-1\": \"plan-A\", \"agent-2\": \"plan-B\"},\n    decisions={\"agent-0\": \"plan-A\", \"agent-1\": \"plan-A\", \"agent-2\": \"plan-A\"},\n)\n\n# Check the four classical properties\nagreement = Agreement()\nvalidity = Validity()\nassert agreement.check(state).status.name == \"SATISFIED\"\nassert validity.check(state).status.name == \"SATISFIED\"\n\n# Weighted consensus with quality-based agent weights\nweighted_state = WeightedConsensusState(\n    proposals={\"agent-0\": \"plan-A\", \"agent-1\": \"plan-A\", \"agent-2\": \"plan-B\"},\n    decisions={\"agent-0\": \"plan-A\", \"agent-1\": \"plan-A\", \"agent-2\": \"plan-A\"},\n    weights={\"agent-0\": 0.9, \"agent-1\": 0.7, \"agent-2\": 0.5},\n)\nw_agreement = WeightedAgreement()\nassert w_agreement.check(weighted_state).status.name == \"SATISFIED\"\n\n# Map to BDI theory and verify preservation\nbdi = BDIMapping()\nassert verify_mapping_preservation(bdi)\n</code></pre>"},{"location":"concepts/consensus/#further-reading","title":"Further Reading","text":"<ul> <li>API Reference: specifications/consensus, specifications/mas_mappings</li> <li>Tutorial: Consensus Verification</li> </ul>"},{"location":"concepts/process-algebra/","title":"Process Algebra (CSP)","text":""},{"location":"concepts/process-algebra/#overview","title":"Overview","text":"<p>Communicating Sequential Processes (CSP) is Tony Hoare's formalism for modeling concurrent systems that interact through message passing. In the context of multi-agent systems, CSP provides a rigorous way to specify how agents coordinate, synchronize, and communicate -- then verify that the resulting system is free of deadlocks, livelocks, and protocol violations.</p> <p>AgentiCraft Foundation implements 13 CSP operators covering core primitives, agent-specific extensions, and recursion. Every operator produces a process that can be compiled to a Labeled Transition System (LTS) for automated verification.</p>"},{"location":"concepts/process-algebra/#key-definitions","title":"Key Definitions","text":"<ul> <li> <p>Process: An abstract entity that engages in events drawn from its alphabet \\(\\alpha(P)\\). A process defines a set of possible behaviors.</p> </li> <li> <p>Event: An atomic, instantaneous action \\(a \\in \\Sigma\\) where \\(\\Sigma\\) is the universal event set.</p> </li> <li> <p>Trace: A finite sequence of events \\(t \\in \\Sigma^*\\). The set of all possible traces of process \\(P\\) is written \\(\\text{traces}(P)\\).</p> </li> <li> <p>Labeled Transition System (LTS): A tuple \\((S, \\Sigma, \\to, s_0)\\) where \\(S\\) is a set of states, \\(\\Sigma\\) is the event alphabet, \\(\\to \\subseteq S \\times \\Sigma \\times S\\) is the transition relation, and \\(s_0 \\in S\\) is the initial state.</p> </li> <li> <p>Deadlock: A state \\(s \\in S\\) with no outgoing transitions in the LTS. A deadlocked system can make no further progress.</p> </li> <li> <p>Refinement: Process \\(Q\\) refines process \\(P\\), written \\(P \\sqsubseteq Q\\), iff \\(\\text{traces}(Q) \\subseteq \\text{traces}(P)\\). This is trace refinement -- an implementation \\(Q\\) satisfies a specification \\(P\\) when every behavior of \\(Q\\) is permitted by \\(P\\).</p> </li> </ul>"},{"location":"concepts/process-algebra/#operators","title":"Operators","text":""},{"location":"concepts/process-algebra/#core-primitives-8","title":"Core Primitives (8)","text":"Operator Symbol Description Stop \\(\\text{STOP}\\) Deadlocked process -- engages in no events Skip \\(\\text{SKIP}\\) Successfully terminating process -- signals completion with \\(\\checkmark\\) Prefix \\(a \\to P\\) Engages in event \\(a\\) then behaves as \\(P\\) External Choice \\(P \\mathbin{[]} Q\\) Environment chooses between \\(P\\) and \\(Q\\) based on their initial events Internal Choice $P \\mathbin{ \\sim Parallel \\(P \\mathbin{\\|} Q\\) Processes execute concurrently, synchronizing on shared events Sequential \\(P \\mathbin{;} Q\\) Process \\(P\\) runs to completion, then \\(Q\\) begins Hiding \\(P \\mathbin{\\setminus} H\\) Events in set \\(H\\) become internal (invisible to the environment)"},{"location":"concepts/process-algebra/#agent-extensions-5","title":"Agent Extensions (5)","text":"Operator Symbol Description Interrupt \\(P \\mathbin{\\triangle} Q\\) Process \\(P\\) runs until \\(Q\\)'s initial event occurs, then control transfers to \\(Q\\) Timeout \\(\\text{Timeout}(P, d, Q)\\) If \\(P\\) does not engage in an event within duration \\(d\\), control transfers to \\(Q\\) Guard \\(\\text{Guard}(c, P)\\) Process \\(P\\) is only enabled when boolean condition \\(c\\) holds Rename \\(P[\\![a \\leftarrow b]\\!]\\) Renames event \\(a\\) to \\(b\\) in all traces of \\(P\\) Pipe $P \\mathbin{ &gt;} Q$"},{"location":"concepts/process-algebra/#recursion-2","title":"Recursion (2)","text":"Operator Symbol Description Recursion \\(\\mu X. P\\) Recursive process definition -- \\(X\\) within \\(P\\) refers back to the whole Variable \\(X\\) Bound variable referencing the enclosing recursive definition"},{"location":"concepts/process-algebra/#operator-hierarchy","title":"Operator Hierarchy","text":"<pre><code>graph LR\n    process([\"Process&lt;br/&gt;&lt;i&gt;abstract base&lt;/i&gt;\"])\n    subgraph primitives[\"Core Primitives\"]\n        direction TB\n        stop[\"STOP\"]\n        skip[\"SKIP \u2713\"]\n        pre[\"a \u2192 P\"]\n        ec[\"P \u25a1 Q\"]\n        ic[\"P \u2293 Q\"]\n        par[\"P \u2225 Q\"]\n        seq[\"P ; Q\"]\n        hid[\"P \u2216 H\"]\n    end\n    subgraph extensions[\"Agent Extensions\"]\n        direction TB\n        int[\"P \u25b3 Q\"]\n        tmo[\"Timeout(P, d, Q)\"]\n        grd[\"Guard(c, P)\"]\n        ren[\"P\u27e6a \u2190 b\u27e7\"]\n        pip[\"P |&gt; Q\"]\n    end\n    subgraph recursion_grp[\"Recursion\"]\n        direction TB\n        rec[\"\u03bcX. P\"]\n        var[\"X\"]\n    end\n    process --&gt; primitives\n    process --&gt; extensions\n    process --&gt; recursion_grp\n    style process fill:#0D9488,stroke:#0F766E,color:#fff\n    style primitives fill:#f0fdfa,stroke:#0D9488\n    style extensions fill:#f0fdfa,stroke:#14B8A6\n    style recursion_grp fill:#f0fdfa,stroke:#0D9488</code></pre>"},{"location":"concepts/process-algebra/#verification-pipeline","title":"Verification Pipeline","text":"<p>The verification pipeline compiles CSP processes into an LTS, then runs multiple analyses to establish correctness properties.</p> <pre><code>flowchart LR\n    P[\"CSP Process\"] --&gt; LTS[\"build_lts()\"]\n    LTS --&gt; DL[\"detect_deadlock()\"]\n    LTS --&gt; TR[\"traces()\"]\n    LTS --&gt; LV[\"analyze_liveness()\"]\n    TR --&gt; TE[\"trace_equivalent()\"]\n    TR --&gt; FR[\"failures_refines()\"]\n    TR --&gt; FD[\"fd_refines()\"]\n    TR --&gt; BS[\"strong_bisimilar()\"]\n    TE --&gt; V{{\"Verified \u2713\"}}\n    FR --&gt; V\n    FD --&gt; V\n    BS --&gt; V\n    DL --&gt; V\n    LV --&gt; V\n    style P fill:#0D9488,stroke:#0F766E,color:#fff\n    style LTS fill:#14B8A6,stroke:#0F766E,color:#fff\n    style V fill:#0D9488,stroke:#0F766E,color:#fff</code></pre> <p>Verification checks available:</p> <ul> <li>Deadlock Detection: Identifies states with no outgoing transitions. A deadlock-free system guarantees that agents never reach a state where no progress is possible.</li> <li>Trace Extraction: Enumerates all possible event sequences up to a configurable depth bound.</li> <li>Liveness Analysis: Checks that desired events are eventually reachable -- no agent starves.</li> <li>Trace Equivalence: Two processes are trace-equivalent iff they have identical trace sets.</li> <li>Failures Refinement: Strengthened refinement that also considers refusal sets -- what a process can refuse to do.</li> <li>FD Refinement: Failures-divergences refinement, the strongest standard CSP refinement ordering.</li> <li>Bisimulation: Structural equivalence -- two processes are bisimilar iff they can simulate each other step-by-step.</li> </ul>"},{"location":"concepts/process-algebra/#coordination-patterns","title":"Coordination Patterns","text":"<p>The CSP operators compose into standard multi-agent coordination patterns:</p> Pattern CSP Structure Description Request-Response \\(\\text{req} \\to \\text{resp} \\to \\text{SKIP}\\) Single synchronous exchange between two agents Pipeline $P_1 \\mathbin{ &gt;} P_2 \\mathbin{ Scatter-Gather \\((P_1 \\mathbin{\\|} P_2 \\mathbin{\\|} P_3) \\mathbin{;} \\text{collect}\\) Parallel fan-out to multiple agents, then collect results Barrier \\(P_1 \\mathbin{\\|} P_2\\) synchronized on \\(\\text{barrier}\\) All agents must reach a synchronization point before proceeding Mutex \\(\\text{acquire} \\to P \\mathbin{;} \\text{release} \\to \\text{SKIP}\\) Mutual exclusion -- only one agent accesses a shared resource at a time Producer-Consumer \\(\\text{produce} \\to \\text{consume} \\to \\mu X. P\\) Recurring handoff of work items between producer and consumer agents"},{"location":"concepts/process-algebra/#how-it-maps-to-code","title":"How It Maps to Code","text":"<pre><code>from agenticraft_foundation import (\n    Event, Prefix, Stop, Skip, ExternalChoice, InternalChoice,\n    Parallel, Sequential, Hiding, Interrupt, Timeout,\n    Guard, Rename, Pipe, Recursion, Variable,\n    build_lts, is_deadlock_free,\n)\n\n# Define a simple request-response process\nreq = Event(\"request\")\nresp = Event(\"response\")\nrequest_response = Sequential(\n    Prefix(req, Prefix(resp, Skip())),\n    Stop()\n)\n\n# Build the Labeled Transition System\nlts = build_lts(request_response)\n\n# Verify deadlock freedom\nassert is_deadlock_free(lts)\n</code></pre>"},{"location":"concepts/process-algebra/#further-reading","title":"Further Reading","text":"<ul> <li>API Reference: algebra/processes, algebra/semantics</li> <li>Tutorial: CSP Coordination Patterns</li> </ul>"},{"location":"concepts/process-algebra/#references","title":"References","text":"<ul> <li>C.A.R. Hoare, Communicating Sequential Processes, Prentice Hall, 1985.</li> <li>A.W. Roscoe, The Theory and Practice of Concurrency, Prentice Hall, 1998.</li> </ul>"},{"location":"concepts/protocol-graph/","title":"Protocol Graph Model","text":""},{"location":"concepts/protocol-graph/#overview","title":"Overview","text":"<p>The protocol graph models a multi-protocol agent mesh as a weighted, labeled graph. Each agent is a node with capabilities, each connection is an edge annotated with supported protocols, and routing algorithms navigate the graph while respecting protocol constraints and minimizing translation costs. The formal model is:</p> \\[G = (V, E, P, \\Phi, \\Gamma)\\] <p>This abstraction enables protocol-aware routing, automatic protocol translation, and workflow optimization across heterogeneous agent networks where different agents speak different protocols.</p>"},{"location":"concepts/protocol-graph/#key-definitions","title":"Key Definitions","text":"<ul> <li> <p>\\(V\\): Agent nodes. Each node \\(v \\in V\\) has a set of capabilities \\(\\text{caps}(v)\\) and a set of supported protocols \\(\\text{protos}(v) \\subseteq P\\).</p> </li> <li> <p>\\(E\\): Edges. Each edge \\((u, v) \\in E\\) represents a communication link between agents \\(u\\) and \\(v\\), with an associated weight \\(w(u, v) \\in \\mathbb{R}^+\\) representing latency or cost.</p> </li> <li> <p>\\(P\\): Protocol universe. The set of all protocols in the mesh, e.g., \\(P = \\{\\text{MCP}, \\text{A2A}, \\text{ANP}, \\ldots\\}\\).</p> </li> <li> <p>\\(\\Phi\\): Protocol assignment. A function \\(\\Phi : E \\to 2^P\\) mapping each edge to the set of protocols available on that link.</p> </li> <li> <p>\\(\\Gamma\\): Protocol affinity. A function \\(\\Gamma : V \\times P \\to [0, 1]\\) scoring how well each agent supports each protocol. An affinity of \\(1.0\\) means native support; lower values indicate degraded or translated support.</p> </li> </ul>"},{"location":"concepts/protocol-graph/#node-types","title":"Node Types","text":"Type Description Typical Protocols <code>LLM_AGENT</code> Language model agent with reasoning capabilities MCP, A2A <code>TOOL_SERVER</code> Stateless tool execution endpoint MCP <code>COORDINATOR</code> Orchestration node managing multi-agent workflows A2A, ANP <code>GATEWAY</code> Protocol translation bridge between network segments All protocols"},{"location":"concepts/protocol-graph/#routing-algorithms","title":"Routing Algorithms","text":"<p>Four routing algorithms are provided, each optimizing for a different objective.</p> Algorithm Class Strategy Complexity Dijkstra <code>ProtocolAwareDijkstra</code> Minimum-cost path with automatic protocol translation at boundaries \\(O((V + E) \\log V)\\) BFS <code>ProtocolConstrainedBFS</code> Minimum-hop path restricted to edges supporting a required protocol \\(O(V + E)\\) Resilient <code>ResilientRouter</code> Failover routing with degraded topology -- reroutes around failed nodes \\(O((V + E) \\log V)\\) Semantic <code>SemanticRouter</code> Capability-similarity matching weighted by protocol affinity \\(\\Gamma\\) \\(O(V \\cdot C)\\) where \\(C\\) is capability dimension <p>All routers return a <code>Route</code> object containing the path, total cost, protocol transitions, and any translations required.</p>"},{"location":"concepts/protocol-graph/#path-cost-function","title":"Path Cost Function","text":"<p>The cost of a route is defined by the path cost function (Definition 12):</p> \\[\\text{cost}(\\pi, \\sigma) = \\sum_{i} w_{e_i}(p_i) + \\sum_{i} \\tau(p_i, p_{i+1}, v_i)\\] <p>where:</p> <ul> <li>\\(\\pi = (v_0, v_1, \\ldots, v_k)\\) is the path through agents</li> <li>\\(\\sigma = (p_0, p_1, \\ldots, p_{k-1})\\) is the protocol used on each edge</li> <li>\\(w_{e_i}(p_i)\\) is the weight of edge \\(e_i = (v_i, v_{i+1})\\) using protocol \\(p_i\\)</li> <li>\\(\\tau(p_i, p_{i+1}, v_i)\\) is the translation cost incurred at node \\(v_i\\) when switching from protocol \\(p_i\\) to \\(p_{i+1}\\)</li> </ul> <p>The translation cost decomposes as \\(\\tau = \\tau_{\\text{base}} + \\tau_{\\text{semantic}}\\), where \\(\\tau_{\\text{base}}\\) is the fixed overhead and \\(\\tau_{\\text{semantic}}\\) penalizes information loss. When \\(p_i = p_{i+1}\\) (no protocol change), \\(\\tau = 0\\).</p>"},{"location":"concepts/protocol-graph/#protocol-transformers","title":"Protocol Transformers","text":"<p>When a message must cross a protocol boundary (e.g., from an MCP tool server to an A2A coordinator), a protocol transformer converts the message format.</p> <p>A transformer is a partial function:</p> \\[T : M_p \\to M_{p'} \\cup \\{\\bot\\}\\] <p>where \\(M_p\\) is the message space of protocol \\(p\\), \\(M_{p'}\\) is the message space of protocol \\(p'\\), and \\(\\bot\\) indicates a failed transformation (the message cannot be represented in the target protocol).</p>"},{"location":"concepts/protocol-graph/#transformer-classifications","title":"Transformer Classifications","text":"Classification Description Information Loss Lossless Bijective mapping -- no information lost or gained None Lossy Surjective mapping -- some metadata or structure is dropped Bounded Destructive Significant structural changes -- may alter semantics Unbounded"},{"location":"concepts/protocol-graph/#transformer-composition","title":"Transformer Composition","text":"<p>Transformers compose sequentially. A path requiring two protocol hops uses:</p> \\[T_{p \\to p''} = T_{p' \\to p''} \\circ T_{p \\to p'}\\] <p>The composition is valid only if neither component returns \\(\\bot\\). The total information loss is the sum of individual losses, making shorter protocol paths preferable.</p>"},{"location":"concepts/protocol-graph/#workflow-model","title":"Workflow Model","text":"<p>A workflow over the protocol graph is defined as:</p> \\[W = (T, \\prec, \\rho)\\] <p>where:</p> <ul> <li>\\(T = \\{t_1, t_2, \\ldots, t_n\\}\\) is a set of tasks</li> <li>\\(\\prec\\) is a partial order (precedence relation) forming a DAG over \\(T\\)</li> <li>\\(\\rho : T \\to P\\) is a protocol assignment mapping each task to a required protocol</li> </ul>"},{"location":"concepts/protocol-graph/#workflow-analysis","title":"Workflow Analysis","text":"<ul> <li> <p>WorkflowValidator: Checks that every task in \\(W\\) can be executed by at least one reachable agent supporting protocol \\(\\rho(t)\\). Reports unreachable tasks and missing capabilities.</p> </li> <li> <p>OptimalProtocolAssigner: Finds the protocol assignment \\(\\rho^*\\) that minimizes total translation cost across the workflow:</p> </li> </ul> <p>\\(\\(\\rho^* = \\arg\\min_\\rho \\sum_{(t_i, t_j) \\in \\prec} \\text{cost}(\\rho(t_i), \\rho(t_j))\\)\\)</p> <p>where \\(\\text{cost}(p, p')\\) is the translation cost between protocols \\(p\\) and \\(p'\\) (zero if \\(p = p'\\)).</p>"},{"location":"concepts/protocol-graph/#how-it-maps-to-code","title":"How It Maps to Code","text":"<pre><code>from agenticraft_foundation.types import ProtocolName\nfrom agenticraft_foundation.protocols import (\n    ProtocolGraph, AgentNode, NodeType, ProtocolEdge,\n    ProtocolAwareDijkstra, ProtocolConstrainedBFS,\n    ResilientRouter, SemanticRouter,\n)\n\n# Build a protocol graph\ngraph = ProtocolGraph()\ngraph.add_agent(AgentNode(\n    agent_id=\"llm-1\", node_type=NodeType.LLM_AGENT,\n    protocols={ProtocolName.MCP, ProtocolName.A2A},\n))\ngraph.add_agent(AgentNode(\n    agent_id=\"tool-1\", node_type=NodeType.TOOL_SERVER,\n    protocols={ProtocolName.MCP},\n))\ngraph.add_agent(AgentNode(\n    agent_id=\"coord-1\", node_type=NodeType.COORDINATOR,\n    protocols={ProtocolName.A2A},\n))\ngraph.add_edge(ProtocolEdge(\n    \"llm-1\", \"tool-1\", protocols={ProtocolName.MCP},\n))\ngraph.add_edge(ProtocolEdge(\n    \"llm-1\", \"coord-1\", protocols={ProtocolName.A2A},\n))\n\n# Route with protocol awareness\nrouter = ProtocolAwareDijkstra(graph)\nroute = router.find_route(source=\"tool-1\", target=\"coord-1\")\nprint(f\"Path: {route.path}, Cost: {route.total_cost}\")\n</code></pre>"},{"location":"concepts/protocol-graph/#further-reading","title":"Further Reading","text":"<ul> <li>API Reference: protocols/graph, protocols/routing, protocols/transforms</li> <li>Tutorial: Multi-Protocol Routing</li> </ul>"},{"location":"concepts/session-types/","title":"Multiparty Session Types","text":""},{"location":"concepts/session-types/#overview","title":"Overview","text":"<p>Multiparty Session Types (MPST) provide a type-theoretic framework for specifying and verifying communication protocols involving multiple participants. Where CSP models processes and their event traces, session types model the structure of message exchanges -- who sends what to whom, in what order, and with what payload types. This makes MPST particularly well-suited for specifying agent-to-agent protocols where correctness depends on all parties adhering to a shared communication contract.</p> <p>AgentiCraft Foundation implements the Honda-Yoshida-Carbone formalism with global type definition, per-role projection, well-formedness checking, and runtime session monitoring.</p>"},{"location":"concepts/session-types/#key-definitions","title":"Key Definitions","text":"<ul> <li>Global Type: A protocol specification from a bird's-eye view describing the complete message flow. A message exchange from participant \\(p\\) to participant \\(q\\) carrying payload type \\(T\\) is written:</li> </ul> <p>\\(\\(G = p \\to q : \\langle T \\rangle . G'\\)\\)</p> <p>where \\(G'\\) is the continuation of the protocol.</p> <ul> <li> <p>Local Type: The projected per-role view of the global protocol. Each participant sees only the sends and receives relevant to them.</p> </li> <li> <p>Projection: The operation \\(G \\upharpoonright r\\) maps a global type \\(G\\) to the local type for role \\(r\\). Projection extracts exactly the communication actions that involve role \\(r\\).</p> </li> <li> <p>Well-formedness: A global type is well-formed when:</p> </li> <li>No ambiguous choices (each branch is distinguishable by the receiving role)</li> <li>All roles participate correctly (no role is required to act on information it cannot observe)</li> <li> <p>The protocol is deadlock-free by construction</p> </li> <li> <p>Session Monitor: A runtime component that intercepts message exchanges and checks conformance against the local type. If an agent sends a message that violates the protocol, the monitor raises a violation before the message is delivered.</p> </li> <li> <p>Choice: A branching point where one role selects among labeled alternatives:</p> </li> </ul> <p>\\(\\(G = p \\to q : \\{l_1 : G_1, \\; l_2 : G_2, \\; \\ldots\\}\\)\\)</p> <p>Role \\(p\\) sends a label \\(l_i\\) to role \\(q\\), and the protocol continues as \\(G_i\\).</p> <ul> <li>Recursion: Protocols with repeated phases use recursive types:</li> </ul> <p>\\(\\(G = \\mu X. \\; p \\to q : \\langle T \\rangle . X\\)\\)</p>"},{"location":"concepts/session-types/#mpst-workflow","title":"MPST Workflow","text":"<pre><code>flowchart LR\n    G[\"Global Type\"] --&gt; P[\"Projection\"]\n    P --&gt; L1[\"Local Type (role A)\"]\n    P --&gt; L2[\"Local Type (role B)\"]\n    P --&gt; L3[\"Local Type (role C)\"]\n    L1 --&gt; M[\"Session Monitor\"]\n    L2 --&gt; M\n    L3 --&gt; M\n    M --&gt; V{{\"Runtime Verified\"}}\n    style G fill:#0D9488,stroke:#0F766E,color:#fff\n    style V fill:#0D9488,stroke:#0F766E,color:#fff</code></pre> <p>The workflow proceeds in two phases:</p> <ol> <li>Design time: Define the global type, project it to local types for each role, and check well-formedness. If projection succeeds, the protocol is guaranteed deadlock-free and type-safe by construction.</li> <li>Runtime: Session monitors attached to each agent enforce the local type. Every send and receive is checked against the expected next action in the local type.</li> </ol>"},{"location":"concepts/session-types/#communication-patterns","title":"Communication Patterns","text":""},{"location":"concepts/session-types/#request-response","title":"Request-Response","text":"<p>The simplest MPST pattern: one agent sends a request, another replies.</p> \\[G = \\text{client} \\to \\text{server} : \\langle \\text{Request} \\rangle . \\; \\text{server} \\to \\text{client} : \\langle \\text{Response} \\rangle . \\; \\text{end}\\]"},{"location":"concepts/session-types/#pipeline","title":"Pipeline","text":"<p>Sequential processing through a chain of agents, each forwarding a transformed result to the next.</p> \\[G = A \\to B : \\langle T_1 \\rangle . \\; B \\to C : \\langle T_2 \\rangle . \\; C \\to D : \\langle T_3 \\rangle . \\; \\text{end}\\]"},{"location":"concepts/session-types/#scatter-gather","title":"Scatter-Gather","text":"<p>A coordinator fans out work to multiple agents, then collects all results.</p> \\[G = \\text{coord} \\to W_1 : \\langle \\text{Task} \\rangle . \\; \\text{coord} \\to W_2 : \\langle \\text{Task} \\rangle . \\; W_1 \\to \\text{coord} : \\langle \\text{Result} \\rangle . \\; W_2 \\to \\text{coord} : \\langle \\text{Result} \\rangle . \\; \\text{end}\\]"},{"location":"concepts/session-types/#consensus","title":"Consensus","text":"<p>A multi-round protocol where agents exchange proposals and votes until agreement is reached.</p> \\[G = \\mu X. \\; \\text{proposer} \\to \\text{voter}_1 : \\langle \\text{Proposal} \\rangle . \\; \\text{proposer} \\to \\text{voter}_2 : \\langle \\text{Proposal} \\rangle . \\; \\text{voter}_1 \\to \\text{proposer} : \\langle \\text{Vote} \\rangle . \\; \\text{voter}_2 \\to \\text{proposer} : \\langle \\text{Vote} \\rangle . \\; \\text{proposer} \\to \\text{all} : \\{$$ $$\\quad \\text{commit} : \\text{end}, \\quad \\text{retry} : X$$ $$\\}\\]"},{"location":"concepts/session-types/#how-it-maps-to-code","title":"How It Maps to Code","text":"<pre><code>from agenticraft_foundation.mpst import (\n    MessageType, EndType,\n    project, WellFormednessChecker, SessionMonitor,\n)\n\n# Define a global type for request-response\nglobal_type = MessageType(\n    sender=\"client\",\n    receiver=\"server\",\n    payload=\"Request\",\n    continuation=MessageType(\n        sender=\"server\",\n        receiver=\"client\",\n        payload=\"Response\",\n        continuation=EndType(),\n    ),\n)\n\n# Project to local types\nclient_local = project(global_type, \"client\")\nserver_local = project(global_type, \"server\")\n\n# Check well-formedness\nchecker = WellFormednessChecker()\nresult = checker.check(global_type)\nassert result.is_well_formed\n\n# Attach runtime monitors\nclient_monitor = SessionMonitor(local_type=client_local)\nserver_monitor = SessionMonitor(local_type=server_local)\n</code></pre>"},{"location":"concepts/session-types/#further-reading","title":"Further Reading","text":"<ul> <li>API Reference: sessions/global_types, sessions/projection, sessions/monitors</li> <li>Tutorial: Session-Typed Protocols</li> </ul>"},{"location":"concepts/session-types/#references","title":"References","text":"<ul> <li>K. Honda, N. Yoshida, M. Carbone, \"Multiparty Asynchronous Session Types,\" Journal of the ACM, 63(1), 2016.</li> </ul>"},{"location":"concepts/spectral-topology/","title":"Spectral Topology","text":""},{"location":"concepts/spectral-topology/#overview","title":"Overview","text":"<p>Spectral graph theory provides a mathematical lens for analyzing the structure and dynamics of agent networks. The key insight is that the eigenvalues of the graph Laplacian encode fundamental properties of the network -- connectivity, robustness, and the speed at which agents can reach consensus. AgentiCraft Foundation uses spectral analysis to evaluate topology quality, predict consensus convergence times, and extend standard graph models to hypergraphs for group coordination.</p>"},{"location":"concepts/spectral-topology/#key-definitions","title":"Key Definitions","text":""},{"location":"concepts/spectral-topology/#graph-laplacian","title":"Graph Laplacian","text":"<p>For an undirected graph with \\(n\\) nodes, the graph Laplacian is the \\(n \\times n\\) matrix:</p> \\[L = D - A\\] <p>where \\(D\\) is the diagonal degree matrix (\\(D_{ii} = \\deg(i)\\)) and \\(A\\) is the adjacency matrix (\\(A_{ij} = 1\\) if nodes \\(i\\) and \\(j\\) are connected).</p> <p>The Laplacian is positive semidefinite, so its eigenvalues satisfy \\(0 = \\lambda_1 \\leq \\lambda_2 \\leq \\cdots \\leq \\lambda_n\\).</p>"},{"location":"concepts/spectral-topology/#algebraic-connectivity","title":"Algebraic Connectivity","text":"<p>The second-smallest eigenvalue \\(\\lambda_2(L)\\), called the algebraic connectivity or Fiedler value, characterizes the network:</p> <ul> <li>\\(\\lambda_2 &gt; 0\\) if and only if the graph is connected</li> <li>Larger \\(\\lambda_2\\) means the network is harder to disconnect (more robust)</li> <li>\\(\\lambda_2\\) directly governs how fast distributed consensus converges</li> </ul>"},{"location":"concepts/spectral-topology/#consensus-convergence","title":"Consensus Convergence","text":"<p>For a standard linear consensus protocol where agents iteratively average their values with neighbors, the convergence time is bounded by:</p> \\[T = O\\!\\left(\\frac{n \\log n}{\\lambda_2}\\right)\\] <p>This means networks with higher algebraic connectivity reach agreement faster. A full mesh (\\(\\lambda_2 = n\\)) converges in \\(O(\\log n)\\) rounds, while a ring (\\(\\lambda_2 \\approx 2(1 - \\cos(2\\pi/n))\\)) may require \\(O(n^2 \\log n)\\) rounds.</p>"},{"location":"concepts/spectral-topology/#topology-comparison","title":"Topology Comparison","text":"Topology \\(\\lambda_2\\) (typical) Consensus Speed Resilience Edge Count Full mesh \\(n\\) Fastest Highest -- tolerates up to \\(n-2\\) node failures \\(O(n^2)\\) Ring \\(\\approx 2(1 - \\cos(2\\pi/n))\\) Slow -- \\(O(n^2)\\) rounds Low -- single failure disconnects \\(O(n)\\) Star \\(1\\) Medium -- hub bottleneck Hub-dependent -- hub failure is catastrophic \\(O(n)\\) Grid (\\(\\sqrt{n} \\times \\sqrt{n}\\)) \\(\\approx 2(1 - \\cos(\\pi/\\sqrt{n}))\\) Moderate Moderate -- local failures contained \\(O(n)\\) Random (\\(p = \\log n / n\\)) \\(\\approx np - 2\\sqrt{np(1-p)}\\) Fast High -- probabilistically robust \\(O(n \\log n)\\) Expander \\(\\Theta(1)\\) Fast -- constant spectral gap High -- by definition \\(O(n)\\)"},{"location":"concepts/spectral-topology/#hypergraph-extension","title":"Hypergraph Extension","text":"<p>Standard graphs model pairwise connections. In multi-agent systems, many coordination patterns involve group interactions -- a broadcast to a team, a committee vote, or a shared workspace. Hypergraphs generalize graphs by allowing edges (called hyperedges) to connect arbitrary subsets of nodes.</p>"},{"location":"concepts/spectral-topology/#hypergraph-laplacian","title":"Hypergraph Laplacian","text":"<p>For a hypergraph with incidence matrix \\(H\\) (rows = nodes, columns = hyperedges), the hypergraph Laplacian is:</p> \\[L_H = D_v - H W D_e^{-1} H^T\\] <p>where:</p> <ul> <li>\\(H \\in \\{0, 1\\}^{|V| \\times |E_H|}\\) is the incidence matrix (\\(H_{ve} = 1\\) if node \\(v\\) belongs to hyperedge \\(e\\))</li> <li>\\(W \\in \\mathbb{R}^{|E_H| \\times |E_H|}\\) is a diagonal weight matrix for hyperedges</li> <li>\\(D_v \\in \\mathbb{R}^{|V| \\times |V|}\\) is the diagonal node degree matrix (\\(D_{v,ii} = \\sum_e W_{ee} H_{ie}\\))</li> <li>\\(D_e \\in \\mathbb{R}^{|E_H| \\times |E_H|}\\) is the diagonal hyperedge degree matrix (\\(D_{e,jj} = \\sum_v H_{vj}\\))</li> </ul> <p>The spectral properties of \\(L_H\\) generalize those of the standard Laplacian: \\(\\lambda_2(L_H) &gt; 0\\) implies the hypergraph is connected, and larger values indicate tighter group coordination.</p>"},{"location":"concepts/spectral-topology/#clique-expansion","title":"Clique Expansion","text":"<p>A hypergraph can be approximated by a standard graph through clique expansion: each hyperedge \\(e = \\{v_1, \\ldots, v_k\\}\\) is replaced by a clique (complete subgraph) on the same \\(k\\) nodes. This allows standard spectral tools to be applied, though it loses the distinction between pairwise and group interactions.</p>"},{"location":"concepts/spectral-topology/#how-it-maps-to-code","title":"How It Maps to Code","text":"<pre><code>from agenticraft_foundation.topology import (\n    NetworkGraph, HypergraphNetwork,\n)\n\n# Build a standard network graph (ring topology)\ngraph = NetworkGraph()\nfor i in range(5):\n    graph.add_node(str(i))\ngraph.add_edge(\"0\", \"1\")\ngraph.add_edge(\"1\", \"2\")\ngraph.add_edge(\"2\", \"3\")\ngraph.add_edge(\"3\", \"4\")\ngraph.add_edge(\"4\", \"0\")\n\n# Compute spectral properties via analyze()\nanalysis = graph.analyze()\nprint(f\"Algebraic connectivity: {analysis.algebraic_connectivity:.4f}\")\nprint(f\"Summary: {analysis.summary}\")\n\n# Hypergraph for group coordination\nhg = HypergraphNetwork()\nfor i in range(6):\n    hg.add_node(str(i))\nhg.add_hyperedge([\"0\", \"1\", \"2\"], weight=1.0)  # team A\nhg.add_hyperedge([\"3\", \"4\", \"5\"], weight=1.0)  # team B\nhg.add_hyperedge([\"2\", \"3\"], weight=0.5)        # bridge\n\n# Compute hypergraph Laplacian\nL_H = hg.laplacian_matrix()\n\n# Convert to standard graph for spectral analysis\nstandard_graph = hg.clique_expansion()\n</code></pre>"},{"location":"concepts/spectral-topology/#factory-constructors","title":"Factory Constructors","text":"<p>The <code>HypergraphNetwork</code> class provides factory constructors for common conversions:</p> <ul> <li><code>HypergraphNetwork.from_graph(graph)</code> -- promotes a standard graph to a hypergraph where each edge becomes a 2-node hyperedge</li> <li><code>HypergraphNetwork.clique_expansion(hypergraph)</code> -- converts a hypergraph to a standard graph via clique expansion</li> </ul>"},{"location":"concepts/spectral-topology/#further-reading","title":"Further Reading","text":"<ul> <li>API Reference: topology/laplacian, topology/hypergraph</li> <li>Tutorial: Topology Analysis for Agent Networks</li> </ul>"},{"location":"concepts/verification/","title":"Verification","text":""},{"location":"concepts/verification/#overview","title":"Overview","text":"<p>Verification is the process of establishing that a system satisfies desired properties before deployment. For multi-agent systems built on LLM agents, this is especially important: agents are nondeterministic, stochastic, and prone to failure modes that don't exist in traditional software (hallucination, context overflow, prompt injection).</p> <p>AgentiCraft Foundation provides 4 verification submodules that address complementary aspects of system correctness:</p> Submodule Question It Answers Formalism Invariant Checker Does the runtime state satisfy required properties? State predicates, transition monitoring Counterexamples Why does verification fail? Synchronized product LTS, BFS divergence search Temporal Logic Does the system satisfy \"always\", \"eventually\", \"until\" properties? CTL backward fixpoint (Clarke &amp; Emerson 1981) Probabilistic What is the probability of reaching a given state? DTMC reachability (Hansson &amp; Jonsson 1994)"},{"location":"concepts/verification/#key-definitions","title":"Key Definitions","text":"<ul> <li> <p>Invariant: A predicate \\(\\phi(s)\\) that must hold in every reachable state \\(s\\). Violation of an invariant indicates a bug.</p> </li> <li> <p>Counterexample: A concrete execution trace \\(t = \\langle a_1, a_2, \\ldots, a_k \\rangle\\) that demonstrates a property violation. A good counterexample is minimal -- no shorter trace exhibits the same violation.</p> </li> <li> <p>CTL Formula: A formula in Computation Tree Logic, interpreted over the states of an LTS. CTL combines path quantifiers (\\(\\mathbf{A}\\) -- all paths, \\(\\mathbf{E}\\) -- exists a path) with temporal operators (\\(\\mathbf{X}\\) -- next, \\(\\mathbf{F}\\) -- eventually, \\(\\mathbf{G}\\) -- globally, \\(\\mathbf{U}\\) -- until).</p> </li> <li> <p>DTMC: A Discrete-Time Markov Chain \\((S, P, \\iota, L)\\) where \\(S\\) is a finite set of states, \\(P: S \\times S \\to [0,1]\\) is a stochastic transition matrix (\\(\\sum_{s'} P(s,s') = 1\\)), \\(\\iota\\) is the initial distribution, and \\(L: S \\to 2^{AP}\\) is a labeling function.</p> </li> <li> <p>Reachability Probability: For target set \\(T \\subseteq S\\), the probability \\(\\Pr^s(\\Diamond T)\\) of eventually reaching \\(T\\) from state \\(s\\), computed by solving the linear system \\(p(s) = \\sum_{s'} P(s,s') \\cdot p(s')\\) with boundary conditions \\(p(s) = 1\\) for \\(s \\in T\\).</p> </li> </ul>"},{"location":"concepts/verification/#how-the-submodules-connect","title":"How the Submodules Connect","text":"<pre><code>flowchart TB\n    subgraph runtime[\"Runtime Verification\"]\n        inv[\"Invariant Checker&lt;br/&gt;&lt;i&gt;state predicates&lt;/i&gt;\"]\n    end\n\n    subgraph static[\"Static Verification\"]\n        ctl[\"CTL Model Checking&lt;br/&gt;&lt;i&gt;temporal properties&lt;/i&gt;\"]\n        prob[\"Probabilistic (DTMC)&lt;br/&gt;&lt;i&gt;reachability, steady-state&lt;/i&gt;\"]\n    end\n\n    subgraph diagnostics[\"Diagnostics\"]\n        cex[\"Counterexample Generation&lt;br/&gt;&lt;i&gt;structured failure explanations&lt;/i&gt;\"]\n    end\n\n    lts[\"LTS&lt;br/&gt;&lt;code&gt;build_lts(process)&lt;/code&gt;\"]\n    ref[\"Refinement&lt;br/&gt;&lt;code&gt;trace_refines, failures_refines&lt;/code&gt;\"]\n    eq[\"Equivalence&lt;br/&gt;&lt;code&gt;strong_bisimilar&lt;/code&gt;\"]\n\n    lts --&gt; ctl\n    lts --&gt; prob\n    ref --&gt;|\"failure\"| cex\n    eq --&gt;|\"failure\"| cex\n    ctl --&gt;|\"counterexample&lt;br/&gt;trace\"| cex\n    inv -.-&gt;|\"violation&lt;br/&gt;detected\"| cex\n\n    style runtime fill:#f0fdfa,stroke:#14B8A6\n    style static fill:#f0fdfa,stroke:#0D9488\n    style diagnostics fill:#f0fdfa,stroke:#0F766E\n    style lts fill:#0D9488,stroke:#0F766E,color:#fff</code></pre> <p>Runtime vs. static: The invariant checker monitors live system state (it's a runtime tool). CTL and DTMC operate on the LTS or a Markov chain model (they're static/design-time tools). Counterexample generation works with both -- it can explain failures from refinement checking, equivalence checking, or CTL model checking.</p>"},{"location":"concepts/verification/#ctl-temporal-logic","title":"CTL Temporal Logic","text":"<p>CTL formulas are built from atomic propositions and composed with temporal operators:</p> Operator Meaning Common Use \\(\\mathbf{AG}(\\phi)\\) \\(\\phi\\) holds in all states on all paths Safety: \"error never happens\" \\(\\mathbf{AF}(\\phi)\\) \\(\\phi\\) eventually holds on all paths Liveness: \"task always completes\" \\(\\mathbf{EF}(\\phi)\\) \\(\\phi\\) is reachable on some path Reachability: \"success is possible\" \\(\\mathbf{EG}(\\phi)\\) \\(\\phi\\) can hold forever on some path Persistence: \"can stay healthy\" \\(\\mathbf{AU}(\\phi, \\psi)\\) \\(\\phi\\) holds until \\(\\psi\\) on all paths Progress: \"processing until done\" \\(\\mathbf{EU}(\\phi, \\psi)\\) \\(\\phi\\) holds until \\(\\psi\\) on some path Conditional reachability <p>The model checker uses backward fixpoint computation: starting from the set of states satisfying the innermost subformula, it iteratively expands using predecessor relations until a fixpoint is reached. This runs in \\(O(|S| \\cdot |\\to| \\cdot |\\phi|)\\) time.</p>"},{"location":"concepts/verification/#probabilistic-verification","title":"Probabilistic Verification","text":"<p>For stochastic agents, nondeterminism is replaced by probability. A DTMC assigns a probability to each transition, enabling quantitative questions:</p> Analysis Question Algorithm Reachability \\(\\Pr(\\Diamond \\text{error})\\) = ? Gaussian elimination on linear system Steady-state Long-run fraction of time in each state? Power iteration: \\(\\pi = \\pi P\\) Expected steps \\(\\mathbb{E}[\\text{steps to success}]\\) = ? Solve \\(e(s) = 1 + \\sum P(s,s') \\cdot e(s')\\) <p>All algorithms are pure Python with zero dependencies. Gaussian elimination handles systems up to ~100 states exactly; value iteration provides a convergent fallback for larger systems.</p>"},{"location":"concepts/verification/#how-it-maps-to-code","title":"How It Maps to Code","text":"<pre><code>from agenticraft_foundation.verification import (\n    # Invariant checking (runtime)\n    InvariantRegistry, check_invariant, StateTransitionMonitor,\n    # Counterexamples (diagnostics)\n    explain_refinement_failure, explain_equivalence_failure,\n    find_minimal_counterexample, CounterexampleExplanation,\n    # CTL temporal logic (static)\n    model_check, AG, AF, EF, EG, EU, AU, AX, EX,\n    Atomic, Not, And, Or, Implies,\n    check_safety, check_liveness, ModelCheckResult,\n    # Probabilistic (static)\n    DTMC, check_reachability, steady_state, expected_steps,\n)\n</code></pre>"},{"location":"concepts/verification/#further-reading","title":"Further Reading","text":"<ul> <li>API Reference: verification/invariant-checker, verification/counterexamples, verification/temporal, verification/probabilistic</li> <li>Tutorials: Checking Temporal Properties with CTL, Modeling Stochastic Agents with DTMC</li> <li>Examples: Temporal Verification, Probabilistic Verification, Counterexample Generation</li> </ul>"},{"location":"concepts/verification/#references","title":"References","text":"<ul> <li>E.M. Clarke, E.A. Emerson, \"Design and Synthesis of Synchronization Skeletons Using Branching Time Temporal Logic\", Workshop on Logics of Programs, 1981.</li> <li>C. Baier, J.-P. Katoen, Principles of Model Checking, MIT Press, 2008.</li> <li>H. Hansson, B. Jonsson, \"A Logic for Reasoning about Time and Reliability\", Formal Aspects of Computing, 1994.</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Annotated walkthroughs of the example scripts in the <code>examples/</code> directory. Each example demonstrates a key module with detailed explanations.</p> Example Module Description CSP Composition algebra All 13 CSP operators, LTS analysis, deadlock detection Interrupt &amp; Timeout algebra 5 agent-specific extensions with practical scenarios Consensus Specification algebra + specifications 3-agent consensus modeled in CSP Mesh Topology topology Spectral analysis, topology comparison Protocol Verification mpst MPST global types, projection, well-formedness Temporal Verification verification CTL model checking: safety, liveness, mutual exclusion Probabilistic Verification verification DTMC reachability, steady-state, expected steps Counterexample Generation verification Structured failure explanations for refinement/equivalence <p>All examples are runnable:</p> <pre><code>python examples/&lt;name&gt;.py\n</code></pre>"},{"location":"examples/consensus-spec/","title":"Consensus Specification","text":"<p>Source: <code>examples/consensus_spec.py</code></p> <p>This example uses CSP operators to formally model a 3-agent consensus protocol, verify its properties, and add fault tolerance with timeouts and interrupts.</p>"},{"location":"examples/consensus-spec/#1-define-consensus-events","title":"1. Define Consensus Events","text":"<p>The protocol uses per-agent proposal and voting events, plus shared decision events.</p> <pre><code>propose = [Event(f\"propose_{i}\") for i in range(3)]\nvote = [Event(f\"vote_{i}\") for i in range(3)]\ncommit = Event(\"commit\")\nabort = Event(\"abort\")\n</code></pre> <p>Each agent has its own <code>propose</code> and <code>vote</code> events (indexed by agent ID), but <code>commit</code> and <code>abort</code> are shared -- all agents must agree on the outcome. This separation is deliberate: proposals and votes are local actions, while the decision is a synchronized global event.</p>"},{"location":"examples/consensus-spec/#2-build-individual-agent-processes","title":"2. Build Individual Agent Processes","text":"<p>Each agent follows the same protocol: propose, vote, then either commit or abort.</p> <pre><code>def make_agent(i: int):\n    \"\"\"Create a consensus participant process.\"\"\"\n    return Prefix(\n        propose[i],\n        Prefix(\n            vote[i],\n            ExternalChoice(\n                left=Prefix(commit, Stop()),\n                right=Prefix(abort, Stop()),\n            ),\n        ),\n    )\n\nagent_0 = make_agent(0)\nagent_1 = make_agent(1)\nagent_2 = make_agent(2)\n</code></pre> <p>The <code>ExternalChoice</code> at the end models the decision point: the environment (or the coordinator) determines whether the group commits or aborts. Each agent can participate in either outcome.</p>"},{"location":"examples/consensus-spec/#3-compose-with-synchronization","title":"3. Compose with Synchronization","text":"<p>Agents run in parallel, synchronizing on the decision events.</p> <pre><code>sync_events = frozenset({commit, abort})\ntwo_agents = Parallel(left=agent_0, right=agent_1, sync_set=sync_events)\nconsensus = Parallel(left=two_agents, right=agent_2, sync_set=sync_events)\n</code></pre> <p>The <code>sync_set</code> contains <code>commit</code> and <code>abort</code>. This enforces a key consensus property: all agents must participate in the same decision event simultaneously. Agent 0 cannot commit while Agent 1 aborts -- the synchronization set prevents this. Proposals and votes are not in the sync set, so agents can propose and vote independently.</p>"},{"location":"examples/consensus-spec/#4-analyze-lts-and-detect-deadlocks","title":"4. Analyze LTS and Detect Deadlocks","text":"<p>The composed system is analyzed for correctness.</p> <pre><code>lts = build_lts(consensus)\nprint(f\"States in consensus LTS: {len(lts.states)}\")\n\ndl = detect_deadlock(lts)\nprint(f\"Has deadlock: {dl.has_deadlock}\")\nif dl.has_deadlock:\n    print(f\"Deadlock states: {len(dl.deadlock_states)}\")\n</code></pre> <p>Building the LTS explores all reachable states of the composed system. Deadlock analysis reveals whether there are states where no agent can make progress. In this model, deadlock states exist after the decision is made (the system reaches <code>Stop</code>), which is expected terminal behavior rather than a liveness violation.</p>"},{"location":"examples/consensus-spec/#5-trace-analysis","title":"5. Trace Analysis","text":"<p>Traces enumerate all possible execution paths.</p> <pre><code>t = list(traces(lts, max_length=10))\nprint(f\"Total traces (max length 10): {len(t)}\")\n\ncommit_traces = [tr for tr in t if commit in tr]\nabort_traces = [tr for tr in t if abort in tr]\nprint(f\"Traces reaching commit: {len(commit_traces)}\")\nprint(f\"Traces reaching abort: {len(abort_traces)}\")\n</code></pre> <p>This verifies that both outcomes are reachable -- the protocol does not force a particular decision. The traces show all interleavings of agent proposals and votes, followed by either a commit or abort. The number of traces grows with the interleavings, but the decision events appear exactly once per trace.</p>"},{"location":"examples/consensus-spec/#6-add-fault-tolerance-with-timeout","title":"6. Add Fault Tolerance with Timeout","text":"<p>A timeout ensures progress even if an agent stalls.</p> <pre><code>fault_tolerant_agent = Timeout(\n    process=agent_0,\n    duration=10.0,\n    fallback=Prefix(abort, Stop()),\n)\n\nprint(f\"Fault-tolerant agent initials: {fault_tolerant_agent.initials()}\")\n# Can propose OR timeout\n</code></pre> <p>Wrapping Agent 0 with a <code>Timeout</code> adds a fallback path: if the agent does not propose within the duration, the system falls back to an abort. This models crash-recovery behavior -- a non-responsive agent triggers an abort rather than blocking the entire consensus indefinitely.</p>"},{"location":"examples/consensus-spec/#7-add-interrupt-handling","title":"7. Add Interrupt Handling","text":"<p>A coordinator can force an abort at any point.</p> <pre><code>coordinator_abort = Event(\"coordinator_abort\")\ninterruptible = Interrupt(\n    primary=fault_tolerant_agent,\n    handler=Prefix(coordinator_abort, Prefix(abort, Stop())),\n)\n\nprint(f\"Interruptible agent initials: {interruptible.initials()}\")\n</code></pre> <p>The <code>Interrupt</code> wraps the already-timeout-protected agent, adding a coordinator override. At any point during the agent's execution, the coordinator can fire <code>coordinator_abort</code> to force an abort. This layers two fault-tolerance mechanisms: timeouts for unresponsive agents, interrupts for coordinator-initiated cancellation.</p>"},{"location":"examples/consensus-spec/#8-verify-the-fault-tolerant-version","title":"8. Verify the Fault-Tolerant Version","text":"<pre><code>ft_lts = build_lts(fault_tolerant_agent)\nft_traces = list(traces(ft_lts, max_length=10))\nprint(f\"Fault-tolerant traces: {len(ft_traces)}\")\n\nprint(f\"Fault-tolerant is deadlock-free: {is_deadlock_free(fault_tolerant_agent)}\")\n</code></pre> <p>The fault-tolerant version has more traces than the original (because the timeout introduces additional paths), but every trace leads to a terminal action. The analysis confirms that the timeout achieves its goal: the agent always makes progress toward either a commit or an abort.</p> Complete source <pre><code>\"\"\"Formal Consensus Specification -- CSP model of distributed consensus.\n\nDemonstrates using CSP operators to model and verify consensus properties.\n\"\"\"\n\nfrom agenticraft_foundation import (\n    Event,\n    ExternalChoice,\n    Interrupt,\n    Parallel,\n    Prefix,\n    Stop,\n    Timeout,\n    build_lts,\n    detect_deadlock,\n    is_deadlock_free,\n    traces,\n)\n\n# =============================================================\n# Model a 3-agent consensus protocol\n# =============================================================\nprint(\"=== 3-Agent Consensus Model ===\")\n\n# Events for agent communication\npropose = [Event(f\"propose_{i}\") for i in range(3)]\nvote = [Event(f\"vote_{i}\") for i in range(3)]\ncommit = Event(\"commit\")\nabort = Event(\"abort\")\n\n# Each agent: propose, then vote, then commit or abort\ndef make_agent(i: int):\n    \"\"\"Create a consensus participant process.\"\"\"\n    return Prefix(\n        propose[i],\n        Prefix(\n            vote[i],\n            ExternalChoice(\n                left=Prefix(commit, Stop()),\n                right=Prefix(abort, Stop()),\n            ),\n        ),\n    )\n\nagent_0 = make_agent(0)\nagent_1 = make_agent(1)\nagent_2 = make_agent(2)\n\nprint(f\"Agent 0 initials: {agent_0.initials()}\")\nprint(f\"Agent 0 alphabet: {agent_0.alphabet()}\")\n\n# Compose agents -- sync on commit/abort (all must agree)\nsync_events = frozenset({commit, abort})\ntwo_agents = Parallel(left=agent_0, right=agent_1, sync_set=sync_events)\nconsensus = Parallel(left=two_agents, right=agent_2, sync_set=sync_events)\n\nprint(f\"\\nConsensus system alphabet: {consensus.alphabet()}\")\nprint(f\"Consensus system initials: {consensus.initials()}\")\n\n# =============================================================\n# Verify properties\n# =============================================================\nprint(\"\\n=== Verification ===\")\n\n# Build LTS and analyze\nlts = build_lts(consensus)\nprint(f\"States in consensus LTS: {len(lts.states)}\")\n\n# Check for deadlock\ndl = detect_deadlock(lts)\nprint(f\"Has deadlock: {dl.has_deadlock}\")\nif dl.has_deadlock:\n    print(f\"Deadlock states: {len(dl.deadlock_states)}\")\n\n# Enumerate traces\nt = list(traces(lts, max_length=10))\nprint(f\"Total traces (max length 10): {len(t)}\")\n\n# Check if commit and abort are both reachable\ncommit_traces = [tr for tr in t if commit in tr]\nabort_traces = [tr for tr in t if abort in tr]\nprint(f\"Traces reaching commit: {len(commit_traces)}\")\nprint(f\"Traces reaching abort: {len(abort_traces)}\")\n\n# =============================================================\n# Add fault tolerance: timeout on proposals\n# =============================================================\nprint(\"\\n=== Fault-Tolerant Consensus ===\")\n\n# Wrap agent 0 with a timeout: if it doesn't propose in time, abort\nfault_tolerant_agent = Timeout(\n    process=agent_0,\n    duration=10.0,\n    fallback=Prefix(abort, Stop()),\n)\n\nprint(f\"Fault-tolerant agent initials: {fault_tolerant_agent.initials()}\")\n# Can propose OR timeout\n\n# Add interrupt: coordinator can force abort\ncoordinator_abort = Event(\"coordinator_abort\")\ninterruptible = Interrupt(\n    primary=fault_tolerant_agent,\n    handler=Prefix(coordinator_abort, Prefix(abort, Stop())),\n)\n\nprint(f\"Interruptible agent initials: {interruptible.initials()}\")\n\n# Verify the fault-tolerant version\nft_lts = build_lts(fault_tolerant_agent)\nft_traces = list(traces(ft_lts, max_length=10))\nprint(f\"Fault-tolerant traces: {len(ft_traces)}\")\n\n# The timeout ensures the agent always makes progress\nprint(f\"Fault-tolerant is deadlock-free: {is_deadlock_free(fault_tolerant_agent)}\")\n\nprint(\"\\nConsensus specification complete.\")\n</code></pre>"},{"location":"examples/counterexample-generation/","title":"Counterexample Generation","text":"<p>Source: <code>examples/counterexample_generation.py</code></p> <p>This example demonstrates structured counterexample generation -- when refinement or equivalence checks fail, the system explains exactly where and why the specification and implementation diverge.</p>"},{"location":"examples/counterexample-generation/#1-trace-refinement-extra-behavior","title":"1. Trace Refinement: Extra Behavior","text":"<p>The implementation does something the specification doesn't allow.</p> <pre><code>from agenticraft_foundation import Event, Prefix, Stop\nfrom agenticraft_foundation.algebra import trace_refines\nfrom agenticraft_foundation.verification import explain_refinement_failure\n\nreq = Event(\"request\")\nresp = Event(\"response\")\nack = Event(\"acknowledge\")\n\n# Spec: request -&gt; response -&gt; stop\nspec = Prefix(req, Prefix(resp, Stop()))\n\n# Impl: request -&gt; response -&gt; acknowledge -&gt; stop (extra event!)\nimpl = Prefix(req, Prefix(resp, Prefix(ack, Stop())))\n\nresult = trace_refines(spec, impl)\n</code></pre> <p>Without counterexample generation, you get <code>is_valid=False</code> and a raw trace. With it:</p> <pre><code>explanation = explain_refinement_failure(spec, impl, result)\nprint(explanation.summary)\n# \"Impl violates spec at trace \u27e8request, response, acknowledge\u27e9:\n#  After \u27e8request, response\u27e9, spec allows {} but impl performs acknowledge\"\n</code></pre> <p>The explanation pinpoints:</p> <ul> <li>Divergence step: Step 2 (the <code>acknowledge</code> event)</li> <li>Spec allowed: <code>{}</code> (nothing -- spec has terminated)</li> <li>Impl attempted: <code>acknowledge</code></li> </ul>"},{"location":"examples/counterexample-generation/#2-failures-refinement-nondeterminism","title":"2. Failures Refinement: Nondeterminism","text":"<p>When an implementation makes an internal choice that the specification leaves to the environment.</p> <pre><code>from agenticraft_foundation import ExternalChoice, InternalChoice\n\n# Spec: external choice (environment decides)\nspec = Prefix(req, ExternalChoice(\n    Prefix(resp, Stop()),\n    Prefix(err, Stop()),\n))\n\n# Impl: internal choice (impl decides -- may refuse error)\nimpl = Prefix(req, InternalChoice(\n    Prefix(resp, Stop()),\n    Prefix(err, Stop()),\n))\n\nresult = failures_refines(spec, impl)\nexplanation = explain_refinement_failure(spec, impl, result)\nprint(explanation.summary)\n# \"After trace \u27e8request\u27e9, impl refuses {error, request}\n#  but spec does not refuse all of these\"\n</code></pre> <p>The <code>InternalChoice</code> means the implementation can nondeterministically pick <code>resp</code> and refuse <code>err</code>, which the specification doesn't allow.</p>"},{"location":"examples/counterexample-generation/#3-bisimulation-branching-structure","title":"3. Bisimulation: Branching Structure","text":"<p>Two processes with the same traces but different branching structure.</p> <pre><code>from agenticraft_foundation.algebra import trace_equivalent, strong_bisimilar\nfrom agenticraft_foundation.verification import explain_equivalence_failure\n\na, b, c = Event(\"a\"), Event(\"b\"), Event(\"c\")\n\n# P: a -&gt; (b [] c)  -- choose after a\np = Prefix(a, ExternalChoice(Prefix(b, Stop()), Prefix(c, Stop())))\n\n# Q: (a -&gt; b) [] (a -&gt; c)  -- choose before a\nq = ExternalChoice(Prefix(a, Prefix(b, Stop())), Prefix(a, Prefix(c, Stop())))\n</code></pre> <p>These have identical trace sets <code>{\u27e8a,b\u27e9, \u27e8a,c\u27e9}</code>, but different branching:</p> <pre><code>trace_equivalent(p, q).is_equivalent   # True (sometimes False depending on semantics)\nstrong_bisimilar(p, q).is_equivalent   # False\n</code></pre> <pre><code>explanation = explain_equivalence_failure(p, q, bisim_result)\nprint(explanation.summary)\n# \"After \u27e8a\u27e9, P can do {c}\"\n</code></pre> <p>After event <code>a</code>, process P can do <code>{b, c}</code> but process Q (having committed to one branch) can only do <code>{b}</code>. The explanation shows exactly which events diverge at which step.</p>"},{"location":"examples/counterexample-generation/#4-minimal-counterexample","title":"4. Minimal Counterexample","text":"<p>Find the shortest distinguishing trace between two processes.</p> <pre><code>from agenticraft_foundation import build_lts\nfrom agenticraft_foundation.verification import find_minimal_counterexample\n\nlts_spec = build_lts(spec)\nlts_impl = build_lts(impl)\nminimal = find_minimal_counterexample(lts_spec, lts_impl)\nprint(f\"Trace length: {len(minimal.annotated_trace)}\")\n</code></pre> <p><code>find_minimal_counterexample</code> uses BFS over the synchronized product of both LTS to find the shortest trace that distinguishes them.</p>"},{"location":"examples/counterexample-generation/#annotated-trace-format","title":"Annotated Trace Format","text":"<p>Each step in the annotated trace is an <code>AnnotatedStep</code>:</p> <pre><code>@dataclass(frozen=True)\nclass AnnotatedStep:\n    event: Event              # The event at this step\n    status: StepStatus        # OK or VIOLATION\n    spec_available: frozenset # Events spec could do here\n    impl_available: frozenset # Events impl could do here\n    spec_states: frozenset    # Spec LTS states at this step\n    impl_states: frozenset    # Impl LTS states at this step\n</code></pre> <p>Steps with <code>StepStatus.OK</code> are where both agree. The first <code>StepStatus.VIOLATION</code> marks the divergence point.</p>"},{"location":"examples/counterexample-generation/#output","title":"Output","text":"<pre><code>=== Trace Refinement Failure ===\nSummary: Impl violates spec at trace \u27e8request, response, acknowledge\u27e9:\n  After \u27e8request, response\u27e9, spec allows {} but impl performs acknowledge\nDivergence at step: 2\n\n=== Extra Nondeterminism ===\nSummary: After trace \u27e8request\u27e9, impl refuses {error, request}\n  but spec does not refuse all of these\n\n=== Bisimulation Failure ===\nSummary: After \u27e8a\u27e9, P can do {c}\nDivergence at step: 1\n  a [OK]    P={a} Q={a}\n  c [VIOLATION] P={b, c} Q={b}\n\n=== Minimal Counterexample ===\nTrace length: 3\n</code></pre>"},{"location":"examples/csp-composition/","title":"CSP Composition","text":"<p>Source: <code>examples/csp_composition.py</code></p> <p>This example demonstrates all core CSP operators working together to model multi-agent coordination scenarios. It covers process construction, composition, hiding, recursion, and formal analysis.</p>"},{"location":"examples/csp-composition/#1-basic-processes","title":"1. Basic Processes","text":"<p>The example begins by defining events and a simple request-response handler.</p> <pre><code>req = Event(\"request\")\nresp = Event(\"response\")\nack = Event(\"ack\")\ninternal = Event(\"internal_process\")\n\n# A simple request-response handler\nhandler = Prefix(req, Prefix(resp, Stop()))\nprint(f\"Handler initials: {handler.initials()}\")\nprint(f\"Handler alphabet: {handler.alphabet()}\")\n</code></pre> <p><code>Prefix(req, Prefix(resp, Stop()))</code> builds a sequential process: perform <code>request</code>, then <code>response</code>, then deadlock (<code>Stop</code>). The <code>initials()</code> method returns the set of events the process can perform immediately. The <code>alphabet()</code> method returns all events the process can ever engage in.</p>"},{"location":"examples/csp-composition/#2-choice-operators","title":"2. Choice Operators","text":"<p>Two forms of choice model different decision-making scenarios.</p> <pre><code>fast_path = Prefix(Event(\"cache_hit\"), Prefix(resp, Stop()))\nslow_path = Prefix(req, Prefix(internal, Prefix(resp, Stop())))\n\n# External choice: environment picks\nservice = ExternalChoice(left=fast_path, right=slow_path)\nprint(f\"Service (external choice) initials: {service.initials()}\")\n\n# Internal choice: process decides\nstrategy = InternalChoice(left=fast_path, right=slow_path)\nprint(f\"Strategy (internal choice) initials: {strategy.initials()}\")\n</code></pre> <p>ExternalChoice offers both branches to the environment (the caller decides which path to take). The initials include the first events of both branches. InternalChoice lets the process decide nondeterministically -- the environment cannot control which branch is taken. This distinction is fundamental in CSP: external choice models observable decisions, internal choice models hidden nondeterminism.</p>"},{"location":"examples/csp-composition/#3-parallel-composition","title":"3. Parallel Composition","text":"<p>Two processes run concurrently, synchronizing on shared events.</p> <pre><code>producer = Prefix(Event(\"produce\"), Prefix(Event(\"emit\"), Stop()))\nconsumer = Prefix(Event(\"emit\"), Prefix(Event(\"consume\"), Stop()))\n\n# Synchronize on \"emit\"\nsystem = Parallel(left=producer, right=consumer, sync_set=frozenset({Event(\"emit\")}))\nprint(f\"Parallel system alphabet: {system.alphabet()}\")\n</code></pre> <p>The <code>sync_set</code> parameter specifies which events require both processes to participate simultaneously. Here, <code>emit</code> is a handoff -- the producer emits and the consumer receives at the same moment. Events not in the sync set (like <code>produce</code> and <code>consume</code>) can proceed independently.</p>"},{"location":"examples/csp-composition/#4-sequential-composition","title":"4. Sequential Composition","text":"<p>One process runs after another completes.</p> <pre><code>setup = Prefix(Event(\"init\"), Skip())\nwork = Prefix(req, Prefix(resp, Stop()))\npipeline = Sequential(first=setup, second=work)\nprint(f\"Sequential pipeline initials: {pipeline.initials()}\")\n</code></pre> <p>The first process must terminate with <code>Skip()</code> (successful termination) before the second process begins. If the first process ends with <code>Stop()</code> (deadlock), the second process never starts. This is a key distinction: <code>Skip</code> signals completion, <code>Stop</code> signals failure.</p>"},{"location":"examples/csp-composition/#5-hiding","title":"5. Hiding","text":"<p>Internal events can be concealed from the external view.</p> <pre><code>visible = Hiding(\n    process=Prefix(internal, Prefix(resp, Stop())),\n    hidden=frozenset({internal}),\n)\nprint(f\"After hiding 'internal': alphabet = {visible.alphabet()}\")\n</code></pre> <p>Hiding converts visible events into internal (tau) transitions. The hidden event <code>internal</code> is removed from the alphabet. This is essential for abstraction -- you can build a detailed internal model and then hide implementation details when composing with other processes.</p>"},{"location":"examples/csp-composition/#6-recursion","title":"6. Recursion","text":"<p>Recursive definitions model infinite behavior like servers.</p> <pre><code>server = Recursion(\n    variable=\"X\",\n    body=Prefix(req, Prefix(resp, Variable(\"X\"))),\n)\nunfolded = server.unfold()\nprint(f\"Recursive server initials: {unfolded.initials()}\")\n</code></pre> <p><code>Recursion</code> defines a fixed-point: the process repeatedly performs <code>request</code> then <code>response</code>, forever. <code>Variable(\"X\")</code> marks where the recursion unfolds. The <code>unfold()</code> method performs one step of unfolding, replacing the variable with the body.</p>"},{"location":"examples/csp-composition/#7-analysis","title":"7. Analysis","text":"<p>The example concludes with formal analysis of the constructed processes.</p> <pre><code>lts = build_lts(handler)\nprint(f\"Handler LTS: {len(lts.states)} states\")\n\nt = list(traces(lts, max_length=5))\nprint(f\"Handler traces: {t}\")\n\ndl = detect_deadlock(lts)\nprint(f\"Handler has deadlock: {dl.has_deadlock}\")\n\nprint(f\"Service is deadlock-free: {is_deadlock_free(service)}\")\n</code></pre> <p><code>build_lts()</code> constructs a Labeled Transition System -- a state machine representation of the process. <code>traces()</code> enumerates all possible execution sequences up to a given length. <code>detect_deadlock()</code> finds states with no outgoing transitions (where the process gets stuck). <code>is_deadlock_free()</code> is a convenience wrapper that returns a boolean.</p> <p>The handler (<code>Prefix(req, Prefix(resp, Stop()))</code>) has a deadlock: after performing both events, it reaches <code>Stop</code>, which has no transitions. This is expected -- it models a one-shot handler, not a server.</p> Complete source <pre><code>\"\"\"CSP Composition -- Core 8 operators working together.\n\nDemonstrates: Stop, Skip, Prefix, ExternalChoice, InternalChoice,\nParallel, Sequential, Hiding, Recursion.\n\"\"\"\n\nfrom agenticraft_foundation import (\n    Event,\n    ExternalChoice,\n    Hiding,\n    InternalChoice,\n    Parallel,\n    Prefix,\n    Recursion,\n    Sequential,\n    Skip,\n    Stop,\n    Variable,\n    build_lts,\n    detect_deadlock,\n    is_deadlock_free,\n    traces,\n)\n\n# --- Events ---\nreq = Event(\"request\")\nresp = Event(\"response\")\nack = Event(\"ack\")\ninternal = Event(\"internal_process\")\n\n# --- Basic processes ---\n# A simple request-response handler\nhandler = Prefix(req, Prefix(resp, Stop()))\nprint(f\"Handler initials: {handler.initials()}\")\nprint(f\"Handler alphabet: {handler.alphabet()}\")\n\n# --- External Choice: environment picks ---\nfast_path = Prefix(Event(\"cache_hit\"), Prefix(resp, Stop()))\nslow_path = Prefix(req, Prefix(internal, Prefix(resp, Stop())))\nservice = ExternalChoice(left=fast_path, right=slow_path)\nprint(f\"\\nService (external choice) initials: {service.initials()}\")\n\n# --- Internal Choice: process decides ---\nstrategy = InternalChoice(left=fast_path, right=slow_path)\nprint(f\"Strategy (internal choice) initials: {strategy.initials()}\")\n\n# --- Parallel composition ---\nproducer = Prefix(Event(\"produce\"), Prefix(Event(\"emit\"), Stop()))\nconsumer = Prefix(Event(\"emit\"), Prefix(Event(\"consume\"), Stop()))\n# Synchronize on \"emit\"\nsystem = Parallel(left=producer, right=consumer, sync_set=frozenset({Event(\"emit\")}))\nprint(f\"\\nParallel system alphabet: {system.alphabet()}\")\n\n# --- Sequential composition ---\nsetup = Prefix(Event(\"init\"), Skip())\nwork = Prefix(req, Prefix(resp, Stop()))\npipeline = Sequential(first=setup, second=work)\nprint(f\"Sequential pipeline initials: {pipeline.initials()}\")\n\n# --- Hiding ---\nvisible = Hiding(\n    process=Prefix(internal, Prefix(resp, Stop())),\n    hidden=frozenset({internal}),\n)\nprint(f\"After hiding 'internal': alphabet = {visible.alphabet()}\")\n\n# --- Recursion ---\nserver = Recursion(\n    variable=\"X\",\n    body=Prefix(req, Prefix(resp, Variable(\"X\"))),\n)\nunfolded = server.unfold()\nprint(f\"\\nRecursive server initials: {unfolded.initials()}\")\n\n# --- Analysis ---\nprint(\"\\n--- Analysis ---\")\nlts = build_lts(handler)\nprint(f\"Handler LTS: {len(lts.states)} states\")\n\nt = list(traces(lts, max_length=5))\nprint(f\"Handler traces: {t}\")\n\ndl = detect_deadlock(lts)\nprint(f\"Handler has deadlock: {dl.has_deadlock}\")\n\nprint(f\"Service is deadlock-free: {is_deadlock_free(service)}\")\n</code></pre>"},{"location":"examples/interrupt-timeout/","title":"Interrupt &amp; Timeout","text":"<p>Source: <code>examples/interrupt_timeout.py</code></p> <p>This example demonstrates the 5 agent-specific CSP extensions through practical AI agent scenarios. Each operator addresses a real coordination problem that arises in multi-agent systems.</p>"},{"location":"examples/interrupt-timeout/#1-interrupt-priority-override","title":"1. Interrupt: Priority Override","text":"<p>An agent performing a long-running task needs to be preemptible by higher-priority requests.</p> <pre><code>process_data = Event(\"process_data\")\nreturn_result = Event(\"return_result\")\nhandle_priority = Event(\"handle_priority\")\nurgent_response = Event(\"urgent_response\")\n\n# Normal task: process data, then return result\ntask = Prefix(process_data, Prefix(return_result, Stop()))\n\n# Priority handler: handle urgent request\nhandler = Prefix(handle_priority, Prefix(urgent_response, Stop()))\n\n# Interruptible task: can be preempted at any point\ninterruptible = Interrupt(primary=task, handler=handler)\n\nprint(f\"Can do: {interruptible.initials()}\")\n# process_data (normal) OR handle_priority (interrupt)\n</code></pre> <p>The <code>Interrupt</code> operator wraps a primary process so that at any point during its execution, a handler process can take over. The initials include both the primary's next event (<code>process_data</code>) and the handler's trigger (<code>handle_priority</code>). After a normal event, the process remains interruptible. After the interrupt fires, the handler runs exclusively -- the primary is abandoned.</p> <p>This models scenarios like: an agent analyzing a document can be interrupted by a high-priority user query.</p>"},{"location":"examples/interrupt-timeout/#2-timeout-bounded-llm-call","title":"2. Timeout: Bounded LLM Call","text":"<p>LLM API calls can hang indefinitely. A timeout ensures the system always makes progress.</p> <pre><code>call_llm = Event(\"call_gpt4\")\nparse_response = Event(\"parse_response\")\nreturn_cached = Event(\"return_cached\")\n\n# LLM call process\nllm_call = Prefix(call_llm, Prefix(parse_response, Stop()))\n\n# Fallback: return cached response\nfallback = Prefix(return_cached, Stop())\n\n# Bounded execution: 30 second timeout\nbounded = Timeout(process=llm_call, duration=30.0, fallback=fallback)\n\nprint(f\"Initials: {bounded.initials()}\")\n# call_gpt4 (start LLM call) OR tau_timeout (timeout fires)\n</code></pre> <p>The <code>Timeout</code> operator adds a special <code>TIMEOUT_EVENT</code> (tau) to the initials. If the timeout fires (modeled as a tau transition), the fallback process takes over. If the primary process makes progress, the timeout remains active for subsequent steps. The duration is metadata for analysis -- the CSP semantics use the nondeterministic choice between progress and timeout.</p> <p>After timeout, the fallback runs (<code>return_cached</code>). After the LLM call starts, the process remains a <code>Timeout</code> instance -- the timeout can still fire during <code>parse_response</code>.</p>"},{"location":"examples/interrupt-timeout/#3-guard-budget-gated-agent","title":"3. Guard: Budget-Gated Agent","text":"<p>Expensive LLM calls should only proceed when budget allows.</p> <pre><code>budget = {\"remaining\": 100.0}\n\nexpensive_call = Event(\"call_gpt4o\")\nprocess = Event(\"process_result\")\n\nexpensive_agent = Prefix(expensive_call, Prefix(process, Stop()))\n\n# Only activate if budget allows\nguarded = Guard(\n    condition=lambda: budget[\"remaining\"] &gt; 0,\n    process=expensive_agent,\n)\n\nprint(f\"Budget &gt; 0: initials = {guarded.initials()}\")\n# {call_gpt4o}\n\nbudget[\"remaining\"] = 0\nprint(f\"Budget = 0: initials = {guarded.initials()}\")\n# frozenset() -- acts as Stop\n\nbudget[\"remaining\"] = 50.0\nprint(f\"Budget restored: initials = {guarded.initials()}\")\n# {call_gpt4o} again\n</code></pre> <p>The <code>Guard</code> operator evaluates a condition (a boolean or callable). When the condition is true, the guarded process behaves normally. When false, it behaves like <code>Stop</code> -- no events are available. The condition can be a lambda that checks runtime state, making it dynamic.</p> <p>This models resource-constrained agents: only activate expensive capabilities when budget, rate limits, or other conditions are met.</p>"},{"location":"examples/interrupt-timeout/#4-rename-protocol-bridging","title":"4. Rename: Protocol Bridging","text":"<p>Two agents use different event vocabularies. Rename translates between them.</p> <pre><code>task_done = Event(\"task_done\")\nagent_a = Prefix(task_done, Stop())\n\nwork_complete = Event(\"work_complete\")\n\n# Bridge: rename task_done -&gt; work_complete\nbridged = Rename.from_dict(agent_a, {task_done: work_complete})\n\nprint(f\"Original initials: {agent_a.initials()}\")   # {task_done}\nprint(f\"Bridged initials: {bridged.initials()}\")     # {work_complete}\n</code></pre> <p><code>Rename</code> applies a mapping from old events to new events across the entire process. The original event disappears from the alphabet and is replaced by the new one. <code>Rename.from_dict()</code> is a convenience constructor that accepts a dictionary mapping.</p> <p>This models protocol bridging in heterogeneous multi-agent systems: Agent A emits <code>task_done</code> but Agent B expects <code>work_complete</code>. The rename adapter makes them compatible without modifying either agent.</p>"},{"location":"examples/interrupt-timeout/#5-pipe-rag-pipeline","title":"5. Pipe: RAG Pipeline","text":"<p>A retrieval-augmented generation pipeline connects a retriever to a processor, hiding the internal channel.</p> <pre><code>query = Event(\"query\")\nemit_docs = Event(\"emit_docs\")\nsummarize = Event(\"summarize\")\n\n# Retriever: receives query, emits documents\nretriever = Prefix(query, Prefix(emit_docs, Stop()))\n\n# Processor: receives documents, produces summary\nprocessor = Prefix(emit_docs, Prefix(summarize, Stop()))\n\n# Pipeline: emit_docs is internal channel\nrag_pipeline = Pipe(\n    producer=retriever,\n    consumer=processor,\n    channel=frozenset({emit_docs}),\n)\n\nprint(f\"Pipeline alphabet: {rag_pipeline.alphabet()}\")\n# {query, summarize} -- emit_docs is hidden\n</code></pre> <p><code>Pipe</code> composes two processes by synchronizing on channel events and then hiding those events from the external alphabet. The result is a pipeline where only the endpoints are visible: <code>query</code> goes in, <code>summarize</code> comes out, and <code>emit_docs</code> is an internal handoff.</p> <p>This is equivalent to <code>Hiding(Parallel(retriever, processor, sync_set={emit_docs}), hidden={emit_docs})</code> but expressed as a single, intention-revealing operator.</p>"},{"location":"examples/interrupt-timeout/#6-analysis","title":"6. Analysis","text":"<p>The example concludes by analyzing the constructed processes.</p> <pre><code>lts = build_lts(interruptible)\nt = list(traces(lts, max_length=5))\nprint(f\"Interruptible traces ({len(t)}): {t[:5]}\")\n\nprint(f\"Timeout process deadlock-free: {is_deadlock_free(bounded)}\")\nprint(f\"Pipeline deadlock-free: {is_deadlock_free(rag_pipeline)}\")\n</code></pre> <p>The interruptible process has more traces than the plain task because at each step, the interrupt can fire. The timeout process is not deadlock-free (it eventually reaches <code>Stop</code>), but it guarantees progress -- every path leads to a terminal action rather than getting stuck waiting for an LLM response. The pipeline is analyzed for deadlocks to verify the synchronization is correct.</p> Complete source <pre><code>\"\"\"Interrupt, Timeout, Guard -- Agent-specific CSP extensions.\n\nDemonstrates the 5 new operators for real agent coordination scenarios.\n\"\"\"\n\nfrom agenticraft_foundation import (\n    TIMEOUT_EVENT,\n    Event,\n    Guard,\n    Interrupt,\n    Pipe,\n    Prefix,\n    Rename,\n    Stop,\n    Timeout,\n    build_lts,\n    is_deadlock_free,\n    traces,\n)\n\n# =============================================================\n# Scenario 1: Interruptible Agent Task\n# =============================================================\nprint(\"=== Interrupt: Priority Override ===\")\n\nprocess_data = Event(\"process_data\")\nreturn_result = Event(\"return_result\")\nhandle_priority = Event(\"handle_priority\")\nurgent_response = Event(\"urgent_response\")\n\n# Normal task: process data, then return result\ntask = Prefix(process_data, Prefix(return_result, Stop()))\n\n# Priority handler: handle urgent request\nhandler = Prefix(handle_priority, Prefix(urgent_response, Stop()))\n\n# Interruptible task: can be preempted at any point\ninterruptible = Interrupt(primary=task, handler=handler)\n\nprint(f\"Can do: {interruptible.initials()}\")\n# process_data (normal) OR handle_priority (interrupt)\n\n# After normal event, still interruptible\nafter_normal = interruptible.after(process_data)\nprint(f\"After process_data: {after_normal}\")\nprint(f\"Still interruptible: {isinstance(after_normal, Interrupt)}\")\n\n# After interrupt event, handler takes over\nafter_interrupt = interruptible.after(handle_priority)\nprint(f\"After interrupt: {after_interrupt}\")\nprint(f\"Handler active: {not isinstance(after_interrupt, Interrupt)}\")\n\n# =============================================================\n# Scenario 2: LLM Call with Timeout\n# =============================================================\nprint(\"\\n=== Timeout: Bounded LLM Call ===\")\n\ncall_llm = Event(\"call_gpt4\")\nparse_response = Event(\"parse_response\")\nreturn_cached = Event(\"return_cached\")\n\n# LLM call process\nllm_call = Prefix(call_llm, Prefix(parse_response, Stop()))\n\n# Fallback: return cached response\nfallback = Prefix(return_cached, Stop())\n\n# Bounded execution: 30 second timeout\nbounded = Timeout(process=llm_call, duration=30.0, fallback=fallback)\n\nprint(f\"Initials: {bounded.initials()}\")\n# call_gpt4 (start LLM call) OR tau_timeout (timeout fires)\n\n# If timeout fires, switch to fallback\nafter_timeout = bounded.after(TIMEOUT_EVENT)\nprint(f\"After timeout: {after_timeout}\")\nassert return_cached in after_timeout.initials()\n\n# If LLM starts, still has timeout\nafter_start = bounded.after(call_llm)\nprint(f\"After call_llm: {after_start}\")\nassert isinstance(after_start, Timeout)\n\n# =============================================================\n# Scenario 3: Conditional Agent Activation\n# =============================================================\nprint(\"\\n=== Guard: Budget-Gated Agent ===\")\n\nbudget = {\"remaining\": 100.0}\n\nexpensive_call = Event(\"call_gpt4o\")\nprocess = Event(\"process_result\")\n\nexpensive_agent = Prefix(expensive_call, Prefix(process, Stop()))\n\n# Only activate if budget allows\nguarded = Guard(\n    condition=lambda: budget[\"remaining\"] &gt; 0,\n    process=expensive_agent,\n)\n\nprint(f\"Budget &gt; 0: initials = {guarded.initials()}\")\nassert expensive_call in guarded.initials()\n\n# Deplete budget\nbudget[\"remaining\"] = 0\nprint(f\"Budget = 0: initials = {guarded.initials()}\")\nassert guarded.initials() == frozenset()  # Acts as Stop\n\n# Restore budget\nbudget[\"remaining\"] = 50.0\nprint(f\"Budget restored: initials = {guarded.initials()}\")\nassert expensive_call in guarded.initials()\n\n# =============================================================\n# Scenario 4: Protocol Bridging via Rename\n# =============================================================\nprint(\"\\n=== Rename: Protocol Bridging ===\")\n\n# Agent A uses \"task_done\" event\ntask_done = Event(\"task_done\")\nagent_a = Prefix(task_done, Stop())\n\n# Agent B expects \"work_complete\" event\nwork_complete = Event(\"work_complete\")\n\n# Bridge: rename task_done -&gt; work_complete\nbridged = Rename.from_dict(agent_a, {task_done: work_complete})\n\nprint(f\"Original initials: {agent_a.initials()}\")\nprint(f\"Bridged initials: {bridged.initials()}\")\nassert work_complete in bridged.initials()\nassert task_done not in bridged.initials()\n\n# =============================================================\n# Scenario 5: RAG Pipeline\n# =============================================================\nprint(\"\\n=== Pipe: RAG Pipeline ===\")\n\nquery = Event(\"query\")\nemit_docs = Event(\"emit_docs\")\nsummarize = Event(\"summarize\")\n\n# Retriever: receives query, emits documents\nretriever = Prefix(query, Prefix(emit_docs, Stop()))\n\n# Processor: receives documents, produces summary\nprocessor = Prefix(emit_docs, Prefix(summarize, Stop()))\n\n# Pipeline: emit_docs is internal channel\nrag_pipeline = Pipe(\n    producer=retriever,\n    consumer=processor,\n    channel=frozenset({emit_docs}),\n)\n\nprint(f\"Pipeline alphabet: {rag_pipeline.alphabet()}\")\nassert query in rag_pipeline.alphabet()\nassert summarize in rag_pipeline.alphabet()\nassert emit_docs not in rag_pipeline.alphabet()  # Hidden!\n\n# =============================================================\n# Analysis\n# =============================================================\nprint(\"\\n=== Analysis ===\")\n\nlts = build_lts(interruptible)\nt = list(traces(lts, max_length=5))\nprint(f\"Interruptible traces ({len(t)}): {t[:5]}\")\n\nprint(f\"Timeout process deadlock-free: {is_deadlock_free(bounded)}\")\nprint(f\"Pipeline deadlock-free: {is_deadlock_free(rag_pipeline)}\")\n\nprint(\"\\nAll examples passed.\")\n</code></pre>"},{"location":"examples/mesh-topology/","title":"Mesh Topology","text":"<p>Source: <code>examples/mesh_topology.py</code></p> <p>This example demonstrates spectral topology analysis using <code>NetworkGraph</code> and <code>LaplacianAnalysis</code>. It builds different agent mesh topologies, compares their algebraic connectivity, and estimates consensus convergence times.</p>"},{"location":"examples/mesh-topology/#1-build-a-5-node-full-mesh","title":"1. Build a 5-Node Full Mesh","text":"<p>The example starts by constructing a fully connected graph of 5 agents.</p> <pre><code>from agenticraft_foundation.topology import (\n    NetworkGraph,\n    analyze_consensus_time,\n)\n\ngraph = NetworkGraph()\nfor i in range(5):\n    graph.add_node(f\"agent_{i}\")\n\n# Full mesh: every agent connected to every other\nfor i in range(5):\n    for j in range(i + 1, 5):\n        graph.add_edge(f\"agent_{i}\", f\"agent_{j}\")\n</code></pre> <p>A full mesh connects every agent to every other agent. With 5 nodes, this produces 10 edges. This is the densest possible topology and serves as the upper bound for connectivity metrics.</p>"},{"location":"examples/mesh-topology/#2-run-laplacian-analysis","title":"2. Run Laplacian Analysis","text":"<p>The <code>analyze()</code> method computes spectral properties of the graph Laplacian.</p> <pre><code>analysis = graph.analyze()\nprint(f\"Nodes: {analysis.num_nodes}\")\nprint(f\"Edges: {analysis.num_edges}\")\nprint(f\"Algebraic connectivity (lambda_2): {analysis.algebraic_connectivity:.4f}\")\nprint(f\"Spectral gap: {analysis.spectral_gap:.4f}\")\nprint(f\"Consensus bound: {analysis.consensus_bound:.4f}\")\nprint(f\"Is connected: {analysis.is_connected}\")\n</code></pre> <p>The key metric is algebraic connectivity (\\(\\lambda_2\\)) -- the second-smallest eigenvalue of the graph Laplacian matrix \\(L = D - A\\), where \\(D\\) is the degree matrix and \\(A\\) is the adjacency matrix. \\(\\lambda_2\\) quantifies how well-connected the graph is:</p> <ul> <li>\\(\\lambda_2 = 0\\) means the graph is disconnected (at least two components).</li> <li>Higher \\(\\lambda_2\\) means faster information propagation and more resilient consensus.</li> <li>The spectral gap (difference between the two smallest eigenvalues) indicates separation between connected and disconnected behavior.</li> <li>The consensus bound (\\(1 / \\lambda_2\\)) gives an upper bound on the time for distributed consensus to converge.</li> </ul>"},{"location":"examples/mesh-topology/#3-compare-topologies","title":"3. Compare Topologies","text":"<p>Three topologies are compared: full mesh, ring, and star.</p> <pre><code># Ring topology\nring = NetworkGraph()\nfor i in range(5):\n    ring.add_node(f\"agent_{i}\")\nfor i in range(5):\n    ring.add_edge(f\"agent_{i}\", f\"agent_{(i + 1) % 5}\")\n\n# Star topology\nstar = NetworkGraph()\nfor i in range(5):\n    star.add_node(f\"agent_{i}\")\nfor i in range(1, 5):\n    star.add_edge(\"agent_0\", f\"agent_{i}\")\n\nfor name, g in [(\"Full Mesh\", graph), (\"Ring\", ring), (\"Star\", star)]:\n    a = g.analyze()\n    print(f\"  {name:12s}: nodes={a.num_nodes}, edges={a.num_edges}, \"\n          f\"lambda_2={a.algebraic_connectivity:.4f}, connected={a.is_connected}\")\n</code></pre> <p>The comparison reveals a hierarchy:</p> <ul> <li>Full mesh: Highest \\(\\lambda_2\\). Every agent can communicate directly with every other. Maximum resilience but \\(O(n^2)\\) edges.</li> <li>Ring: Moderate \\(\\lambda_2\\). Each agent connects to two neighbors. Information must traverse up to \\(n/2\\) hops. \\(\\lambda_2\\) decreases as the ring grows.</li> <li>Star: Lower \\(\\lambda_2\\). All communication routes through the hub (agent_0). Removing the hub disconnects the entire network. The hub is a single point of failure.</li> </ul>"},{"location":"examples/mesh-topology/#4-interpret-lambda_2","title":"4. Interpret \\(\\lambda_2\\)","text":"<p>The algebraic connectivity directly predicts consensus performance.</p> <pre><code>mesh_analysis = graph.analyze()\nif mesh_analysis.algebraic_connectivity &gt; 0:\n    convergence_bound = 1.0 / mesh_analysis.algebraic_connectivity\n    print(f\"Full mesh convergence bound: {convergence_bound:.4f}\")\n\nring_analysis = ring.analyze()\nif ring_analysis.algebraic_connectivity &gt; 0:\n    convergence_bound = 1.0 / ring_analysis.algebraic_connectivity\n    print(f\"Ring convergence bound: {convergence_bound:.4f}\")\n</code></pre> <p>The convergence bound \\(1 / \\lambda_2\\) gives an upper estimate on how many rounds of message passing are needed for all agents to reach agreement. A lower bound means faster consensus:</p> <ul> <li>Full mesh converges fastest because every agent receives updates directly.</li> <li>Ring converges slowest because updates must propagate hop-by-hop around the cycle.</li> </ul>"},{"location":"examples/mesh-topology/#5-consensus-convergence-time","title":"5. Consensus Convergence Time","text":"<p>The <code>analyze_consensus_time()</code> function provides a direct estimate.</p> <pre><code>mesh_time = analyze_consensus_time(graph)\nring_time = analyze_consensus_time(ring)\nprint(f\"Consensus time (full mesh): {mesh_time:.4f}\")\nprint(f\"Consensus time (ring): {ring_time:.4f}\")\n</code></pre> <p>This function computes a convergence time estimate based on the spectral properties. The ratio <code>ring_time / mesh_time</code> quantifies the cost of using a sparser topology. For production systems, this tradeoff matters: full mesh has \\(O(n^2)\\) communication overhead but \\(O(1)\\) convergence, while ring has \\(O(n)\\) communication but \\(O(n^2)\\) convergence.</p> <p>The takeaway: higher algebraic connectivity means faster consensus and a more resilient mesh. Topology selection is a tradeoff between communication cost and convergence speed.</p> Complete source <pre><code>\"\"\"Spectral Topology Analysis -- Network resilience via Laplacian.\n\nDemonstrates LaplacianAnalysis for evaluating agent mesh topologies.\n\"\"\"\n\nfrom agenticraft_foundation.topology import (\n    NetworkGraph,\n    analyze_consensus_time,\n)\n\n# =============================================================\n# Build a 5-agent mesh topology\n# =============================================================\nprint(\"=== 5-Agent Mesh Topology ===\")\n\ngraph = NetworkGraph()\nfor i in range(5):\n    graph.add_node(f\"agent_{i}\")\n\n# Full mesh: every agent connected to every other\nfor i in range(5):\n    for j in range(i + 1, 5):\n        graph.add_edge(f\"agent_{i}\", f\"agent_{j}\")\n\n# Analyze\nanalysis = graph.analyze()\nprint(f\"Nodes: {analysis.num_nodes}\")\nprint(f\"Edges: {analysis.num_edges}\")\nprint(f\"Algebraic connectivity (lambda_2): {analysis.algebraic_connectivity:.4f}\")\nprint(f\"Spectral gap: {analysis.spectral_gap:.4f}\")\nprint(f\"Consensus bound: {analysis.consensus_bound:.4f}\")\nprint(f\"Is connected: {analysis.is_connected}\")\n\n# =============================================================\n# Compare topologies\n# =============================================================\nprint(\"\\n=== Topology Comparison ===\")\n\n# Ring topology\nring = NetworkGraph()\nfor i in range(5):\n    ring.add_node(f\"agent_{i}\")\nfor i in range(5):\n    ring.add_edge(f\"agent_{i}\", f\"agent_{(i + 1) % 5}\")\n\n# Star topology\nstar = NetworkGraph()\nfor i in range(5):\n    star.add_node(f\"agent_{i}\")\nfor i in range(1, 5):\n    star.add_edge(\"agent_0\", f\"agent_{i}\")\n\nfor name, g in [(\"Full Mesh\", graph), (\"Ring\", ring), (\"Star\", star)]:\n    a = g.analyze()\n    print(f\"  {name:12s}: nodes={a.num_nodes}, edges={a.num_edges}, \"\n          f\"lambda_2={a.algebraic_connectivity:.4f}, connected={a.is_connected}\")\n\n# Higher lambda_2 = faster consensus convergence\n# Full mesh &gt; Ring &gt; Star (for 5 nodes)\n\n# =============================================================\n# Consensus time analysis\n# =============================================================\nprint(\"\\n=== Consensus Convergence ===\")\n\nmesh_analysis = graph.analyze()\nif mesh_analysis.algebraic_connectivity &gt; 0:\n    convergence_bound = 1.0 / mesh_analysis.algebraic_connectivity\n    print(f\"Full mesh convergence bound: {convergence_bound:.4f}\")\n\nring_analysis = ring.analyze()\nif ring_analysis.algebraic_connectivity &gt; 0:\n    convergence_bound = 1.0 / ring_analysis.algebraic_connectivity\n    print(f\"Ring convergence bound: {convergence_bound:.4f}\")\n\n# Consensus time estimation\nmesh_time = analyze_consensus_time(graph)\nring_time = analyze_consensus_time(ring)\nprint(f\"\\nConsensus time (full mesh): {mesh_time:.4f}\")\nprint(f\"Consensus time (ring): {ring_time:.4f}\")\n\nprint(\"\\nHigher algebraic connectivity = faster consensus = more resilient mesh.\")\n</code></pre>"},{"location":"examples/probabilistic-verification/","title":"Probabilistic Verification","text":"<p>Source: <code>examples/probabilistic_verification.py</code></p> <p>This example uses Discrete-Time Markov Chains (DTMC) to model and verify probabilistic properties of stochastic agent systems -- LLM retry logic, provider fallback chains, and consensus convergence.</p>"},{"location":"examples/probabilistic-verification/#1-llm-agent-retry-model","title":"1. LLM Agent Retry Model","text":"<p>An LLM agent that calls an API, handling transient and permanent errors.</p> <pre><code>from agenticraft_foundation.verification import (\n    DTMC, check_reachability, expected_steps, steady_state,\n)\n\ndtmc = DTMC()\ndtmc.add_state(0, labels={\"idle\"})\ndtmc.add_state(1, labels={\"calling_llm\"})\ndtmc.add_state(2, labels={\"success\"})\ndtmc.add_state(3, labels={\"transient_error\"})\ndtmc.add_state(4, labels={\"permanent_error\"})\n\ndtmc.add_transition(0, 1, probability=1.0)\ndtmc.add_transition(1, 2, probability=0.85)   # 85% success\ndtmc.add_transition(1, 3, probability=0.12)   # 12% transient\ndtmc.add_transition(1, 4, probability=0.03)   # 3% permanent\ndtmc.add_transition(3, 1, probability=1.0)    # retry\ndtmc.add_transition(2, 2, probability=1.0)    # absorbing\ndtmc.add_transition(4, 4, probability=1.0)    # absorbing\n\ndtmc.validate()\n</code></pre> <p>Transition probabilities from each state must sum to 1.0. The <code>validate()</code> method checks this.</p>"},{"location":"examples/probabilistic-verification/#reachability-probability","title":"Reachability Probability","text":"<p>\"What's the probability of eventually reaching success?\"</p> <pre><code>result = check_reachability(dtmc, target_labels={\"success\"})\nprint(f\"P(success) = {result.probability:.6f}\")  # 0.965909\n</code></pre> <p>The system solves a linear system: \\(p(s) = \\sum_{s'} P(s, s') \\cdot p(s')\\) with boundary conditions \\(p(\\text{success}) = 1\\) and \\(p(\\text{permanent\\_error}) = 0\\).</p> <p>The retry loop amplifies the per-attempt 85% rate to 96.6% overall -- but the 3% permanent error rate caps it.</p>"},{"location":"examples/probabilistic-verification/#expected-steps","title":"Expected Steps","text":"<pre><code>steps = expected_steps(dtmc, target_labels={\"success\"})\nprint(f\"E[steps] = {steps.expected:.4f}\")  # 2.2727\n</code></pre> <p>On average, 2.27 steps to reach success (accounting for retries).</p>"},{"location":"examples/probabilistic-verification/#2-provider-fallback-chain","title":"2. Provider Fallback Chain","text":"<p>Three providers with decreasing reliability as fallbacks.</p> <pre><code>fallback = DTMC()\nfallback.add_state(0, labels={\"start\"})\nfallback.add_state(1, labels={\"primary\"})       # 95% success\nfallback.add_state(2, labels={\"secondary\"})     # 90% success\nfallback.add_state(3, labels={\"tertiary\"})      # 80% success\nfallback.add_state(4, labels={\"success\"})\nfallback.add_state(5, labels={\"total_failure\"})\n\nfallback.add_transition(0, 1, probability=1.0)\nfallback.add_transition(1, 4, probability=0.95)\nfallback.add_transition(1, 2, probability=0.05)\nfallback.add_transition(2, 4, probability=0.90)\nfallback.add_transition(2, 3, probability=0.10)\nfallback.add_transition(3, 4, probability=0.80)\nfallback.add_transition(3, 5, probability=0.20)\nfallback.add_transition(4, 4, probability=1.0)\nfallback.add_transition(5, 5, probability=1.0)\n\nresult = check_reachability(fallback, target_labels={\"success\"})\nprint(f\"P(success) = {result.probability:.6f}\")  # 0.999000\n</code></pre> <p>The cascade: \\(0.95 + 0.05 \\times 0.90 + 0.05 \\times 0.10 \\times 0.80 = 0.999\\). Three nines of reliability from providers that individually offer far less.</p>"},{"location":"examples/probabilistic-verification/#3-consensus-convergence","title":"3. Consensus Convergence","text":"<p>A gossip-based consensus model where convergence probability increases per round.</p> <pre><code>consensus = DTMC()\nconsensus.add_state(0, labels={\"round_0\", \"diverged\"})\nconsensus.add_state(1, labels={\"round_1\", \"diverged\"})\nconsensus.add_state(2, labels={\"round_2\", \"diverged\"})\nconsensus.add_state(3, labels={\"converged\"})\n\nconsensus.add_transition(0, 1, probability=0.6)\nconsensus.add_transition(0, 3, probability=0.4)\nconsensus.add_transition(1, 2, probability=0.3)\nconsensus.add_transition(1, 3, probability=0.7)\nconsensus.add_transition(2, 3, probability=1.0)\nconsensus.add_transition(3, 3, probability=1.0)\n</code></pre> <pre><code>steps = expected_steps(consensus, target_labels={\"converged\"})\nprint(f\"E[rounds] = {steps.expected:.4f}\")  # 1.7800\n</code></pre> <p>Guaranteed convergence within 3 rounds, expected in under 2.</p>"},{"location":"examples/probabilistic-verification/#4-ergodic-steady-state","title":"4. Ergodic Steady-State","text":"<p>An agent cycling through think/act/observe states indefinitely.</p> <pre><code>cycle = DTMC()\ncycle.add_state(0, labels={\"thinking\"})\ncycle.add_state(1, labels={\"acting\"})\ncycle.add_state(2, labels={\"observing\"})\n\ncycle.add_transition(0, 1, probability=0.8)\ncycle.add_transition(0, 2, probability=0.2)\ncycle.add_transition(1, 2, probability=1.0)\ncycle.add_transition(2, 0, probability=1.0)\n\ndist = steady_state(cycle)\n</code></pre> <p>The steady-state distribution \\(\\pi\\) satisfies \\(\\pi = \\pi P\\):</p> State Long-run fraction thinking 35.7% acting 28.6% observing 35.7% <p>This tells you the long-run resource allocation: the agent spends about a third of its time thinking, a third observing, and slightly less acting.</p>"},{"location":"examples/probabilistic-verification/#output","title":"Output","text":"<pre><code>=== LLM Agent Retry Model ===\nP(eventually success) = 0.965909\nE[steps to success] = 2.2727\n\n=== Provider Fallback Chain ===\nP(success with fallback chain) = 0.999000\nP(total failure) = 0.001000\n\n=== Consensus Convergence ===\nP(eventually converge) = 1.0000\nE[rounds to converge] = 1.7800\n\n=== Ergodic Agent Cycle ===\n  thinking: 35.7%\n  acting: 28.6%\n  observing: 35.7%\n</code></pre>"},{"location":"examples/protocol-verification/","title":"Protocol Verification","text":"<p>Source: <code>examples/protocol_verification.py</code></p> <p>This example demonstrates Multiparty Session Types (MPST) for specifying and verifying communication protocols between agents. It covers global type definitions, projection to local types, and well-formedness checking.</p>"},{"location":"examples/protocol-verification/#1-define-a-request-response-protocol","title":"1. Define a Request-Response Protocol","text":"<p>The simplest protocol: a client sends a request and receives a response.</p> <pre><code>from agenticraft_foundation.mpst import (\n    Projector,\n    SessionTypeChecker,\n    end,\n    msg,\n    project_all,\n    request_response,\n)\n\n# Global type: Client sends request to Server, Server sends response to Client\nprotocol = request_response(\"client\", \"server\")\nprint(f\"Protocol: {protocol}\")\n</code></pre> <p>The <code>request_response()</code> convenience function creates a global type with two message exchanges. A global type describes the entire protocol from a bird's-eye view -- it specifies who sends what to whom, and in what order. This is the specification that all participants must conform to.</p>"},{"location":"examples/protocol-verification/#2-project-to-local-types","title":"2. Project to Local Types","text":"<p>Each participant gets a local view of the protocol.</p> <pre><code>projector = Projector()\nclient_type = projector.project(protocol, \"client\")\nserver_type = projector.project(protocol, \"server\")\nprint(f\"Client view: {client_type}\")\nprint(f\"Server view: {server_type}\")\n</code></pre> <p>Projection extracts the local type for a single participant from the global type. The client's local type describes what the client does: send a request, then receive a response. The server's local type is the dual: receive a request, then send a response. Projection guarantees that if each participant follows their local type, the overall protocol is satisfied.</p>"},{"location":"examples/protocol-verification/#3-check-well-formedness","title":"3. Check Well-Formedness","text":"<p>The protocol is validated for structural correctness.</p> <pre><code>checker = SessionTypeChecker()\nresult = checker.check_well_formed(protocol)\nprint(f\"Well-formed: {result.is_well_formed}\")\n</code></pre> <p>Well-formedness ensures the global type is a valid protocol specification. The checker verifies properties such as:</p> <ul> <li>Every message has a defined sender and receiver.</li> <li>No participant sends a message to itself.</li> <li>The protocol terminates (reaches <code>end</code>).</li> <li>Branching is deterministic from the perspective of each participant.</li> </ul> <p>A well-formed protocol can be safely projected and implemented.</p>"},{"location":"examples/protocol-verification/#4-build-a-custom-3-party-protocol","title":"4. Build a Custom 3-Party Protocol","text":"<p>A more complex RAG (retrieval-augmented generation) protocol with three participants.</p> <pre><code>rag_protocol = msg(\n    \"client\", \"retriever\", \"query\",\n    msg(\n        \"retriever\", \"processor\", \"documents\",\n        msg(\n            \"processor\", \"client\", \"summary\",\n            end(),\n        ),\n    ),\n)\n\nprint(f\"RAG Protocol: {rag_protocol}\")\n</code></pre> <p>The <code>msg()</code> function constructs a message exchange: <code>msg(sender, receiver, label, continuation)</code>. The RAG protocol specifies three steps:</p> <ol> <li>The client sends a <code>query</code> to the retriever.</li> <li>The retriever sends <code>documents</code> to the processor.</li> <li>The processor sends a <code>summary</code> back to the client.</li> </ol> <p>Each <code>msg()</code> call nests the continuation, building a sequential protocol. The <code>end()</code> at the bottom terminates the protocol.</p>"},{"location":"examples/protocol-verification/#5-project-and-validate-the-custom-protocol","title":"5. Project and Validate the Custom Protocol","text":"<p>All participants get their local views, and the protocol is verified.</p> <pre><code>all_projections = project_all(\n    rag_protocol,\n    participants=[\"client\", \"retriever\", \"processor\"],\n)\n\nfor participant, local_type in all_projections.items():\n    print(f\"  {participant}: {local_type}\")\n\nresult = checker.check_well_formed(rag_protocol)\nprint(f\"Well-formed: {result.is_well_formed}\")\nif not result.is_well_formed:\n    for error in result.errors:\n        print(f\"  Error: {error}\")\n</code></pre> <p>The <code>project_all()</code> convenience function projects the global type for every participant at once. Each local type describes that participant's obligations:</p> <ul> <li>client: Send <code>query</code> to retriever, then receive <code>summary</code> from processor.</li> <li>retriever: Receive <code>query</code> from client, then send <code>documents</code> to processor.</li> <li>processor: Receive <code>documents</code> from retriever, then send <code>summary</code> to client.</li> </ul> <p>The well-formedness check validates the complete protocol. If errors are found, they are reported with details about which property was violated.</p> <p>This approach enables protocol-first development: define the global type, verify it, project to local types, and implement each participant against its local type. The type system guarantees that the composed system conforms to the specification.</p> Complete source <pre><code>\"\"\"Protocol Verification -- Multiparty Session Types.\n\nDemonstrates SessionMonitor and SessionTypeChecker for protocol conformance.\n\"\"\"\n\nfrom agenticraft_foundation.mpst import (\n    Projector,\n    SessionTypeChecker,\n    end,\n    msg,\n    project_all,\n    request_response,\n)\n\n# =============================================================\n# Define a request-response protocol\n# =============================================================\nprint(\"=== Request-Response Protocol ===\")\n\n# Global type: Client sends request to Server, Server sends response to Client\nprotocol = request_response(\"client\", \"server\")\nprint(f\"Protocol: {protocol}\")\n\n# Project to local types\nprojector = Projector()\nclient_type = projector.project(protocol, \"client\")\nserver_type = projector.project(protocol, \"server\")\nprint(f\"Client view: {client_type}\")\nprint(f\"Server view: {server_type}\")\n\n# Verify well-formedness\nchecker = SessionTypeChecker()\nresult = checker.check_well_formed(protocol)\nprint(f\"Well-formed: {result.is_well_formed}\")\n\n# =============================================================\n# Build a more complex protocol manually\n# =============================================================\nprint(\"\\n=== Custom Multi-Party Protocol ===\")\n\n# Three-party protocol:\n# 1. Client sends \"query\" to Retriever\n# 2. Retriever sends \"documents\" to Processor\n# 3. Processor sends \"summary\" to Client\nrag_protocol = msg(\n    \"client\", \"retriever\", \"query\",\n    msg(\n        \"retriever\", \"processor\", \"documents\",\n        msg(\n            \"processor\", \"client\", \"summary\",\n            end(),\n        ),\n    ),\n)\n\nprint(f\"RAG Protocol: {rag_protocol}\")\n\n# Project all participants\nall_projections = project_all(\n    rag_protocol,\n    participants=[\"client\", \"retriever\", \"processor\"],\n)\n\nfor participant, local_type in all_projections.items():\n    print(f\"  {participant}: {local_type}\")\n\n# Verify\nresult = checker.check_well_formed(rag_protocol)\nprint(f\"Well-formed: {result.is_well_formed}\")\nif not result.is_well_formed:\n    for error in result.errors:\n        print(f\"  Error: {error}\")\n\nprint(\"\\nProtocol verification complete.\")\n</code></pre>"},{"location":"examples/temporal-verification/","title":"Temporal Verification","text":"<p>Source: <code>examples/temporal_verification.py</code></p> <p>This example uses CTL (Computation Tree Logic) to verify temporal properties of a multi-agent task assignment system. CTL formulas express properties like \"always\", \"eventually\", and \"until\" over labeled transition systems.</p>"},{"location":"examples/temporal-verification/#1-build-the-agent-process","title":"1. Build the Agent Process","text":"<p>A task assignment agent that receives tasks, processes them, and either succeeds or retries on failure.</p> <pre><code>from agenticraft_foundation import (\n    Event, ExternalChoice, Prefix, Recursion, Stop, Variable, build_lts,\n)\n\nreceive = Event(\"receive_task\")\nprocess = Event(\"process\")\nsucceed = Event(\"succeed\")\nfail = Event(\"fail\")\nretry = Event(\"retry\")\n\nagent = Recursion(\n    variable=\"X\",\n    body=Prefix(\n        receive,\n        Prefix(\n            process,\n            ExternalChoice(\n                left=Prefix(succeed, Stop()),\n                right=Prefix(fail, Prefix(retry, Variable(\"X\"))),\n            ),\n        ),\n    ),\n)\n\nlts = build_lts(agent, max_states=50)\n</code></pre> <p>The <code>Recursion</code> operator creates a loop: on failure, the agent retries the entire task. This means the LTS has a cycle through the fail/retry path.</p>"},{"location":"examples/temporal-verification/#2-label-states-with-atomic-propositions","title":"2. Label States with Atomic Propositions","text":"<p>CTL model checking requires a labeling function that maps each state to a set of atomic propositions.</p> <pre><code>labeling = {s: set() for s in lts.states}\nlabeling[lts.initial_state].add(\"idle\")\n\nfor s in lts.states:\n    outgoing = {e for e, _ in lts.successors(s)}\n    if receive in outgoing:\n        labeling[s].add(\"idle\")\n    if process in outgoing:\n        labeling[s].add(\"received\")\n    if succeed in outgoing or fail in outgoing:\n        labeling[s].add(\"processing\")\n    if retry in outgoing:\n        labeling[s].add(\"failed\")\n    if not outgoing:\n        labeling[s].add(\"done\")\n</code></pre> <p>Each state gets labeled based on its outgoing events. Terminal states (no outgoing transitions) are labeled <code>done</code>.</p>"},{"location":"examples/temporal-verification/#3-safety-no-error-states","title":"3. Safety: No Error States","text":"<p>AG(not error) -- \"In all reachable states, error never holds.\"</p> <pre><code>from agenticraft_foundation.verification import check_safety\n\nresult = check_safety(lts, \"error\", labeling)\nprint(f\"No error states: {result.satisfied}\")  # True\n</code></pre> <p>Since we never labeled any state <code>error</code>, this trivially holds. In practice, you'd label error states and verify the system avoids them.</p>"},{"location":"examples/temporal-verification/#4-liveness-always-terminates","title":"4. Liveness: Always Terminates?","text":"<p>AF(done) -- \"From every state, done is eventually reached.\"</p> <pre><code>from agenticraft_foundation.verification import check_liveness\n\nresult = check_liveness(lts, \"done\", labeling)\nprint(f\"Always terminates: {result.satisfied}\")  # False\n</code></pre> <p>This is False -- the retry loop means the agent can cycle <code>receive -&gt; process -&gt; fail -&gt; retry</code> indefinitely. CTL correctly identifies that there exists an infinite path that never reaches <code>done</code>. This is a key insight: the agent can succeed but isn't guaranteed to.</p>"},{"location":"examples/temporal-verification/#5-existential-reachability","title":"5. Existential Reachability","text":"<p>EF(done) -- \"There exists a path to a done state.\"</p> <pre><code>from agenticraft_foundation.verification import model_check, EF, Atomic\n\nresult = model_check(lts, EF(Atomic(\"done\")), labeling)\nprint(f\"Can reach done: {result.satisfied}\")  # True\n</code></pre> <p>While termination isn't guaranteed (AF fails), success is possible (EF holds). The distinction between AF and EF is central to CTL.</p>"},{"location":"examples/temporal-verification/#6-mutual-exclusion","title":"6. Mutual Exclusion","text":"<p>A classic verification example: two processes should never be in their critical sections simultaneously.</p> <pre><code>from agenticraft_foundation.verification import AG, Not, And\n\n# AG(not (critical_a AND critical_b))\nresult = model_check(\n    mutex_lts,\n    AG(Not(And(Atomic(\"critical_a\"), Atomic(\"critical_b\")))),\n    mutex_labels,\n)\nprint(f\"Mutual exclusion holds: {result.satisfied}\")  # True\n</code></pre> <p>The model checker exhaustively verifies that no reachable state has both agents in their critical sections.</p>"},{"location":"examples/temporal-verification/#key-ctl-operators","title":"Key CTL Operators","text":"Operator Meaning <code>AG(f)</code> f holds in all states on all paths (safety) <code>AF(f)</code> f eventually holds on all paths (liveness) <code>EF(f)</code> f is reachable on some path <code>EG(f)</code> f persists along some infinite path <code>AU(f, g)</code> f holds until g on all paths <code>EU(f, g)</code> f holds until g on some path"},{"location":"examples/temporal-verification/#output","title":"Output","text":"<pre><code>=== Task Assignment Agent ===\nStates: 5\nTransitions: 5\n\n=== Safety: errors never occur ===\n  No error states: True\n\n=== Liveness: task always eventually completes ===\n  Always terminates: False\n\n=== Existential reachability: success is possible ===\n  Can reach done: True\n\n=== Mutual Exclusion Model ===\n  Mutual exclusion holds: True\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#install-with-uv-recommended","title":"Install with uv (recommended)","text":"<p>uv is the recommended package manager for Python projects.</p> <pre><code>uv add agenticraft-foundation\n</code></pre>"},{"location":"getting-started/installation/#install-with-pip","title":"Install with pip","text":"<pre><code>pip install agenticraft-foundation\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify installation","text":"<pre><code>python -c \"import agenticraft_foundation; print(agenticraft_foundation.__version__)\"\n</code></pre> <p>This should print the installed version (e.g., <code>0.1.0</code>).</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10+</li> <li>Zero runtime dependencies -- the library uses only the Python standard library. No NumPy, no SciPy, no external packages.</li> </ul>"},{"location":"getting-started/installation/#development-setup","title":"Development setup","text":"<p>For contributors who want to run tests and work on the codebase:</p> <pre><code># Clone the repository\ngit clone https://github.com/agenticraft/agenticraft-foundation.git\ncd agenticraft-foundation\n\n# Install with development dependencies\nuv sync --group dev\n\n# Verify the test suite passes\nuv run pytest tests/ -v\n</code></pre> <p>The full test suite (1,012 tests) should complete in under a minute on most machines. All tests run without network access or external services.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Four self-contained examples demonstrating the core modules. Each runs independently with no external dependencies.</p>"},{"location":"getting-started/quickstart/#1-csp-deadlock-detection","title":"1. CSP Deadlock Detection","text":"<p>The <code>algebra</code> module implements CSP (Communicating Sequential Processes) for modeling agent coordination. This example builds an interruptible agent task, constructs its labeled transition system, and checks for deadlock freedom.</p> <pre><code>from agenticraft_foundation import (\n    Event, Prefix, Stop, Parallel,\n    Interrupt, Timeout, Guard, TIMEOUT_EVENT,\n    build_lts, traces, detect_deadlock, is_deadlock_free,\n)\n\nprocess_data = Event(\"process_data\")\nhandle_priority = Event(\"handle_priority\")\nreturn_result = Event(\"return_result\")\n\ntask = Prefix(process_data, Prefix(return_result, Stop()))\nhandler = Prefix(handle_priority, Stop())\nagent = Interrupt(primary=task, handler=handler)\n\nassert process_data in agent.initials()\nassert handle_priority in agent.initials()\n\nfallback = Prefix(Event(\"return_cached\"), Stop())\nbounded = Timeout(process=agent, duration=30.0, fallback=fallback)\n\nlts = build_lts(bounded)\nprint(f\"States: {len(lts.states)}\")\nprint(f\"Deadlock-free: {is_deadlock_free(bounded)}\")\n</code></pre> <p>The <code>Interrupt</code> operator lets a priority handler pre-empt a running task -- a common pattern in multi-agent systems where urgent messages must take precedence. The <code>Timeout</code> wraps the process with a fallback path if the agent does not complete within the given duration. <code>build_lts</code> expands the process into a finite-state labeled transition system, and <code>is_deadlock_free</code> checks that no reachable state has zero outgoing transitions.</p>"},{"location":"getting-started/quickstart/#2-mpst-protocol-projection","title":"2. MPST Protocol Projection","text":"<p>The <code>mpst</code> module implements multiparty session types for specifying and verifying multi-agent communication protocols. This example defines a client-server request-response protocol, projects it to per-role local types, and checks well-formedness.</p> <pre><code>from agenticraft_foundation.mpst import (\n    GlobalInteraction, GlobalType, Projector,\n    SessionTypeChecker,\n)\n\nprotocol = GlobalType(interactions=[\n    GlobalInteraction(sender=\"client\", receiver=\"server\", message_type=\"Request\"),\n    GlobalInteraction(sender=\"server\", receiver=\"client\", message_type=\"Response\"),\n])\n\nprojector = Projector()\nlocal_client = projector.project(protocol, \"client\")\nlocal_server = projector.project(protocol, \"server\")\n\nchecker = SessionTypeChecker()\nresult = checker.check_well_formedness(protocol)\nprint(f\"Well-formed: {result.is_valid}\")\n</code></pre> <p>A <code>GlobalType</code> specifies the entire protocol from a bird's-eye view. The <code>Projector</code> derives each participant's local view -- what they send and what they expect to receive. <code>SessionTypeChecker</code> verifies that the global protocol is well-formed: every send has a matching receive, no role is left waiting indefinitely, and the protocol terminates.</p>"},{"location":"getting-started/quickstart/#3-protocol-aware-routing","title":"3. Protocol-Aware Routing","text":"<p>The <code>protocols</code> module provides protocol-aware routing across heterogeneous agent networks. This example builds a protocol graph with agents supporting different protocols and finds the optimal route using Dijkstra's algorithm with protocol translation costs.</p> <pre><code>from agenticraft_foundation.protocols import (\n    ProtocolGraph, ProtocolAwareDijkstra,\n    PathCostCalculator, ProtocolCompatibilityMatrix,\n    PROTOCOL_COMPATIBILITY,\n)\nfrom agenticraft_foundation.types import ProtocolName\n\ngraph = ProtocolGraph()\ngraph.add_agent(\"gateway\", [\"routing\"], {ProtocolName.MCP, ProtocolName.A2A})\ngraph.add_agent(\"analyzer\", [\"analysis\"], {ProtocolName.MCP})\ngraph.add_agent(\"reporter\", [\"output\"], {ProtocolName.MCP, ProtocolName.A2A})\ngraph.add_edge(\"gateway\", \"analyzer\", {ProtocolName.MCP})\ngraph.add_edge(\"analyzer\", \"reporter\", {ProtocolName.MCP})\n\ncompat = ProtocolCompatibilityMatrix(PROTOCOL_COMPATIBILITY)\ncalc = PathCostCalculator(graph, compat)\ndijkstra = ProtocolAwareDijkstra(graph, compat, calc)\nroute = dijkstra.find_optimal_route(\"gateway\", \"reporter\", ProtocolName.MCP)\nprint(f\"Path: {route.path}, Cost: {route.total_cost:.2f}\")\n</code></pre> <p>The <code>ProtocolGraph</code> models agents as nodes annotated with their supported protocols and capabilities. <code>ProtocolCompatibilityMatrix</code> encodes the cost of translating between protocols (e.g., MCP to A2A). <code>ProtocolAwareDijkstra</code> finds the lowest-cost path that respects protocol constraints, factoring in both hop distance and translation overhead.</p>"},{"location":"getting-started/quickstart/#4-topology-spectral-analysis","title":"4. Topology Spectral Analysis","text":"<p>The <code>topology</code> module provides spectral analysis of agent network topologies. This example builds a fully connected 5-agent network and computes its algebraic connectivity -- a measure of how resilient the network is to agent failures.</p> <pre><code>from agenticraft_foundation.topology import NetworkGraph, LaplacianAnalysis\n\ngraph = NetworkGraph()\nfor i in range(5):\n    graph.add_node(f\"agent_{i}\")\nfor i in range(5):\n    for j in range(i + 1, 5):\n        graph.add_edge(f\"agent_{i}\", f\"agent_{j}\")\n\nanalysis = LaplacianAnalysis(graph)\nprint(f\"Nodes: {analysis.num_nodes}\")\nprint(f\"Algebraic connectivity (lambda_2): {analysis.algebraic_connectivity:.4f}\")\nprint(f\"Consensus bound: {analysis.consensus_bound:.2f}\")\n</code></pre> <p>The Laplacian matrix of a graph encodes its connectivity structure. Its second-smallest eigenvalue (\\(\\lambda_2\\), the algebraic connectivity) quantifies how well-connected the network is: higher values mean faster consensus convergence and greater resilience to node removal. The consensus bound gives the theoretical upper limit on rounds needed for distributed agreement. A fully connected graph of 5 nodes has \\(\\lambda_2 = 5.0\\) -- the maximum for that size.</p>"},{"location":"getting-started/why-formal-methods/","title":"Why Formal Methods?","text":""},{"location":"getting-started/why-formal-methods/#the-problem","title":"The Problem","text":"<p>Multi-agent systems fail in production because coordination bugs are invisible until runtime. An agent deadlocks waiting for a message that will never arrive. A protocol mismatch silently drops requests between services using different communication standards. A network partition splits the agent mesh into disconnected components that can never reach consensus.</p> <p>Testing alone cannot cover this. A system with 10 agents, each with 5 possible states, has 5^10 (roughly 10 million) reachable configurations. Add message ordering, timeouts, and failure modes, and the state space grows combinatorially. Integration tests cover a tiny fraction of possible executions. The bugs that bring down production systems live in the states that tests never reach.</p> <p>Formal verification takes a different approach. Instead of sampling executions, it reasons about all possible executions simultaneously. A deadlock-freedom proof guarantees that no reachable state -- out of millions -- is a deadlock. A refinement proof guarantees that the implementation matches its specification for every possible input sequence, not just the ones in the test suite.</p>"},{"location":"getting-started/why-formal-methods/#what-formal-verification-catches","title":"What Formal Verification Catches","text":"<p>Deadlock detection. Identify states where no agent can make progress. In a multi-agent pipeline, this catches circular dependencies (A waits for B, B waits for C, C waits for A) before deployment.</p> <p>Trace analysis. Enumerate and verify all possible execution sequences. Confirm that a required event always eventually occurs, or that two events never happen in the wrong order.</p> <p>Refinement checking. Prove that an implementation is a correct refinement of its specification. If the spec says \"the system never loses a message,\" refinement checking verifies this holds for the actual process algebra model.</p> <p>Protocol verification. Ensure multi-party communication protocols are well-formed. Every send has a matching receive, no role is left waiting indefinitely, and the protocol terminates. Catches mismatches between agents speaking different protocol versions.</p> <p>Spectral analysis. Quantify the resilience of an agent network topology. The algebraic connectivity (\\(\\lambda_2\\) of the graph Laplacian) directly predicts how many node failures the network can tolerate and how fast distributed consensus converges.</p> <p>Workflow validation. Verify that a protocol workflow is executable before deploying it. Check that all preconditions can be satisfied, that task assignments respect agent capabilities, and that the workflow terminates.</p> <p>Fault tolerance modeling. Model both classical distributed systems failures (crash, Byzantine, omission) and LLM-specific failure modes (hallucination, quality degradation, latency spikes). Compute theoretical bounds on system behavior under failure.</p>"},{"location":"getting-started/why-formal-methods/#decision-matrix","title":"Decision Matrix","text":"<p>Use this table to find the right module for your verification need.</p> If you need to... Use module Key capability Verify agent coordination is deadlock-free algebra CSP process algebra with LTS construction, trace enumeration, and deadlock detection across 13 process operators Ensure multi-party protocols are well-formed mpst Multiparty session types with global-to-local projection and well-formedness checking Find optimal message routes across protocols protocols Protocol-aware Dijkstra routing with compatibility matrices and translation cost modeling Quantify network resilience topology Spectral Laplacian analysis with algebraic connectivity, consensus bounds, and bridge detection Model consensus with quality weights specifications Weighted consensus specifications with agreement/validity properties and BDI/Contract Net mappings Bound algorithm complexity complexity 30+ theoretical complexity bounds with classical and LLM-specific fault models Check runtime invariants verification Invariant checking, CTL temporal logic model checking, DTMC probabilistic analysis, counterexample generation Apply to real protocols integration Adapters applying formal verification to protocol session types and workflow verification"},{"location":"getting-started/why-formal-methods/#when-formal-methods-pay-off","title":"When Formal Methods Pay Off","text":"<p>Formal verification has a cost: you write specifications, not just code. The payoff is highest when:</p> <ul> <li>Coordination logic is non-trivial. Two agents passing messages is simple. Ten agents with conditional branching, timeouts, and fallback paths is where hidden deadlocks live.</li> <li>Failures are expensive. If a stuck pipeline means lost revenue or corrupted data, proving deadlock freedom before deployment is cheaper than debugging in production.</li> <li>The system evolves. Refinement checking ensures that changes to agent behavior still satisfy the original specification. This catches regressions that unit tests miss.</li> <li>You need to reason about topology. Spectral analysis gives quantitative answers to questions like \"how many agents can fail before consensus breaks?\" -- answers that no amount of testing can provide.</li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>These are hands-on tutorials that walk you through building real verification workflows with <code>agenticraft-foundation</code>. Each tutorial is self-contained and produces working code you can extend for your own multi-agent systems.</p> <p>All tutorials use only <code>agenticraft-foundation</code> -- no external dependencies required.</p>"},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or later</li> <li><code>agenticraft-foundation</code> installed:</li> </ul> <pre><code>pip install agenticraft-foundation\n</code></pre>"},{"location":"tutorials/#tutorial-index","title":"Tutorial Index","text":"Tutorial What You'll Learn Time Modeling Agent Coordination with CSP Build CSP models, analyze LTS, detect deadlocks 15 min Verifying Protocols with Session Types Define global types, project to local types, verify well-formedness 15 min Multi-Protocol Routing Build protocol graphs, routing algorithms, workflow validation 20 min Analyzing Mesh Topologies Spectral analysis, topology comparison, hypergraph coordination 15 min Formal Consensus Verification Consensus properties, weighted consensus, MAS theory mappings 15 min Checking Temporal Properties with CTL CTL formulas, safety, liveness, response properties, counterexamples 15 min Modeling Stochastic Agents with DTMC Markov chains, reachability probability, expected steps, steady-state 15 min"},{"location":"tutorials/#suggested-order","title":"Suggested Order","text":"<p>The tutorials are designed to be read in order, but each is self-contained. If you are new to formal methods for multi-agent systems, start with the CSP tutorial to build intuition for process-algebraic modeling, then proceed through session types and protocol routing. If you are primarily interested in topology or consensus, you can skip directly to those tutorials. The verification tutorials (CTL and DTMC) build on CSP concepts, so read the CSP tutorial first if you haven't already.</p>"},{"location":"tutorials/#getting-help","title":"Getting Help","text":"<p>If you run into issues, check the API Reference for detailed method signatures, or the Concepts section for background on the formal foundations.</p>"},{"location":"tutorials/consensus-verification/","title":"Formal Consensus Verification","text":"<p>Time: 15 minutes</p> <p>In this tutorial, you will model consensus states for a multi-agent system, verify classical consensus properties (agreement, validity, integrity, termination), extend to weighted consensus with quality-based agent weights, and explore MAS theory mappings for BDI and Contract Net protocols.</p>"},{"location":"tutorials/consensus-verification/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li><code>agenticraft-foundation</code> installed</li> <li>Familiarity with the idea of distributed consensus (multiple agents agreeing on a value)</li> </ul>"},{"location":"tutorials/consensus-verification/#what-youll-build","title":"What You'll Build","text":"<p>A consensus verification workflow for a 3-agent system. You will:</p> <ol> <li>Define consensus states with proposals and decisions</li> <li>Verify the four classical consensus properties</li> <li>Model weighted consensus with agent quality weights</li> <li>Map consensus states to MAS theory frameworks (BDI and Contract Net)</li> </ol>"},{"location":"tutorials/consensus-verification/#step-1-define-consensus-states","title":"Step 1: Define Consensus States","text":"<p>A consensus state captures a snapshot of a distributed agreement protocol. It records what each agent proposed, what each agent decided (if anything), and which processes are correct (not faulty).</p> <pre><code>from agenticraft_foundation.specifications import (\n    ConsensusState, ConsensusProperty,\n    AgreementProperty, ValidityProperty,\n    IntegrityProperty, TerminationProperty,\n)\n\n# Create consensus state with 3 agents\nstate = ConsensusState(\n    proposals={\"agent_0\": \"value_a\", \"agent_1\": \"value_a\", \"agent_2\": \"value_b\"},\n    decisions={\"agent_0\": \"value_a\", \"agent_1\": \"value_a\"},\n    correct_processes={\"agent_0\", \"agent_1\", \"agent_2\"},\n)\n</code></pre> <p>In this state, all three agents have made proposals. Agents 0 and 1 proposed \"value_a\", while agent 2 proposed \"value_b\". So far, agents 0 and 1 have decided on \"value_a\", but agent 2 has not yet decided. All three agents are marked as correct (non-faulty).</p> <p>This is a realistic mid-protocol snapshot. In a running system, you would capture these states at checkpoints and verify properties to ensure the protocol is behaving correctly.</p>"},{"location":"tutorials/consensus-verification/#step-2-verify-consensus-properties","title":"Step 2: Verify Consensus Properties","text":"<p>The classical consensus properties are the foundation of distributed systems correctness. Each property captures a different aspect of what it means for agents to agree correctly.</p> <pre><code>agreement = AgreementProperty()\nvalidity = ValidityProperty()\n\nprint(f\"Agreement holds: {agreement.verify(state)}\")\nprint(f\"Validity holds: {validity.verify(state)}\")\n</code></pre> <p>Agreement requires that no two correct processes decide differently. In our state, agents 0 and 1 both decided \"value_a\", so agreement holds. If agent 1 had decided \"value_b\" instead, agreement would be violated.</p> <p>Validity requires that any decision value was proposed by some process. Since \"value_a\" was proposed by agents 0 and 1, and it is the decided value, validity holds. This property prevents the protocol from deciding on a value that nobody proposed.</p> <p>There are two additional properties worth understanding, even though they may not hold for every mid-protocol snapshot:</p> <p>Integrity requires that every correct process decides at most once. This prevents flip-flopping, which would undermine the stability of the consensus.</p> <p>Termination requires that every correct process eventually decides. In our snapshot, agent 2 has not yet decided, so termination does not hold yet -- but it should hold once the protocol completes.</p>"},{"location":"tutorials/consensus-verification/#step-3-weighted-consensus","title":"Step 3: Weighted Consensus","text":"<p>In many multi-agent systems, not all agents are equal. An agent backed by a more capable model, or one with a track record of higher accuracy, should have more influence on the consensus outcome. Weighted consensus formalizes this.</p> <pre><code>from agenticraft_foundation.specifications import (\n    WeightedConsensusState, WeightedAgreement, WeightedQuorum,\n)\n\nweighted_state = WeightedConsensusState(\n    proposals={\"agent_0\": \"value_a\", \"agent_1\": \"value_a\", \"agent_2\": \"value_b\"},\n    decisions={\"agent_0\": \"value_a\", \"agent_1\": \"value_a\"},\n    correct_processes={\"agent_0\", \"agent_1\", \"agent_2\"},\n    weights={\"agent_0\": 0.5, \"agent_1\": 0.3, \"agent_2\": 0.2},\n)\n\nweighted_agreement = WeightedAgreement()\nweighted_quorum = WeightedQuorum()\n\nprint(f\"Weighted agreement: {weighted_agreement.verify(weighted_state)}\")\nprint(f\"Weighted quorum: {weighted_quorum.verify(weighted_state)}\")\n</code></pre> <p>The <code>weights</code> dictionary assigns a weight to each agent. Here, agent 0 has weight 0.5 (the most influential), agent 1 has 0.3, and agent 2 has 0.2. The weights should sum to 1.0.</p> <p>Weighted agreement extends classical agreement by requiring that the decided value has sufficient weighted support. Weighted quorum checks whether the agents that have decided represent a sufficient fraction of the total weight. In this case, agents 0 and 1 together have weight 0.8, which is a strong quorum.</p> <p>This is directly applicable to multi-agent systems where you use ensemble methods or voting among LLM agents. The weights can represent model quality scores, historical accuracy, or confidence levels.</p>"},{"location":"tutorials/consensus-verification/#step-4-mas-theory-mappings","title":"Step 4: MAS Theory Mappings","text":"<p>The consensus framework connects to broader multi-agent systems theory through mappings. These mappings translate domain-specific structures (like BDI mental states or Contract Net negotiations) into the consensus formalism, allowing you to apply the same verification properties.</p> <pre><code>from agenticraft_foundation.specifications import BDIMapping, ContractNetMapping\n\nbdi = BDIMapping()\nbdi_state = bdi.map_to_mas({\n    \"beliefs\": {\"context\": \"current_state\"},\n    \"desires\": {\"objective\": \"complete_task\"},\n    \"intentions\": {\"assignment\": \"agent_0\"},\n})\nprint(f\"BDI mapping: {bdi_state}\")\n\ncontract_net = ContractNetMapping()\ncn_state = contract_net.map_to_mas({\n    \"cfp\": \"task_description\",\n    \"bids\": {\"agent_0\": 0.9, \"agent_1\": 0.7},\n    \"award\": \"agent_0\",\n})\nprint(f\"Contract Net mapping: {cn_state}\")\n</code></pre> <p>The BDI (Belief-Desire-Intention) mapping translates the classic BDI agent architecture into MAS theory terms. Beliefs represent the agent's model of the world, desires represent its goals, and intentions represent its committed plans. The mapping produces a structured state that can be analyzed for consistency and completeness.</p> <p>The Contract Net mapping translates a Contract Net Protocol interaction -- where a manager issues a call for proposals (CFP), agents bid, and the manager awards the task -- into a consensus-compatible structure. The bids can be mapped to proposals, and the award can be mapped to a decision, allowing you to verify properties like validity (the awarded agent actually bid) and agreement (only one agent was awarded).</p> <p>These mappings are extensible. If your multi-agent system uses a different coordination pattern (auction, marketplace, negotiation), you can create custom mappings that translate your domain-specific state into the consensus formalism and reuse all the verification properties.</p>"},{"location":"tutorials/consensus-verification/#complete-script","title":"Complete Script","text":"<pre><code>\"\"\"Consensus Verification Tutorial - Complete Script\n\nModels consensus states, verifies properties, uses weighted consensus,\nand explores MAS theory mappings.\n\"\"\"\nfrom agenticraft_foundation.specifications import (\n    ConsensusState, ConsensusProperty,\n    AgreementProperty, ValidityProperty,\n    IntegrityProperty, TerminationProperty,\n    WeightedConsensusState, WeightedAgreement, WeightedQuorum,\n    BDIMapping, ContractNetMapping,\n)\n\n# Step 1: Define consensus state\nstate = ConsensusState(\n    proposals={\"agent_0\": \"value_a\", \"agent_1\": \"value_a\", \"agent_2\": \"value_b\"},\n    decisions={\"agent_0\": \"value_a\", \"agent_1\": \"value_a\"},\n    correct_processes={\"agent_0\", \"agent_1\", \"agent_2\"},\n)\n\n# Step 2: Verify consensus properties\nagreement = AgreementProperty()\nvalidity = ValidityProperty()\n\nprint(f\"Agreement holds: {agreement.verify(state)}\")\nprint(f\"Validity holds: {validity.verify(state)}\")\n\n# Step 3: Weighted consensus\nweighted_state = WeightedConsensusState(\n    proposals={\"agent_0\": \"value_a\", \"agent_1\": \"value_a\", \"agent_2\": \"value_b\"},\n    decisions={\"agent_0\": \"value_a\", \"agent_1\": \"value_a\"},\n    correct_processes={\"agent_0\", \"agent_1\", \"agent_2\"},\n    weights={\"agent_0\": 0.5, \"agent_1\": 0.3, \"agent_2\": 0.2},\n)\n\nweighted_agreement = WeightedAgreement()\nweighted_quorum = WeightedQuorum()\n\nprint(f\"Weighted agreement: {weighted_agreement.verify(weighted_state)}\")\nprint(f\"Weighted quorum: {weighted_quorum.verify(weighted_state)}\")\n\n# Step 4: MAS theory mappings\nbdi = BDIMapping()\nbdi_state = bdi.map_to_mas({\n    \"beliefs\": {\"context\": \"current_state\"},\n    \"desires\": {\"objective\": \"complete_task\"},\n    \"intentions\": {\"assignment\": \"agent_0\"},\n})\nprint(f\"BDI mapping: {bdi_state}\")\n\ncontract_net = ContractNetMapping()\ncn_state = contract_net.map_to_mas({\n    \"cfp\": \"task_description\",\n    \"bids\": {\"agent_0\": 0.9, \"agent_1\": 0.7},\n    \"award\": \"agent_0\",\n})\nprint(f\"Contract Net mapping: {cn_state}\")\n</code></pre>"},{"location":"tutorials/consensus-verification/#next-steps","title":"Next Steps","text":"<ul> <li>Read Consensus Concepts for the formal definitions and proofs behind these properties</li> <li>Explore the Specifications API Reference for custom properties and verification strategies</li> <li>Revisit Modeling Agent Coordination with CSP to combine process-algebraic modeling with consensus verification</li> </ul>"},{"location":"tutorials/csp-coordination/","title":"Modeling Agent Coordination with CSP","text":"<p>Time: 15 minutes</p> <p>In this tutorial, you will model a multi-agent consensus protocol using Communicating Sequential Processes (CSP), verify it for deadlock freedom, and extend it with fault tolerance using Timeout and Interrupt constructs.</p>"},{"location":"tutorials/csp-coordination/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li><code>agenticraft-foundation</code> installed</li> <li>Basic Python knowledge</li> </ul>"},{"location":"tutorials/csp-coordination/#what-youll-build","title":"What You'll Build","text":"<p>A 3-agent consensus protocol modeled in CSP where agents propose values, vote, and reach a decision. You will:</p> <ol> <li>Define agent events and processes</li> <li>Compose agents in parallel with synchronization</li> <li>Build a Labeled Transition System (LTS) and analyze it</li> <li>Add fault tolerance with Timeout and Interrupt</li> <li>Verify refinement between the original and fault-tolerant versions</li> </ol>"},{"location":"tutorials/csp-coordination/#step-1-define-agent-events","title":"Step 1: Define Agent Events","text":"<p>Every CSP model starts with events -- the atomic actions that agents can perform. In a consensus protocol, agents propose values, vote on proposals, decide on a final value, and acknowledge the decision.</p> <pre><code>from agenticraft_foundation import Event, Prefix, Stop, Skip\n\npropose = Event(\"propose\")\nvote = Event(\"vote\")\ndecide = Event(\"decide\")\nack = Event(\"acknowledge\")\n</code></pre> <p><code>Event</code> creates a named event. <code>Prefix</code>, <code>Stop</code>, and <code>Skip</code> are CSP process constructors: <code>Prefix(e, P)</code> performs event <code>e</code> then behaves like process <code>P</code>, <code>Stop</code> is the deadlocked process (does nothing), and <code>Skip</code> is the successfully terminated process.</p>"},{"location":"tutorials/csp-coordination/#step-2-build-individual-agent-processes","title":"Step 2: Build Individual Agent Processes","text":"<p>Each agent follows the same protocol: propose, then vote, then decide, then terminate successfully.</p> <pre><code>agent = Prefix(propose, Prefix(vote, Prefix(decide, Skip())))\n</code></pre> <p>Reading this from left to right: the agent first performs <code>propose</code>, then <code>vote</code>, then <code>decide</code>, then terminates. This is a sequential composition -- the agent must complete each step before moving to the next.</p> <p>You can think of this as a finite state machine with 4 states and 3 transitions:</p> <pre><code>[start] --propose--&gt; [voted] --vote--&gt; [decided] --decide--&gt; [done]\n</code></pre>"},{"location":"tutorials/csp-coordination/#step-3-compose-agents-in-parallel","title":"Step 3: Compose Agents in Parallel","text":"<p>Real multi-agent systems have multiple agents running concurrently. CSP's parallel composition operator lets you model this, with a synchronization set that defines which events require all agents to participate.</p> <pre><code>from agenticraft_foundation import Parallel\n\nsync_events = {propose, vote, decide}\nagent1 = Prefix(propose, Prefix(vote, Prefix(decide, Skip())))\nagent2 = Prefix(propose, Prefix(vote, Prefix(decide, Skip())))\nsystem = Parallel(agent1, agent2, sync_set=sync_events)\n</code></pre> <p>The <code>sync_set</code> parameter is critical. Events in the synchronization set can only occur when both agents are ready to perform them simultaneously. This models the requirement that all agents must participate in each phase of the consensus protocol. Events not in the sync set can be performed independently by either agent.</p>"},{"location":"tutorials/csp-coordination/#step-4-build-the-lts-and-analyze","title":"Step 4: Build the LTS and Analyze","text":"<p>With the system composed, you can build its Labeled Transition System -- a complete state graph showing every reachable state and every possible transition. This is the foundation for all verification.</p> <pre><code>from agenticraft_foundation import build_lts, traces, detect_deadlock, is_deadlock_free\n\nlts = build_lts(system)\nprint(f\"States: {len(lts.states)}\")\nprint(f\"Transitions: {len(lts.transitions)}\")\nprint(f\"Deadlock-free: {is_deadlock_free(system)}\")\n\ndeadlocks = detect_deadlock(system)\nprint(f\"Deadlock states: {len(deadlocks.deadlock_states)}\")\n\nall_traces = list(traces(lts, max_length=6))\nprint(f\"Traces (up to length 6): {len(all_traces)}\")\n</code></pre> <p>The <code>build_lts</code> function exhaustively explores the state space of the process. <code>is_deadlock_free</code> checks whether the system can reach any state where no further progress is possible (other than successful termination). <code>traces</code> enumerates all possible event sequences up to a given length.</p> <p>For this simple two-agent system, you should see a small number of states (since both agents are synchronized on all events, they move in lockstep). In a system with unsynchronized events, the state space grows as agents interleave independently.</p>"},{"location":"tutorials/csp-coordination/#step-5-add-fault-tolerance-with-timeout","title":"Step 5: Add Fault Tolerance with Timeout","text":"<p>Production multi-agent systems need fault tolerance. What happens if an agent hangs during the vote phase? CSP's Timeout construct lets you model bounded waiting with a fallback.</p> <pre><code>from agenticraft_foundation import Timeout, Interrupt\n\nfallback = Prefix(Event(\"use_cached\"), Stop())\nbounded_agent = Timeout(process=agent, duration=30.0, fallback=fallback)\n</code></pre> <p><code>Timeout(process, duration, fallback)</code> behaves like <code>process</code> if it completes within <code>duration</code>, otherwise it switches to <code>fallback</code>. Here, the fallback uses a cached value and then stops. This models a real-world pattern where agents have SLA deadlines and must degrade gracefully.</p>"},{"location":"tutorials/csp-coordination/#step-6-add-interrupt-handling","title":"Step 6: Add Interrupt Handling","text":"<p>Beyond timeouts, agents need to handle external interrupts -- for example, a cancellation signal from a supervisor.</p> <pre><code>cancel = Event(\"cancel\")\ncancel_handler = Prefix(cancel, Prefix(Event(\"cleanup\"), Stop()))\ninterruptible = Interrupt(primary=bounded_agent, handler=cancel_handler)\n\nlts_final = build_lts(interruptible)\nprint(f\"Final states: {len(lts_final.states)}\")\n</code></pre> <p><code>Interrupt(primary, handler)</code> runs the primary process, but at any point, the handler can take over. Here, if a <code>cancel</code> event occurs, the agent performs cleanup and stops. The LTS for this interruptible process will be larger because it includes the interrupt paths at every state.</p>"},{"location":"tutorials/csp-coordination/#step-7-check-refinement","title":"Step 7: Check Refinement","text":"<p>Refinement is a core concept in CSP verification. Process <code>P</code> refines process <code>Q</code> (written <code>Q [= P</code>) if every observable behavior of <code>P</code> is also a behavior of <code>Q</code>. This lets you verify that your fault-tolerant implementation is a valid refinement of the original specification.</p> <pre><code>from agenticraft_foundation.algebra import trace_refines\n\n# Verify the fault-tolerant version refines the original spec\nprint(f\"Refines original: {trace_refines(agent, bounded_agent)}\")\n</code></pre> <p>If <code>trace_refines(spec, impl)</code> returns <code>True</code>, it means the implementation never exhibits a trace that the specification does not allow. The fault-tolerant version may have additional behaviors (like the timeout fallback), so trace refinement may not hold in that direction -- and that is expected. What matters is whether the refinement relationship matches your design intent.</p>"},{"location":"tutorials/csp-coordination/#complete-script","title":"Complete Script","text":"<pre><code>\"\"\"CSP Coordination Tutorial - Complete Script\n\nModels a multi-agent consensus protocol, verifies deadlock freedom,\nand adds fault tolerance with Timeout and Interrupt.\n\"\"\"\nfrom agenticraft_foundation import (\n    Event, Prefix, Stop, Skip, Parallel,\n    Timeout, Interrupt,\n    build_lts, traces, detect_deadlock, is_deadlock_free,\n)\nfrom agenticraft_foundation.algebra import trace_refines\n\n# Step 1: Define events\npropose = Event(\"propose\")\nvote = Event(\"vote\")\ndecide = Event(\"decide\")\nack = Event(\"acknowledge\")\n\n# Step 2: Build agent processes\nagent = Prefix(propose, Prefix(vote, Prefix(decide, Skip())))\n\n# Step 3: Compose in parallel\nsync_events = {propose, vote, decide}\nagent1 = Prefix(propose, Prefix(vote, Prefix(decide, Skip())))\nagent2 = Prefix(propose, Prefix(vote, Prefix(decide, Skip())))\nsystem = Parallel(agent1, agent2, sync_set=sync_events)\n\n# Step 4: Build LTS and analyze\nlts = build_lts(system)\nprint(f\"States: {len(lts.states)}\")\nprint(f\"Transitions: {len(lts.transitions)}\")\nprint(f\"Deadlock-free: {is_deadlock_free(system)}\")\n\ndeadlocks = detect_deadlock(system)\nprint(f\"Deadlock states: {len(deadlocks.deadlock_states)}\")\n\nall_traces = list(traces(lts, max_length=6))\nprint(f\"Traces (up to length 6): {len(all_traces)}\")\n\n# Step 5: Add timeout fault tolerance\nfallback = Prefix(Event(\"use_cached\"), Stop())\nbounded_agent = Timeout(process=agent, duration=30.0, fallback=fallback)\n\n# Step 6: Add interrupt handling\ncancel = Event(\"cancel\")\ncancel_handler = Prefix(cancel, Prefix(Event(\"cleanup\"), Stop()))\ninterruptible = Interrupt(primary=bounded_agent, handler=cancel_handler)\n\nlts_final = build_lts(interruptible)\nprint(f\"Final states: {len(lts_final.states)}\")\n\n# Step 7: Check refinement\nprint(f\"Refines original: {trace_refines(agent, bounded_agent)}\")\n</code></pre>"},{"location":"tutorials/csp-coordination/#next-steps","title":"Next Steps","text":"<ul> <li>Read Process Algebra Concepts for the formal foundations behind CSP</li> <li>Explore the Algebra API Reference for the complete set of process constructors and operations</li> <li>Continue to Verifying Protocols with Session Types to learn how to verify communication protocols</li> </ul>"},{"location":"tutorials/mpst-verification/","title":"Verifying Protocols with Session Types","text":"<p>Time: 15 minutes</p> <p>In this tutorial, you will define a multi-party session type for a RAG (Retrieval-Augmented Generation) pipeline, project it to local types for each role, verify well-formedness, and set up runtime session monitoring.</p>"},{"location":"tutorials/mpst-verification/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li><code>agenticraft-foundation</code> installed</li> <li>Familiarity with the concept of communication protocols (who sends what to whom)</li> </ul>"},{"location":"tutorials/mpst-verification/#what-youll-build","title":"What You'll Build","text":"<p>A RAG pipeline protocol with 3 roles -- client, retriever, and generator -- modeled as a multiparty session type. You will:</p> <ol> <li>Define the global protocol as a sequence of interactions</li> <li>Project the global type to each participant's local view</li> <li>Verify that the protocol is well-formed (no stuck participants, no orphan messages)</li> <li>Set up runtime monitoring to detect protocol violations</li> <li>Use built-in patterns for common protocol shapes</li> </ol>"},{"location":"tutorials/mpst-verification/#step-1-define-the-global-type","title":"Step 1: Define the Global Type","text":"<p>A global type describes a protocol from a bird's-eye view: who sends what to whom, and in what order. The RAG pipeline has three interactions:</p> <ol> <li>The client sends a query to the retriever</li> <li>The retriever sends context to the generator</li> <li>The generator sends a response back to the client</li> </ol> <pre><code>from agenticraft_foundation.mpst import GlobalInteraction, GlobalType\n\nrag_protocol = GlobalType(interactions=[\n    GlobalInteraction(sender=\"client\", receiver=\"retriever\", message_type=\"Query\"),\n    GlobalInteraction(sender=\"retriever\", receiver=\"generator\", message_type=\"Context\"),\n    GlobalInteraction(sender=\"generator\", receiver=\"client\", message_type=\"Response\"),\n])\n</code></pre> <p>Each <code>GlobalInteraction</code> specifies a sender, a receiver, and a message type. The interactions are ordered -- the query must happen before the context retrieval, which must happen before the response generation. This ordering is what makes the protocol a pipeline rather than a free-for-all.</p>"},{"location":"tutorials/mpst-verification/#step-2-project-to-local-types","title":"Step 2: Project to Local Types","text":"<p>Each participant in the protocol only sees their own sends and receives. Projection takes the global type and produces a local type for each role. This is a fundamental operation in multiparty session type theory -- it ensures that each participant has a consistent view of the protocol.</p> <pre><code>from agenticraft_foundation.mpst import Projector\n\nprojector = Projector()\nlocal_client = projector.project(rag_protocol, \"client\")\nlocal_retriever = projector.project(rag_protocol, \"retriever\")\nlocal_generator = projector.project(rag_protocol, \"generator\")\n\nprint(f\"Client view: {local_client}\")\nprint(f\"Retriever view: {local_retriever}\")\nprint(f\"Generator view: {local_generator}\")\n</code></pre> <p>The client's local type will show: send <code>Query</code> to retriever, then receive <code>Response</code> from generator. The retriever sees: receive <code>Query</code> from client, then send <code>Context</code> to generator. The generator sees: receive <code>Context</code> from retriever, then send <code>Response</code> to client.</p> <p>Notice that projection preserves the causal ordering. The client knows it must send before it receives. The generator knows it must receive before it sends. This is exactly the information each participant needs to implement the protocol correctly.</p>"},{"location":"tutorials/mpst-verification/#step-3-verify-well-formedness","title":"Step 3: Verify Well-Formedness","text":"<p>A well-formed protocol guarantees several properties: no participant gets stuck waiting for a message that never arrives, no messages are sent to participants who are not expecting them, and every branch of a choice is projectable to all roles.</p> <pre><code>from agenticraft_foundation.mpst import SessionTypeChecker\n\nchecker = SessionTypeChecker()\nresult = checker.check_well_formedness(rag_protocol)\nprint(f\"Well-formed: {result.is_valid}\")\nif not result.is_valid:\n    for error in result.errors:\n        print(f\"  Error: {error}\")\n</code></pre> <p>For our RAG protocol, well-formedness should pass. But consider what happens if you add an interaction where the generator sends directly to the retriever without the client's knowledge -- the checker would flag this as a potential issue depending on the protocol structure.</p> <p>Well-formedness checking catches design errors before any code is written. In a multi-agent system with dozens of roles and message types, this verification is essential.</p>"},{"location":"tutorials/mpst-verification/#step-4-set-up-session-monitoring","title":"Step 4: Set Up Session Monitoring","text":"<p>Once you have verified the protocol at design time, you can monitor it at runtime. A session monitor tracks the actual messages exchanged and checks them against the local type.</p> <pre><code>from agenticraft_foundation.mpst import SessionMonitor\n\nmonitor = SessionMonitor(local_type=local_client)\n# Simulate message exchange\nmonitor.send(\"Query\", to=\"retriever\")\nmonitor.receive(\"Response\", from_role=\"generator\")\nprint(f\"Session complete: {monitor.is_complete()}\")\n</code></pre> <p>The monitor tracks the current state of the session. After the client sends a <code>Query</code> and receives a <code>Response</code>, the session is complete according to the local type. If the client tried to send a second <code>Query</code> without the protocol allowing it, the monitor would raise a violation.</p> <p>In a production system, you would wrap your actual message-passing code with monitor calls. This gives you runtime guarantees that agents are following the protocol, without modifying the agents themselves.</p>"},{"location":"tutorials/mpst-verification/#step-5-use-built-in-patterns","title":"Step 5: Use Built-In Patterns","text":"<p>Many protocols follow common shapes. The <code>agenticraft_foundation.mpst.patterns</code> module provides factories for these patterns, so you do not have to define them from scratch.</p> <pre><code>from agenticraft_foundation.mpst.patterns import request_response, pipeline\n\n# Request-response pattern\nrr = request_response.create(\"client\", \"server\", \"Request\", \"Response\")\nprint(f\"Request-response roles: {rr.roles}\")\n\n# Pipeline pattern\npipe = pipeline.create([\"ingester\", \"processor\", \"writer\"], [\"RawData\", \"ProcessedData\"])\nprint(f\"Pipeline roles: {pipe.roles}\")\n</code></pre> <p>The <code>request_response</code> pattern creates a two-party protocol where one role sends a request and receives a response. The <code>pipeline</code> pattern chains multiple roles together, where each role receives from the previous one and sends to the next.</p> <p>These patterns are fully verified <code>GlobalType</code> instances -- you can project them, check well-formedness, and create monitors from them just like any protocol you define manually.</p>"},{"location":"tutorials/mpst-verification/#complete-script","title":"Complete Script","text":"<pre><code>\"\"\"MPST Verification Tutorial - Complete Script\n\nDefines a RAG pipeline protocol as a multiparty session type,\nverifies well-formedness, and sets up runtime monitoring.\n\"\"\"\nfrom agenticraft_foundation.mpst import (\n    GlobalInteraction, GlobalType,\n    Projector, SessionTypeChecker, SessionMonitor,\n)\nfrom agenticraft_foundation.mpst.patterns import request_response, pipeline\n\n# Step 1: Define global type\nrag_protocol = GlobalType(interactions=[\n    GlobalInteraction(sender=\"client\", receiver=\"retriever\", message_type=\"Query\"),\n    GlobalInteraction(sender=\"retriever\", receiver=\"generator\", message_type=\"Context\"),\n    GlobalInteraction(sender=\"generator\", receiver=\"client\", message_type=\"Response\"),\n])\n\n# Step 2: Project to local types\nprojector = Projector()\nlocal_client = projector.project(rag_protocol, \"client\")\nlocal_retriever = projector.project(rag_protocol, \"retriever\")\nlocal_generator = projector.project(rag_protocol, \"generator\")\n\nprint(f\"Client view: {local_client}\")\nprint(f\"Retriever view: {local_retriever}\")\nprint(f\"Generator view: {local_generator}\")\n\n# Step 3: Verify well-formedness\nchecker = SessionTypeChecker()\nresult = checker.check_well_formedness(rag_protocol)\nprint(f\"Well-formed: {result.is_valid}\")\nif not result.is_valid:\n    for error in result.errors:\n        print(f\"  Error: {error}\")\n\n# Step 4: Runtime monitoring\nmonitor = SessionMonitor(local_type=local_client)\nmonitor.send(\"Query\", to=\"retriever\")\nmonitor.receive(\"Response\", from_role=\"generator\")\nprint(f\"Session complete: {monitor.is_complete()}\")\n\n# Step 5: Built-in patterns\nrr = request_response.create(\"client\", \"server\", \"Request\", \"Response\")\nprint(f\"Request-response roles: {rr.roles}\")\n\npipe = pipeline.create([\"ingester\", \"processor\", \"writer\"], [\"RawData\", \"ProcessedData\"])\nprint(f\"Pipeline roles: {pipe.roles}\")\n</code></pre>"},{"location":"tutorials/mpst-verification/#next-steps","title":"Next Steps","text":"<ul> <li>Read Session Types Concepts for the theoretical background on MPST</li> <li>Explore the MPST API Reference for advanced features like choice types and recursion</li> <li>Continue to Multi-Protocol Routing to learn how to route messages across protocol boundaries</li> </ul>"},{"location":"tutorials/probabilistic-analysis/","title":"Modeling Stochastic Agents with DTMC","text":"<p>Time: 15 minutes</p> <p>In this tutorial, you will build Discrete-Time Markov Chain models of stochastic LLM agents, compute reachability probabilities, analyze steady-state distributions, and calculate expected completion times.</p>"},{"location":"tutorials/probabilistic-analysis/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li><code>agenticraft-foundation</code> installed</li> <li>Basic probability (what a transition probability means)</li> </ul>"},{"location":"tutorials/probabilistic-analysis/#what-youll-build","title":"What You'll Build","text":"<p>A probabilistic model of an LLM agent with retry logic and provider fallback. You will:</p> <ol> <li>Build a DTMC for a single-provider agent with retries</li> <li>Compute reachability probability (\"will it succeed?\")</li> <li>Compute expected steps to success</li> <li>Extend to a multi-provider fallback model</li> <li>Analyze steady-state distribution for an ergodic agent</li> <li>Compare designs quantitatively</li> </ol>"},{"location":"tutorials/probabilistic-analysis/#step-1-build-a-single-provider-agent","title":"Step 1: Build a Single-Provider Agent","text":"<p>An LLM agent sends a request to a provider. With probability 0.9, the call succeeds. With probability 0.1, it fails transiently. On failure, the agent retries.</p> <pre><code>from agenticraft_foundation.verification import DTMC\n\ndtmc = DTMC()\ndtmc.add_state(0, labels={\"start\"})\ndtmc.add_state(1, labels={\"calling\"})\ndtmc.add_state(2, labels={\"success\"})\ndtmc.add_state(3, labels={\"failed\"})\n\ndtmc.add_transition(0, 1, probability=1.0)    # start \u2192 calling\ndtmc.add_transition(1, 2, probability=0.9)    # 90% success\ndtmc.add_transition(1, 3, probability=0.1)    # 10% transient failure\ndtmc.add_transition(3, 1, probability=1.0)    # retry on failure\ndtmc.add_transition(2, 2, probability=1.0)    # success is absorbing\n\ndtmc.validate()  # checks probabilities sum to 1.0 per state\nprint(f\"States: {len(dtmc.states)}, Transitions: {dtmc.transition_count()}\")\n</code></pre> <p>The <code>validate()</code> method raises <code>ValueError</code> if any state's outgoing probabilities don't sum to 1.0. Always call it after building a DTMC.</p>"},{"location":"tutorials/probabilistic-analysis/#step-2-compute-reachability-probability","title":"Step 2: Compute Reachability Probability","text":"<p>The fundamental question: \"what is the probability that the agent eventually reaches success?\"</p> <pre><code>from agenticraft_foundation.verification import check_reachability\n\nresult = check_reachability(dtmc, target_labels={\"success\"})\nprint(f\"P(eventually success) = {result.probability:.4f}\")\nprint(f\"Per-state probabilities:\")\nfor state_id, prob in sorted(result.per_state.items()):\n    labels = dtmc.states[state_id].labels\n    print(f\"  State {state_id} {labels}: {prob:.4f}\")\n</code></pre> <p>With retry on every failure, the probability of eventually succeeding is 1.0 -- the agent will keep trying until it works. The math: \\(P = 0.9 + 0.1 \\cdot 0.9 + 0.1^2 \\cdot 0.9 + \\cdots = \\sum_{k=0}^{\\infty} 0.1^k \\cdot 0.9 = 1.0\\).</p>"},{"location":"tutorials/probabilistic-analysis/#step-3-compute-expected-steps","title":"Step 3: Compute Expected Steps","text":"<p>How many steps does it take on average to reach success?</p> <pre><code>from agenticraft_foundation.verification import expected_steps\n\nresult = expected_steps(dtmc, target_labels={\"success\"})\nprint(f\"E[steps to success] = {result.expected:.2f}\")\nprint(f\"Per-state expected steps:\")\nfor state_id, steps in sorted(result.per_state.items()):\n    labels = dtmc.states[state_id].labels\n    print(f\"  State {state_id} {labels}: {steps:.2f}\")\n</code></pre> <p>From the start state, the expected number of steps is \\(1 + \\frac{1}{0.9} \\approx 2.11\\) -- one step to reach <code>calling</code>, then on average \\(\\frac{1}{0.9} \\approx 1.11\\) attempts to succeed (geometric distribution).</p>"},{"location":"tutorials/probabilistic-analysis/#step-4-multi-provider-fallback","title":"Step 4: Multi-Provider Fallback","text":"<p>Now model a more realistic agent that falls back to a secondary provider when the primary fails.</p> <pre><code>fallback = DTMC()\nfallback.add_state(0, labels={\"start\"})\nfallback.add_state(1, labels={\"primary\"})\nfallback.add_state(2, labels={\"secondary\"})\nfallback.add_state(3, labels={\"success\"})\nfallback.add_state(4, labels={\"total_failure\"})\n\nfallback.add_transition(0, 1, probability=1.0)     # start \u2192 try primary\nfallback.add_transition(1, 3, probability=0.9)     # primary succeeds (90%)\nfallback.add_transition(1, 2, probability=0.1)     # primary fails \u2192 try secondary\nfallback.add_transition(2, 3, probability=0.95)    # secondary succeeds (95%)\nfallback.add_transition(2, 4, probability=0.05)    # secondary also fails\nfallback.add_transition(3, 3, probability=1.0)     # absorbing\nfallback.add_transition(4, 4, probability=1.0)     # absorbing\n\nfallback.validate()\n\nresult = check_reachability(fallback, target_labels={\"success\"})\nprint(f\"P(success) = {result.probability:.4f}\")\n\nfailure = check_reachability(fallback, target_labels={\"total_failure\"})\nprint(f\"P(total failure) = {failure.probability:.4f}\")\n</code></pre> <p>With fallback, the success probability is \\(0.9 + 0.1 \\cdot 0.95 = 0.995\\). The total failure probability is \\(0.1 \\cdot 0.05 = 0.005\\). This is a non-absorbing chain with two absorbing states, so probabilities don't need to sum to 1.0 per target -- they sum across targets.</p>"},{"location":"tutorials/probabilistic-analysis/#step-5-steady-state-distribution","title":"Step 5: Steady-State Distribution","text":"<p>For an agent that runs continuously (not absorbing), the steady-state distribution tells you the long-run fraction of time spent in each state.</p> <pre><code>from agenticraft_foundation.verification import steady_state\n\n# Ergodic agent: cycles through states continuously\ncyclic = DTMC()\ncyclic.add_state(0, labels={\"idle\"})\ncyclic.add_state(1, labels={\"thinking\"})\ncyclic.add_state(2, labels={\"acting\"})\ncyclic.add_state(3, labels={\"reviewing\"})\n\ncyclic.add_transition(0, 1, probability=1.0)     # idle \u2192 thinking\ncyclic.add_transition(1, 2, probability=0.7)     # think \u2192 act (70%)\ncyclic.add_transition(1, 1, probability=0.3)     # think more (30%)\ncyclic.add_transition(2, 3, probability=1.0)     # act \u2192 review\ncyclic.add_transition(3, 0, probability=0.8)     # review \u2192 idle (80%)\ncyclic.add_transition(3, 1, probability=0.2)     # review \u2192 rethink (20%)\n\ncyclic.validate()\n\ndist = steady_state(cyclic)\nprint(\"Steady-state distribution:\")\nfor state_id, prob in sorted(dist.items()):\n    labels = cyclic.states[state_id].labels\n    print(f\"  State {state_id} {labels}: {prob:.4f}\")\n</code></pre> <p>The steady-state distribution \\(\\pi\\) satisfies \\(\\pi = \\pi P\\) and \\(\\sum_s \\pi(s) = 1\\). It tells you: in the long run, what fraction of time does the agent spend thinking vs. acting vs. reviewing?</p>"},{"location":"tutorials/probabilistic-analysis/#step-6-compare-designs","title":"Step 6: Compare Designs","text":"<p>Use probabilistic verification to make quantitative design decisions. Compare the single-provider retry vs. multi-provider fallback:</p> <pre><code># Single-provider with retry\nretry_steps = expected_steps(dtmc, target_labels={\"success\"})\nretry_prob = check_reachability(dtmc, target_labels={\"success\"})\n\n# Multi-provider fallback\nfallback_steps = expected_steps(fallback, target_labels={\"success\"})\nfallback_prob = check_reachability(fallback, target_labels={\"success\"})\n\nprint(\"Design Comparison:\")\nprint(f\"  {'Metric':&lt;30} {'Retry':&gt;10} {'Fallback':&gt;10}\")\nprint(f\"  {'P(success)':&lt;30} {retry_prob.probability:&gt;10.4f} {fallback_prob.probability:&gt;10.4f}\")\nprint(f\"  {'E[steps]':&lt;30} {retry_steps.expected:&gt;10.2f} {fallback_steps.expected:&gt;10.2f}\")\n</code></pre> <p>The retry model guarantees eventual success (\\(P = 1.0\\)) but may take many steps. The fallback model has a small failure probability (\\(P = 0.005\\)) but always finishes in exactly 3 steps. Which is better depends on your requirements.</p>"},{"location":"tutorials/probabilistic-analysis/#complete-script","title":"Complete Script","text":"<pre><code>\"\"\"Probabilistic Analysis Tutorial - Complete Script\n\nModels LLM agents as DTMCs and computes reachability,\nexpected steps, and steady-state distributions.\n\"\"\"\nfrom agenticraft_foundation.verification import (\n    DTMC, check_reachability, steady_state, expected_steps,\n)\n\n# Step 1: Single-provider with retry\ndtmc = DTMC()\ndtmc.add_state(0, labels={\"start\"})\ndtmc.add_state(1, labels={\"calling\"})\ndtmc.add_state(2, labels={\"success\"})\ndtmc.add_state(3, labels={\"failed\"})\ndtmc.add_transition(0, 1, probability=1.0)\ndtmc.add_transition(1, 2, probability=0.9)\ndtmc.add_transition(1, 3, probability=0.1)\ndtmc.add_transition(3, 1, probability=1.0)\ndtmc.add_transition(2, 2, probability=1.0)\ndtmc.validate()\n\n# Step 2: Reachability\nresult = check_reachability(dtmc, target_labels={\"success\"})\nprint(f\"Retry model P(success) = {result.probability:.4f}\")\n\n# Step 3: Expected steps\nsteps = expected_steps(dtmc, target_labels={\"success\"})\nprint(f\"Retry model E[steps] = {steps.expected:.2f}\")\n\n# Step 4: Multi-provider fallback\nfallback = DTMC()\nfallback.add_state(0, labels={\"start\"})\nfallback.add_state(1, labels={\"primary\"})\nfallback.add_state(2, labels={\"secondary\"})\nfallback.add_state(3, labels={\"success\"})\nfallback.add_state(4, labels={\"total_failure\"})\nfallback.add_transition(0, 1, probability=1.0)\nfallback.add_transition(1, 3, probability=0.9)\nfallback.add_transition(1, 2, probability=0.1)\nfallback.add_transition(2, 3, probability=0.95)\nfallback.add_transition(2, 4, probability=0.05)\nfallback.add_transition(3, 3, probability=1.0)\nfallback.add_transition(4, 4, probability=1.0)\nfallback.validate()\n\nresult = check_reachability(fallback, target_labels={\"success\"})\nprint(f\"Fallback model P(success) = {result.probability:.4f}\")\n\n# Step 5: Steady-state\ncyclic = DTMC()\ncyclic.add_state(0, labels={\"idle\"})\ncyclic.add_state(1, labels={\"thinking\"})\ncyclic.add_state(2, labels={\"acting\"})\ncyclic.add_state(3, labels={\"reviewing\"})\ncyclic.add_transition(0, 1, probability=1.0)\ncyclic.add_transition(1, 2, probability=0.7)\ncyclic.add_transition(1, 1, probability=0.3)\ncyclic.add_transition(2, 3, probability=1.0)\ncyclic.add_transition(3, 0, probability=0.8)\ncyclic.add_transition(3, 1, probability=0.2)\ncyclic.validate()\n\ndist = steady_state(cyclic)\nprint(\"Steady-state:\", {cyclic.states[s].labels: f\"{p:.3f}\" for s, p in dist.items()})\n\n# Step 6: Compare\nretry_steps = expected_steps(dtmc, target_labels={\"success\"})\nfallback_steps = expected_steps(fallback, target_labels={\"success\"})\nprint(f\"Retry E[steps]={retry_steps.expected:.2f}, Fallback E[steps]={fallback_steps.expected:.2f}\")\n</code></pre>"},{"location":"tutorials/probabilistic-analysis/#next-steps","title":"Next Steps","text":"<ul> <li>Read Verification Concepts for the theory behind DTMC model checking</li> <li>See the Probabilistic API Reference for the complete DTMC API</li> <li>Explore Checking Temporal Properties with CTL for non-probabilistic verification</li> </ul>"},{"location":"tutorials/protocol-routing/","title":"Multi-Protocol Routing","text":"<p>Time: 20 minutes</p> <p>In this tutorial, you will build a protocol graph representing agents with different protocol capabilities, use multiple routing algorithms to find optimal paths, handle agent failures with resilient routing, and validate a multi-step workflow against the graph.</p>"},{"location":"tutorials/protocol-routing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li><code>agenticraft-foundation</code> installed</li> <li>Familiarity with graph concepts (nodes, edges, paths)</li> </ul>"},{"location":"tutorials/protocol-routing/#what-youll-build","title":"What You'll Build","text":"<p>A protocol-aware routing system with 4 agents that support different combinations of MCP and A2A protocols. You will:</p> <ol> <li>Build a protocol graph with agents and edges</li> <li>Set up protocol compatibility and cost calculation</li> <li>Find optimal routes using Dijkstra (minimum cost)</li> <li>Find shortest routes using BFS (minimum hops)</li> <li>Route around failed agents with resilient routing</li> <li>Define and validate a multi-step workflow</li> </ol>"},{"location":"tutorials/protocol-routing/#step-1-build-the-protocol-graph","title":"Step 1: Build the Protocol Graph","text":"<p>A protocol graph models your agent network. Each agent has capabilities (what it can do) and supported protocols (how it communicates). Edges represent direct communication links between agents, annotated with the protocols those links support.</p> <pre><code>from agenticraft_foundation.protocols import ProtocolGraph\nfrom agenticraft_foundation.types import ProtocolName\n\ngraph = ProtocolGraph()\ngraph.add_agent(\"gateway\", [\"routing\"], {ProtocolName.MCP, ProtocolName.A2A})\ngraph.add_agent(\"analyzer\", [\"analysis\"], {ProtocolName.MCP})\ngraph.add_agent(\"executor\", [\"execution\"], {ProtocolName.A2A})\ngraph.add_agent(\"reporter\", [\"output\"], {ProtocolName.MCP, ProtocolName.A2A})\n\ngraph.add_edge(\"gateway\", \"analyzer\", {ProtocolName.MCP})\ngraph.add_edge(\"gateway\", \"executor\", {ProtocolName.A2A})\ngraph.add_edge(\"analyzer\", \"reporter\", {ProtocolName.MCP})\ngraph.add_edge(\"executor\", \"reporter\", {ProtocolName.A2A})\n</code></pre> <p>This creates a diamond-shaped graph. The gateway can reach the reporter via two paths: through the analyzer (using MCP) or through the executor (using A2A). The analyzer only speaks MCP, while the executor only speaks A2A. The gateway and reporter are bilingual.</p> <p>This topology is common in production systems where different subsystems use different protocols -- for example, an analysis pipeline using structured MCP tool calls and an execution pipeline using agent-to-agent messaging.</p>"},{"location":"tutorials/protocol-routing/#step-2-set-up-routing-infrastructure","title":"Step 2: Set Up Routing Infrastructure","text":"<p>Before routing, you need two components: a compatibility matrix that defines the cost of protocol transitions, and a path cost calculator that evaluates routes.</p> <pre><code>from agenticraft_foundation.protocols import (\n    ProtocolCompatibilityMatrix, PathCostCalculator,\n    PROTOCOL_COMPATIBILITY,\n)\n\ncompat = ProtocolCompatibilityMatrix(PROTOCOL_COMPATIBILITY)\ncalc = PathCostCalculator(graph, compat)\n</code></pre> <p><code>PROTOCOL_COMPATIBILITY</code> is a built-in dictionary defining the base compatibility between protocol pairs. Same-protocol communication has zero overhead. Cross-protocol communication (e.g., translating from MCP to A2A) incurs a cost that reflects the complexity and potential information loss of the translation.</p> <p>The <code>PathCostCalculator</code> uses the compatibility matrix and graph structure to compute the total cost of any path. The cost function is:</p> \\[\\text{cost}(\\pi, \\sigma) = \\sum_{i} w_{e_i}(p_i) + \\sum_{i} \\tau(p_i, p_{i+1}, v_i)\\] <p>The first term sums edge weights \\(w_{e_i}(p_i)\\) \u2014 the hop cost of each link using its assigned protocol. The second term sums translation costs \\(\\tau(p_i, p_{i+1}, v_i)\\) \u2014 the overhead of switching protocols at intermediate nodes. Same-protocol hops contribute zero translation cost.</p>"},{"location":"tutorials/protocol-routing/#step-3-dijkstra-routing-minimum-cost","title":"Step 3: Dijkstra Routing (Minimum Cost)","text":"<p>Dijkstra's algorithm finds the path with the lowest total cost. In a protocol-aware context, this means finding the route that minimizes both the number of hops and the cost of any protocol translations required.</p> <pre><code>from agenticraft_foundation.protocols import ProtocolAwareDijkstra\n\ndijkstra = ProtocolAwareDijkstra(graph, compat, calc)\nroute = dijkstra.find_optimal_route(\"gateway\", \"reporter\", ProtocolName.MCP)\nprint(f\"Path: {route.path}\")\nprint(f\"Total cost: {route.total_cost:.2f}\")\nprint(f\"Protocols used: {route.protocols_used}\")\n</code></pre> <p>When requesting an MCP route from gateway to reporter, Dijkstra will prefer the path through the analyzer (gateway -&gt; analyzer -&gt; reporter) because it stays on MCP the entire way, avoiding any protocol translation cost.</p> <p>If you change the preferred protocol to A2A, the algorithm will route through the executor instead.</p>"},{"location":"tutorials/protocol-routing/#step-4-bfs-routing-minimum-hops","title":"Step 4: BFS Routing (Minimum Hops)","text":"<p>Sometimes you want the shortest path regardless of cost -- for example, when latency matters more than protocol overhead. BFS finds the path with the fewest hops.</p> <pre><code>from agenticraft_foundation.protocols import ProtocolConstrainedBFS\n\nbfs = ProtocolConstrainedBFS(graph, compat, calc)\nshortest = bfs.find_shortest_path(\"gateway\", \"reporter\", ProtocolName.MCP)\nprint(f\"Path: {shortest.path}\")\nprint(f\"Hops: {shortest.num_hops}\")\n</code></pre> <p>In this graph, both paths have the same number of hops (2), so BFS may return either one. The difference between BFS and Dijkstra becomes significant in larger graphs where some short paths have high protocol translation costs.</p>"},{"location":"tutorials/protocol-routing/#step-5-resilient-routing-with-failures","title":"Step 5: Resilient Routing with Failures","text":"<p>Production systems experience failures. An agent might crash, or a protocol endpoint might become unavailable. Resilient routing finds alternative paths that avoid failed components.</p> <pre><code>from agenticraft_foundation.protocols import ResilientRouter\n\nrouter = ResilientRouter(graph, compat, calc)\nresilient = router.find_resilient_route(\n    \"gateway\", \"reporter\", ProtocolName.A2A,\n    failed_protocols=set(), failed_agents={\"analyzer\"},\n)\nprint(f\"Failover path: {resilient.path}\")\n</code></pre> <p>With the analyzer down, the only path from gateway to reporter is through the executor. The resilient router finds this path automatically. You can also specify failed protocols -- for example, if the MCP endpoint is down across the entire network, the router will only use A2A links.</p> <p>This is particularly useful in self-healing mesh architectures where the routing table must be recomputed dynamically as agents come and go.</p>"},{"location":"tutorials/protocol-routing/#step-6-workflow-validation","title":"Step 6: Workflow Validation","text":"<p>A workflow defines a sequence of tasks with dependencies, where each task requires specific capabilities and supports specific protocols. Workflow validation checks whether the agent graph can actually execute the workflow.</p> <pre><code>from agenticraft_foundation.protocols import (\n    ProtocolWorkflow, WorkflowTask, WorkflowValidator,\n    OptimalProtocolAssigner,\n)\n\nworkflow = ProtocolWorkflow(workflow_id=\"data_pipeline\")\nworkflow.add_task(WorkflowTask(\n    task_id=\"extract\", capabilities=[\"data_access\"],\n    compatible_protocols={ProtocolName.MCP, ProtocolName.A2A},\n))\nworkflow.add_task(WorkflowTask(\n    task_id=\"transform\", capabilities=[\"processing\"],\n    compatible_protocols={ProtocolName.MCP},\n))\nworkflow.add_task(WorkflowTask(\n    task_id=\"load\", capabilities=[\"storage\"],\n    compatible_protocols={ProtocolName.MCP, ProtocolName.A2A},\n))\nworkflow.add_edge(\"extract\", \"transform\")\nworkflow.add_edge(\"transform\", \"load\")\n\nvalidator = WorkflowValidator()\nresult = validator.validate(workflow, graph, compat)\nprint(f\"Valid: {result.is_valid}\")\n\nassigner = OptimalProtocolAssigner()\nassignment = assigner.assign(workflow, graph, compat, calc)\nprint(f\"Protocol assignment: {assignment}\")\n</code></pre> <p>The <code>WorkflowValidator</code> checks that every task in the workflow can be assigned to at least one agent in the graph with the required capabilities and a compatible protocol. It also checks that the data flow between tasks has a valid protocol path.</p> <p>The <code>OptimalProtocolAssigner</code> goes further: it finds the assignment of protocols to tasks that minimizes the total cost across the entire workflow. Since the <code>transform</code> task only supports MCP, the assigner will choose MCP for the whole pipeline to avoid protocol transitions.</p>"},{"location":"tutorials/protocol-routing/#complete-script","title":"Complete Script","text":"<pre><code>\"\"\"Protocol Routing Tutorial - Complete Script\n\nBuilds a protocol graph, routes with Dijkstra and BFS,\nhandles failures with resilient routing, and validates workflows.\n\"\"\"\nfrom agenticraft_foundation.protocols import (\n    ProtocolGraph,\n    ProtocolCompatibilityMatrix, PathCostCalculator,\n    PROTOCOL_COMPATIBILITY,\n    ProtocolAwareDijkstra, ProtocolConstrainedBFS,\n    ResilientRouter,\n    ProtocolWorkflow, WorkflowTask, WorkflowValidator,\n    OptimalProtocolAssigner,\n)\nfrom agenticraft_foundation.types import ProtocolName\n\n# Step 1: Build protocol graph\ngraph = ProtocolGraph()\ngraph.add_agent(\"gateway\", [\"routing\"], {ProtocolName.MCP, ProtocolName.A2A})\ngraph.add_agent(\"analyzer\", [\"analysis\"], {ProtocolName.MCP})\ngraph.add_agent(\"executor\", [\"execution\"], {ProtocolName.A2A})\ngraph.add_agent(\"reporter\", [\"output\"], {ProtocolName.MCP, ProtocolName.A2A})\n\ngraph.add_edge(\"gateway\", \"analyzer\", {ProtocolName.MCP})\ngraph.add_edge(\"gateway\", \"executor\", {ProtocolName.A2A})\ngraph.add_edge(\"analyzer\", \"reporter\", {ProtocolName.MCP})\ngraph.add_edge(\"executor\", \"reporter\", {ProtocolName.A2A})\n\n# Step 2: Set up routing infrastructure\ncompat = ProtocolCompatibilityMatrix(PROTOCOL_COMPATIBILITY)\ncalc = PathCostCalculator(graph, compat)\n\n# Step 3: Dijkstra routing\ndijkstra = ProtocolAwareDijkstra(graph, compat, calc)\nroute = dijkstra.find_optimal_route(\"gateway\", \"reporter\", ProtocolName.MCP)\nprint(f\"Path: {route.path}\")\nprint(f\"Total cost: {route.total_cost:.2f}\")\nprint(f\"Protocols used: {route.protocols_used}\")\n\n# Step 4: BFS routing\nbfs = ProtocolConstrainedBFS(graph, compat, calc)\nshortest = bfs.find_shortest_path(\"gateway\", \"reporter\", ProtocolName.MCP)\nprint(f\"Path: {shortest.path}\")\nprint(f\"Hops: {shortest.num_hops}\")\n\n# Step 5: Resilient routing\nrouter = ResilientRouter(graph, compat, calc)\nresilient = router.find_resilient_route(\n    \"gateway\", \"reporter\", ProtocolName.A2A,\n    failed_protocols=set(), failed_agents={\"analyzer\"},\n)\nprint(f\"Failover path: {resilient.path}\")\n\n# Step 6: Workflow validation\nworkflow = ProtocolWorkflow(workflow_id=\"data_pipeline\")\nworkflow.add_task(WorkflowTask(\n    task_id=\"extract\", capabilities=[\"data_access\"],\n    compatible_protocols={ProtocolName.MCP, ProtocolName.A2A},\n))\nworkflow.add_task(WorkflowTask(\n    task_id=\"transform\", capabilities=[\"processing\"],\n    compatible_protocols={ProtocolName.MCP},\n))\nworkflow.add_task(WorkflowTask(\n    task_id=\"load\", capabilities=[\"storage\"],\n    compatible_protocols={ProtocolName.MCP, ProtocolName.A2A},\n))\nworkflow.add_edge(\"extract\", \"transform\")\nworkflow.add_edge(\"transform\", \"load\")\n\nvalidator = WorkflowValidator()\nresult = validator.validate(workflow, graph, compat)\nprint(f\"Valid: {result.is_valid}\")\n\nassigner = OptimalProtocolAssigner()\nassignment = assigner.assign(workflow, graph, compat, calc)\nprint(f\"Protocol assignment: {assignment}\")\n</code></pre>"},{"location":"tutorials/protocol-routing/#next-steps","title":"Next Steps","text":"<ul> <li>Read Protocol Concepts for the theory behind protocol-aware routing</li> <li>Explore the Protocols API Reference for advanced graph operations and custom cost functions</li> <li>Continue to Analyzing Mesh Topologies to learn about spectral analysis of agent networks</li> </ul>"},{"location":"tutorials/temporal-verification/","title":"Checking Temporal Properties with CTL","text":"<p>Time: 15 minutes</p> <p>In this tutorial, you will build an LTS from a CSP process, define temporal properties using CTL formulas, and use the model checker to verify safety, liveness, and response properties.</p>"},{"location":"tutorials/temporal-verification/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li><code>agenticraft-foundation</code> installed</li> <li>Familiarity with CSP basics (see Modeling Agent Coordination with CSP)</li> </ul>"},{"location":"tutorials/temporal-verification/#what-youll-build","title":"What You'll Build","text":"<p>A task-processing agent modeled in CSP that can succeed, fail, or retry. You will:</p> <ol> <li>Build an LTS from a CSP process</li> <li>Label states with atomic propositions</li> <li>Check safety properties with AG (\"always globally\")</li> <li>Check liveness properties with AF (\"always eventually\")</li> <li>Check response properties with AU (\"always until\")</li> <li>Interpret counterexamples when properties fail</li> </ol>"},{"location":"tutorials/temporal-verification/#step-1-build-the-agent-process","title":"Step 1: Build the Agent Process","text":"<p>Start with a simple agent that receives a request, processes it, and either succeeds or encounters an error. On error, the agent can retry.</p> <pre><code>from agenticraft_foundation import (\n    Event, Prefix, ExternalChoice, Stop, Skip,\n    Recursion, Variable, build_lts,\n)\n\nreq = Event(\"request\")\nprocess = Event(\"process\")\nsuccess = Event(\"success\")\nerror = Event(\"error\")\nretry = Event(\"retry\")\n\n# Agent: request \u2192 process \u2192 (success | error \u2192 retry \u2192 recurse)\nbody = Prefix(req, Prefix(process, ExternalChoice(\n    Prefix(success, Skip()),\n    Prefix(error, Prefix(retry, Variable(\"X\"))),\n)))\nagent = Recursion(variable=\"X\", body=body)\n\nlts = build_lts(agent, max_states=50)\nprint(f\"States: {len(lts.states)}, Transitions: {len(lts.transitions)}\")\n</code></pre> <p>The agent loops: on error it retries the entire sequence. On success it terminates. The <code>max_states</code> parameter bounds exploration for recursive processes.</p>"},{"location":"tutorials/temporal-verification/#step-2-label-states-with-atomic-propositions","title":"Step 2: Label States with Atomic Propositions","text":"<p>CTL formulas reference atomic propositions -- labels attached to states. You define a labeling function that maps each state ID to a set of proposition names.</p> <pre><code>labeling = {s: set() for s in lts.states}\n\n# Label the initial state\nlabeling[lts.initial_state].add(\"init\")\n\n# Label states based on their outgoing transitions\nfor s in lts.states:\n    outgoing = {e for e, _ in lts.successors(s)}\n    if not outgoing:\n        labeling[s].add(\"terminal\")\n    if Event(\"success\") in outgoing:\n        labeling[s].add(\"can_succeed\")\n    if Event(\"error\") in outgoing:\n        labeling[s].add(\"can_fail\")\n\nprint(f\"Labeled {sum(len(v) for v in labeling.values())} propositions across {len(lts.states)} states\")\n</code></pre> <p>The labeling connects the LTS structure to the properties you want to verify. You can label states however you like -- by outgoing events, by state identity, or by any computed property.</p>"},{"location":"tutorials/temporal-verification/#step-3-check-safety-errors-dont-get-stuck","title":"Step 3: Check Safety -- \"Errors Don't Get Stuck\"","text":"<p>A safety property says something bad never happens. Use <code>AG(Not(...))</code> to express \"in all reachable states, the bad thing doesn't hold.\"</p> <pre><code>from agenticraft_foundation.verification import (\n    model_check, AG, AF, Not, Atomic, check_safety,\n)\n\n# Safety: terminal states are never reached from error\n# (i.e., errors always lead to retry, not deadlock)\nresult = model_check(lts, AG(Not(Atomic(\"terminal\"))), labeling)\nprint(f\"No terminal states: {result.satisfied}\")\nprint(f\"States satisfying AG(\u00acterminal): {len(result.satisfying_states)}\")\n</code></pre> <p>If the property fails, <code>result.counterexample</code> contains a trace leading to a violating state. In this agent, terminal states exist (after success), so this property will fail -- which is correct. Let's ask a better question:</p> <pre><code># Convenience function: check_safety checks AG(\u00acprop)\nresult = check_safety(lts, \"can_fail\", labeling)\nprint(f\"Never in can_fail state: {result.satisfied}\")\n# This will be False -- the agent CAN reach error states, by design\n</code></pre>"},{"location":"tutorials/temporal-verification/#step-4-check-liveness-success-is-always-reachable","title":"Step 4: Check Liveness -- \"Success Is Always Reachable\"","text":"<p>A liveness property says something good eventually happens. Use <code>AF(...)</code> to express \"on all paths, the good thing eventually holds.\"</p> <pre><code>from agenticraft_foundation.verification import check_liveness\n\n# Liveness: from the initial state, can the agent always eventually succeed?\nresult = check_liveness(lts, \"can_succeed\", labeling)\nprint(f\"Always eventually can succeed: {result.satisfied}\")\n</code></pre> <p>This checks whether every execution path eventually reaches a state labeled <code>can_succeed</code>. For the retry agent, this depends on whether the recursion always makes progress toward success.</p>"},{"location":"tutorials/temporal-verification/#step-5-check-reachability-success-is-possible","title":"Step 5: Check Reachability -- \"Success Is Possible\"","text":"<p>Sometimes you want a weaker property: not that something always happens, but that it can happen. Use <code>EF(...)</code> for existential reachability.</p> <pre><code>from agenticraft_foundation.verification import EF\n\n# Reachability: is there at least one path to success?\nresult = model_check(lts, EF(Atomic(\"can_succeed\")), labeling)\nprint(f\"Success reachable: {result.satisfied}\")\nprint(f\"States that can reach success: {len(result.satisfying_states)}\")\n</code></pre> <p><code>EF(\u03c6)</code> asks: \"does there exist a path from this state that eventually reaches a state where \u03c6 holds?\" This is useful for checking that success is possible, even if not guaranteed.</p>"},{"location":"tutorials/temporal-verification/#step-6-check-response-every-request-gets-a-response","title":"Step 6: Check Response -- \"Every Request Gets a Response\"","text":"<p>Response properties combine two formulas with <code>AU</code> (always until): \"\u03c6 holds at every step until \u03c8 becomes true, and \u03c8 eventually does become true.\"</p> <pre><code>from agenticraft_foundation.verification import AU, Or\n\n# First, add more labels for this check\nfor s in lts.states:\n    outgoing = {e for e, _ in lts.successors(s)}\n    if Event(\"request\") in outgoing:\n        labeling[s].add(\"waiting\")\n    if Event(\"success\") in outgoing or Event(\"error\") in outgoing:\n        labeling[s].add(\"responded\")\n\n# Response: after init, the agent is either waiting or has responded,\n# until it reaches a terminal or can_succeed state\nresult = model_check(\n    lts,\n    AU(\n        Or(Atomic(\"waiting\"), Atomic(\"responded\")),\n        Atomic(\"can_succeed\"),\n    ),\n    labeling,\n)\nprint(f\"Response property: {result.satisfied}\")\n</code></pre>"},{"location":"tutorials/temporal-verification/#step-7-interpret-counterexamples","title":"Step 7: Interpret Counterexamples","text":"<p>When a property fails, the model checker provides a counterexample trace -- a concrete path demonstrating the violation.</p> <pre><code># This safety property will fail (terminal states exist after success)\nresult = model_check(lts, AG(Not(Atomic(\"terminal\"))), labeling)\nif not result.satisfied:\n    print(f\"Property violated!\")\n    if result.counterexample:\n        print(f\"Counterexample trace: {result.counterexample}\")\n    print(f\"States violating property: {len(lts.states) - len(result.satisfying_states)}\")\n</code></pre> <p>The counterexample is a sequence of events leading from the initial state to a state that violates the property. Use it to understand why a property fails and whether the failure is a genuine bug or an expected behavior.</p>"},{"location":"tutorials/temporal-verification/#complete-script","title":"Complete Script","text":"<pre><code>\"\"\"Temporal Verification Tutorial - Complete Script\n\nBuilds a retry agent in CSP, then checks safety, liveness,\nand response properties using CTL model checking.\n\"\"\"\nfrom agenticraft_foundation import (\n    Event, Prefix, ExternalChoice, Stop, Skip,\n    Recursion, Variable, build_lts,\n)\nfrom agenticraft_foundation.verification import (\n    model_check, AG, AF, EF, AU, Not, Or, Atomic,\n    check_safety, check_liveness,\n)\n\n# Step 1: Build the agent\nreq = Event(\"request\")\nprocess = Event(\"process\")\nsuccess = Event(\"success\")\nerror = Event(\"error\")\nretry = Event(\"retry\")\n\nbody = Prefix(req, Prefix(process, ExternalChoice(\n    Prefix(success, Skip()),\n    Prefix(error, Prefix(retry, Variable(\"X\"))),\n)))\nagent = Recursion(variable=\"X\", body=body)\nlts = build_lts(agent, max_states=50)\nprint(f\"States: {len(lts.states)}, Transitions: {len(lts.transitions)}\")\n\n# Step 2: Label states\nlabeling = {s: set() for s in lts.states}\nlabeling[lts.initial_state].add(\"init\")\nfor s in lts.states:\n    outgoing = {e for e, _ in lts.successors(s)}\n    if not outgoing:\n        labeling[s].add(\"terminal\")\n    if Event(\"success\") in outgoing:\n        labeling[s].add(\"can_succeed\")\n    if Event(\"error\") in outgoing:\n        labeling[s].add(\"can_fail\")\n\n# Step 3: Safety\nresult = check_safety(lts, \"can_fail\", labeling)\nprint(f\"Never can_fail: {result.satisfied}\")\n\n# Step 4: Liveness\nresult = check_liveness(lts, \"can_succeed\", labeling)\nprint(f\"Always eventually can_succeed: {result.satisfied}\")\n\n# Step 5: Reachability\nresult = model_check(lts, EF(Atomic(\"can_succeed\")), labeling)\nprint(f\"Success reachable: {result.satisfied}\")\n\n# Step 6: Response\nfor s in lts.states:\n    outgoing = {e for e, _ in lts.successors(s)}\n    if Event(\"request\") in outgoing:\n        labeling[s].add(\"waiting\")\n    if Event(\"success\") in outgoing or Event(\"error\") in outgoing:\n        labeling[s].add(\"responded\")\n\nresult = model_check(\n    lts,\n    AU(Or(Atomic(\"waiting\"), Atomic(\"responded\")), Atomic(\"can_succeed\")),\n    labeling,\n)\nprint(f\"Response property: {result.satisfied}\")\n\n# Step 7: Counterexample\nresult = model_check(lts, AG(Not(Atomic(\"terminal\"))), labeling)\nif not result.satisfied and result.counterexample:\n    print(f\"Counterexample: {result.counterexample}\")\n</code></pre>"},{"location":"tutorials/temporal-verification/#next-steps","title":"Next Steps","text":"<ul> <li>Read Verification Concepts for the formal foundations behind CTL model checking</li> <li>Continue to Modeling Stochastic Agents with DTMC to analyze probabilistic agent behavior</li> <li>See the Temporal Logic API Reference for the complete formula AST and model checker API</li> </ul>"},{"location":"tutorials/topology-analysis/","title":"Analyzing Mesh Topologies","text":"<p>Time: 15 minutes</p> <p>In this tutorial, you will create several common agent network topologies, analyze their spectral properties to understand how well they support consensus, and use hypergraphs to model group coordination patterns.</p>"},{"location":"tutorials/topology-analysis/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li><code>agenticraft-foundation</code> installed</li> <li>Basic understanding of graph structure (nodes, edges)</li> </ul>"},{"location":"tutorials/topology-analysis/#what-youll-build","title":"What You'll Build","text":"<p>A topology analysis workbench that compares full mesh, ring, and star topologies using spectral metrics. You will:</p> <ol> <li>Create a full mesh topology and compute its spectral properties</li> <li>Create ring and star topologies for comparison</li> <li>Compare topologies using algebraic connectivity and consensus bounds</li> <li>Build a hypergraph for group coordination analysis</li> </ol>"},{"location":"tutorials/topology-analysis/#step-1-create-a-full-mesh-topology","title":"Step 1: Create a Full Mesh Topology","text":"<p>A full mesh is the ideal topology for consensus: every agent is directly connected to every other agent. Information flows in a single hop between any pair of agents.</p> <pre><code>from agenticraft_foundation.topology import NetworkGraph, LaplacianAnalysis\n\nmesh = NetworkGraph()\nn = 5\nfor i in range(n):\n    mesh.add_node(f\"agent_{i}\")\nfor i in range(n):\n    for j in range(i + 1, n):\n        mesh.add_edge(f\"agent_{i}\", f\"agent_{j}\")\n\nanalysis = LaplacianAnalysis(mesh)\nprint(f\"Nodes: {analysis.num_nodes}\")\nprint(f\"Edges: {analysis.num_edges}\")\nprint(f\"Algebraic connectivity (lambda_2): {analysis.algebraic_connectivity:.4f}\")\nprint(f\"Consensus bound: {analysis.consensus_bound:.2f}\")\n</code></pre> <p>The algebraic connectivity (\\(\\lambda_2\\)) is the second-smallest eigenvalue of the graph's Laplacian matrix. It is the single most important metric for consensus in distributed systems. A higher \\(\\lambda_2\\) means faster consensus convergence. For a full mesh with \\(n\\) nodes, \\(\\lambda_2\\) equals \\(n\\), which is the theoretical maximum for that number of nodes.</p> <p>The consensus bound is derived from \\(\\lambda_2\\) and provides an upper bound on the number of communication rounds needed for the network to converge to agreement.</p>"},{"location":"tutorials/topology-analysis/#step-2-create-ring-and-star-topologies","title":"Step 2: Create Ring and Star Topologies","text":"<p>Real networks are rarely full meshes. Rings and stars are two common alternatives that trade connectivity for simplicity.</p> <pre><code># Ring topology\nring = NetworkGraph()\nfor i in range(n):\n    ring.add_node(f\"agent_{i}\")\nfor i in range(n):\n    ring.add_edge(f\"agent_{i}\", f\"agent_{(i+1) % n}\")\n\nring_analysis = LaplacianAnalysis(ring)\nprint(f\"Ring lambda_2: {ring_analysis.algebraic_connectivity:.4f}\")\n\n# Star topology\nstar = NetworkGraph()\nstar.add_node(\"hub\")\nfor i in range(n - 1):\n    star.add_node(f\"agent_{i}\")\n    star.add_edge(\"hub\", f\"agent_{i}\")\n\nstar_analysis = LaplacianAnalysis(star)\nprint(f\"Star lambda_2: {star_analysis.algebraic_connectivity:.4f}\")\n</code></pre> <p>The ring topology connects each agent to its two neighbors, forming a circle. Information must travel through multiple hops to reach distant agents, which means slower consensus. \\(\\lambda_2\\) for a ring is approximately \\(2 - 2\\cos(2\\pi/n)\\), which is much smaller than the full mesh value.</p> <p>The star topology connects all agents through a central hub. While it has the same number of edges as the ring (n edges), its structure allows information to flow from any agent to any other in just 2 hops. However, the hub is a single point of failure.</p>"},{"location":"tutorials/topology-analysis/#step-3-compare-topologies","title":"Step 3: Compare Topologies","text":"<p>Putting the metrics side by side reveals the trade-offs clearly.</p> <pre><code>print(f\"{'Topology':&lt;12} {'lambda_2':&gt;10} {'Consensus bound':&gt;16}\")\nprint(\"-\" * 40)\nfor name, a in [(\"Full mesh\", analysis), (\"Ring\", ring_analysis), (\"Star\", star_analysis)]:\n    print(f\"{name:&lt;12} {a.algebraic_connectivity:&gt;10.4f} {a.consensus_bound:&gt;16.2f}\")\n</code></pre> <p>You will see that the full mesh has the highest \\(\\lambda_2\\) and the lowest consensus bound (fastest convergence). The star falls in between, and the ring has the lowest \\(\\lambda_2\\) and the highest consensus bound (slowest convergence).</p> <p>This comparison is not just academic. In a multi-agent system with 50 agents, the difference between a ring and a mesh topology can mean the difference between consensus in 5 rounds and consensus in 50 rounds. The spectral analysis gives you a quantitative basis for choosing your network topology.</p> <p>The trade-off, of course, is the number of connections: a full mesh with \\(n\\) nodes requires \\(n(n-1)/2\\) edges, which becomes impractical for large networks. This is why real systems use topologies that balance connectivity with operational complexity.</p>"},{"location":"tutorials/topology-analysis/#step-4-build-a-hypergraph-for-group-coordination","title":"Step 4: Build a Hypergraph for Group Coordination","text":"<p>Standard graphs model pairwise connections. But in multi-agent systems, agents often coordinate in groups -- a team meeting, a broadcast channel, or a shared workspace. Hypergraphs generalize graphs by allowing edges (called hyperedges) to connect any number of nodes simultaneously.</p> <pre><code>from agenticraft_foundation.topology import HypergraphNetwork\n\nhg = HypergraphNetwork()\nhg.add_hyperedge(\"team_a\", {\"agent_0\", \"agent_1\", \"agent_2\"}, weight=2.0)\nhg.add_hyperedge(\"team_b\", {\"agent_1\", \"agent_2\", \"agent_3\"}, weight=1.5)\nhg.add_hyperedge(\"all_hands\", {\"agent_0\", \"agent_1\", \"agent_2\", \"agent_3\"})\n\nhg_analysis = hg.analyze()\nprint(f\"Hypergraph lambda_2: {hg_analysis.algebraic_connectivity:.4f}\")\nprint(f\"Consensus bound: {hg_analysis.consensus_bound:.2f}\")\nprint(f\"Connected: {hg_analysis.is_connected}\")\n\ncoord = hg.analyze_group_coordination()\nprint(f\"Participation ratio: {coord['participation_ratio']:.2f}\")\nprint(f\"Average group size: {coord['avg_group_size']:.1f}\")\n</code></pre> <p>Each hyperedge has a name, a set of member nodes, and an optional weight. The weight represents the coordination capacity of the group -- a team with a weight of 2.0 can propagate information twice as fast as a team with the default weight of 1.0.</p> <p>The hypergraph analysis computes spectral properties using the hypergraph Laplacian, which generalizes the standard graph Laplacian. The participation ratio measures how evenly agents are distributed across groups (1.0 means perfectly even, lower values indicate some agents participate in many more groups than others). The average group size gives you a sense of the coordination overhead.</p> <p>This analysis is particularly useful for designing multi-agent systems with team-based coordination, where you need to balance team sizes, overlap between teams, and the overall connectivity of the coordination structure.</p>"},{"location":"tutorials/topology-analysis/#complete-script","title":"Complete Script","text":"<pre><code>\"\"\"Topology Analysis Tutorial - Complete Script\n\nCompares mesh, ring, and star topologies using spectral analysis,\nthen builds a hypergraph for group coordination analysis.\n\"\"\"\nfrom agenticraft_foundation.topology import (\n    NetworkGraph, LaplacianAnalysis, HypergraphNetwork,\n)\n\n# Step 1: Full mesh topology\nn = 5\nmesh = NetworkGraph()\nfor i in range(n):\n    mesh.add_node(f\"agent_{i}\")\nfor i in range(n):\n    for j in range(i + 1, n):\n        mesh.add_edge(f\"agent_{i}\", f\"agent_{j}\")\n\nanalysis = LaplacianAnalysis(mesh)\nprint(f\"Nodes: {analysis.num_nodes}\")\nprint(f\"Edges: {analysis.num_edges}\")\nprint(f\"Algebraic connectivity (lambda_2): {analysis.algebraic_connectivity:.4f}\")\nprint(f\"Consensus bound: {analysis.consensus_bound:.2f}\")\n\n# Step 2: Ring and star topologies\nring = NetworkGraph()\nfor i in range(n):\n    ring.add_node(f\"agent_{i}\")\nfor i in range(n):\n    ring.add_edge(f\"agent_{i}\", f\"agent_{(i+1) % n}\")\n\nring_analysis = LaplacianAnalysis(ring)\nprint(f\"Ring lambda_2: {ring_analysis.algebraic_connectivity:.4f}\")\n\nstar = NetworkGraph()\nstar.add_node(\"hub\")\nfor i in range(n - 1):\n    star.add_node(f\"agent_{i}\")\n    star.add_edge(\"hub\", f\"agent_{i}\")\n\nstar_analysis = LaplacianAnalysis(star)\nprint(f\"Star lambda_2: {star_analysis.algebraic_connectivity:.4f}\")\n\n# Step 3: Compare topologies\nprint(f\"\\n{'Topology':&lt;12} {'lambda_2':&gt;10} {'Consensus bound':&gt;16}\")\nprint(\"-\" * 40)\nfor name, a in [(\"Full mesh\", analysis), (\"Ring\", ring_analysis), (\"Star\", star_analysis)]:\n    print(f\"{name:&lt;12} {a.algebraic_connectivity:&gt;10.4f} {a.consensus_bound:&gt;16.2f}\")\n\n# Step 4: Hypergraph for group coordination\nhg = HypergraphNetwork()\nhg.add_hyperedge(\"team_a\", {\"agent_0\", \"agent_1\", \"agent_2\"}, weight=2.0)\nhg.add_hyperedge(\"team_b\", {\"agent_1\", \"agent_2\", \"agent_3\"}, weight=1.5)\nhg.add_hyperedge(\"all_hands\", {\"agent_0\", \"agent_1\", \"agent_2\", \"agent_3\"})\n\nhg_analysis = hg.analyze()\nprint(f\"\\nHypergraph lambda_2: {hg_analysis.algebraic_connectivity:.4f}\")\nprint(f\"Consensus bound: {hg_analysis.consensus_bound:.2f}\")\nprint(f\"Connected: {hg_analysis.is_connected}\")\n\ncoord = hg.analyze_group_coordination()\nprint(f\"Participation ratio: {coord['participation_ratio']:.2f}\")\nprint(f\"Average group size: {coord['avg_group_size']:.1f}\")\n</code></pre>"},{"location":"tutorials/topology-analysis/#next-steps","title":"Next Steps","text":"<ul> <li>Read Topology Concepts for the mathematical foundations of spectral graph theory</li> <li>Explore the Topology API Reference for weighted graphs, directed graphs, and advanced spectral methods</li> <li>Continue to Formal Consensus Verification to verify consensus properties directly</li> </ul>"}]}